<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="lj">
    
    <title>
        
            C++构造函数 |
        
        LjBlog
    </title>
    
<link rel="stylesheet" href="/HexoBlog/css/style.css">

    <link rel="shortcut icon" href="/HexoBlog/images/logo.svg">
    
<link rel="stylesheet" href="/HexoBlog/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"ljkk23.github.io","root":"/HexoBlog/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/HexoBlog/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                LjBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">C++构造函数</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/HexoBlog/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">lj</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-04-07 16:07:45</span>
        <span class="mobile">2022-04-07 16:07</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/categories/C/">C++</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/tags/C/">C++</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。<br><br></p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line();  &#x2F;&#x2F; 这是构造函数
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    cout &lt;&lt; &quot;创建!&quot; &lt;&lt; endl;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line;
 
   &#x2F;&#x2F; 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;长度 &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建!
长度 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值<br><br></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line(double len);  &#x2F;&#x2F; 这是构造函数
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line( double len)
&#123;
    cout &lt;&lt; &quot;创建！长度为：&quot; &lt;&lt; len &lt;&lt; endl;
    length &#x3D; len;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line(10.0);
 
   &#x2F;&#x2F; 获取默认设置的长度
   cout &lt;&lt; &quot;长度 &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
   &#x2F;&#x2F; 再次设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;长度 &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建！长度为：10
长度 10
长度 6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="为什么需要构造函数"><a href="#为什么需要构造函数" class="headerlink" title="为什么需要构造函数"></a>为什么需要构造函数</h4><ul>
<li>设置构造函数的初衷，很多程序错误，是对象(变量)未能初始化引起的，故设置一个构造函数，自动调用它来进行初始化，以避免这类错误</li>
<li>理解：我们讲究面向对象，那么作为一个对象，他生来就与众不同，就和人一样，并不是出生后在进行塑性，构造函数使得编程更加符合面向对象的要求，更加自然。</li>
<li>初始化成员变量，分配内存空间。</li>
<li>一般情况下（指类成员没有指针的情况）自定义类有没有构造函数影响不大。（但使用时要注意，因为默认构造函数下，成员是不被初始化的。）但如果有指针，而你又没有定义构造函数，那问题就大了。（使用没有初始化的指针会有什么问题？是不可预想的。）</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>让类进行自动初始化，为指针分配空间  </li>
<li>用于在创建不同对象时用不同的值初始化不同对象的各种数据元素</li>
</ul>
<h4 id="重载函数"><a href="#重载函数" class="headerlink" title="重载函数"></a>重载函数</h4><p>重载函数是函数的一种特殊情况，为方便使用，C++允许在同一范围中声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同，也就是说用同一个函数完成不同的功能。 这就是重载函数。 重载函数常用来实现功能类似而所处理的数据类型不同的问题。 不能只有函数返回值类型不同。构造函数可以重载。</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>上述中构造函数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Line::Line( double len)
&#123;
    length &#x3D; len;
    cout &lt;&lt; &quot;创建！长度为：&quot; &lt;&lt; len &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以使用下面方法代替：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Line::Line( double len): length(len)
&#123;
    cout &lt;&lt; &quot;创建！长度为：&quot; &lt;&lt; len &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然当有多个值需初始化时就是下面这种格式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">C::C( double a, double b, double c): x(a), y(b), z(c)
&#123;
  ....
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。<br><br><br>一个类有且仅有一个析构函数。如果定义类时没写析构函数，则编译器生成默认析构函数。如果定义了析构函数，则编译器不生成默认析构函数。<br><br><br>析构函数在对象消亡时即自动被调用。可以定义析构函数在对象消亡前做善后工作。例如，对象如果在生存期间用 new 运算符动态分配了内存，则在各处写 delete 语句以确保程序的每条执行路径都能释放这片内存是比较麻烦的事情。有了析构函数，只要在析构函数中调用 delete 语句，就能确保对象运行中用 new 运算符分配的空间在对象消亡时被释放。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line();   &#x2F;&#x2F; 构造函数声明
      ~Line();  &#x2F;&#x2F; 析构函数声明
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    cout &lt;&lt; &quot;创建！&quot; &lt;&lt; endl;
&#125;
Line::~Line(void)
&#123;
    cout &lt;&lt; &quot;销毁！&quot; &lt;&lt; endl;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line;
 
   &#x2F;&#x2F; 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;长度为：&quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建！
长度为：6
销毁！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：</p>
<ul>
<li><p>通过使用另一个同类型的对象来初始化新创建的对象。</p>
</li>
<li><p>复制对象把它作为参数传递给函数。</p>
</li>
<li><p>复制对象，并从函数返回这个对象。</p>
</li>
</ul>
<p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">classname (const classname &amp;obj) &#123;
   &#x2F;&#x2F; 构造函数的主体
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。<br><br></p>
<p>为什么是对象引用：防止无限递归，如果是传值即Line(Line obj)，那就要先复制一份，复制会调用拷贝构造函数，无限递归，所以要用引用，至于不用指针，效率问题。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line();   &#x2F;&#x2F; 构造函数声明
      Line(const Line &amp;obj); &#x2F;&#x2F;拷贝函数声明
      ~Line();  &#x2F;&#x2F; 析构函数声明
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    cout &lt;&lt; &quot;创建！&quot; &lt;&lt; endl;
&#125;
Line::Line(const Line &amp;obj)
&#123;
    length&#x3D;obj.length;
    cout &lt;&lt; &quot;拷贝！&quot; &lt;&lt; endl;
&#125;
Line::~Line(void)
&#123;
    cout &lt;&lt; &quot;销毁！&quot; &lt;&lt; endl;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line1;
 
   &#x2F;&#x2F; 设置长度
   line1.setLength(6.0); 
   cout &lt;&lt; &quot;line1长度为：&quot; &lt;&lt; line1.getLength() &lt;&lt;endl;
   Line line2 &#x3D; line1;
   cout &lt;&lt; &quot;line2长度为：&quot; &lt;&lt; line2.getLength() &lt;&lt;endl;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建！
line1长度为：6
拷贝！
line2长度为：6
销毁！
销毁！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h4><ul>
<li><p>浅拷贝：将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用</p>
</li>
<li><p>深拷贝：创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”</p>
</li>
</ul>
<h5 id="为什么要使用深拷贝？"><a href="#为什么要使用深拷贝？" class="headerlink" title="为什么要使用深拷贝？"></a>为什么要使用深拷贝？</h5><p>我们希望在改变新的数组（对象）的时候，不改变原数组（对象）</p>
<h5 id="怎么检验深拷贝成功"><a href="#怎么检验深拷贝成功" class="headerlink" title="怎么检验深拷贝成功"></a>怎么检验深拷贝成功</h5><p>改变任意一个新对象数组中的属性元素，都不改变原对象&#x2F;数组</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;

using namespace std;

class Line
&#123;
public:
    void setLength(double len);
    double getLength(void);
    Line(double len); &#x2F;&#x2F; 这是构造函数
private:
    double length;
&#125;;

&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(double len)
&#123;
    cout &lt;&lt; &quot;创建！长度为：&quot; &lt;&lt; len &lt;&lt; endl;
    length &#x3D; len;
&#125;

void Line::setLength(double len)
&#123;
    length &#x3D; len;
&#125;

double Line::getLength(void)
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main()
&#123;
    int a &#x3D; 1;
    int b &#x3D; a;
    cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;
    cout &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl;
    Line line1(10.0);
    Line line2 &#x3D; line1;
    cout &lt;&lt; &quot;line1长度 &quot; &lt;&lt; line1.getLength() &lt;&lt; endl;
    cout &lt;&lt; &quot;line2长度 &quot; &lt;&lt; line2.getLength() &lt;&lt; endl;

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">a:1
b:1
创建！长度为：10
line1长度 10
line2长度 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>b 和 line2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 line1 所在内存中的数据按照二进制位（Bit）复制到 b 和 line2 所在的内存，这种默认的拷贝行为就是浅拷贝。<br><br></p>
<h5 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h5><p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;malloc.h&gt;

using namespace std;

class Line
&#123;
public:
    void setLength(double len);
    double getLength(void);
    Line();                &#x2F;&#x2F; 构造函数声明
    Line(const Line &amp;obj); &#x2F;&#x2F;拷贝函数声明
    ~Line();               &#x2F;&#x2F; 析构函数声明

private:
    double *length;
&#125;;

&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    length &#x3D; (double *)malloc(sizeof(double));
    cout &lt;&lt; &quot;创建！&quot; &lt;&lt; endl;
&#125;
Line::Line(const Line &amp;obj)
&#123;
    length &#x3D; obj.length;
    cout &lt;&lt; &quot;拷贝！&quot; &lt;&lt; endl;
&#125;
&#x2F;* Line::Line(const Line &amp;obj)
&#123;
    length &#x3D; (double *)malloc(sizeof(double));
    *length &#x3D; *(obj.length);
    cout &lt;&lt; &quot;拷贝！&quot; &lt;&lt; endl;
&#125; *&#x2F;
Line::~Line(void)
&#123;
    cout &lt;&lt; &quot;销毁！&quot; &lt;&lt; endl;
&#125;

void Line::setLength(double len)
&#123;
    *length &#x3D; len;
&#125;

double Line::getLength(void)
&#123;
    return *length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main()
&#123;
    Line line1;
    &#x2F;&#x2F; 设置长度
    line1.setLength(6.0);
    cout &lt;&lt; &quot;line1长度为：&quot; &lt;&lt; line1.getLength() &lt;&lt; endl;
    Line line2 &#x3D; line1;
    cout &lt;&lt; &quot;line2长度为：&quot; &lt;&lt; line2.getLength() &lt;&lt; endl;
    &#x2F;&#x2F;修改line2
    line2.setLength(7.0);
    cout &lt;&lt; &quot;line1长度为：&quot; &lt;&lt; line1.getLength() &lt;&lt; endl;
    cout &lt;&lt; &quot;line2长度为：&quot; &lt;&lt; line2.getLength() &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>运行结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建！
line1长度为：6
拷贝！
line2长度为：6
line1长度为：7
line2长度为：7
销毁！
销毁！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>使用深拷贝：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建！
line1长度为：6
拷贝！
line2长度为：6
line1长度为：6
line2长度为：7
销毁！
销毁！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 line2 的数据，就没有影响 line1。<br><br></p>
<p>这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝就可以。<br><br></p>
<p>另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，请看下面的例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;unistd.h&gt;

using namespace std;

class Line
&#123;
public:
    void setLength(double len);
    double getLength(void);
    time_t getTime(void);
    Line();                &#x2F;&#x2F; 构造函数声明
    Line(const Line &amp;obj); &#x2F;&#x2F;拷贝函数声明
    ~Line();               &#x2F;&#x2F; 析构函数声明

private:
    double length;
    time_t setTime;
&#125;;

&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    time(&amp;setTime);
    cout &lt;&lt; &quot;创建！&quot; &lt;&lt; endl;
&#125;
Line::Line(const Line &amp;obj)
&#123;
    length &#x3D; obj.length;
    time(&amp;setTime);
    cout &lt;&lt; &quot;拷贝！&quot; &lt;&lt; endl;
&#125;
Line::~Line(void)
&#123;
    cout &lt;&lt; &quot;销毁！&quot; &lt;&lt; endl;
&#125;

void Line::setLength(double len)
&#123;
    length &#x3D; len;
&#125;

double Line::getLength(void)
&#123;
    return length;
&#125;

time_t Line::getTime(void)
&#123;
    return setTime;
&#125;
&#x2F;&#x2F; 程序的主函数
int main()
&#123;
    Line line1;
    sleep(2);
    Line line2 &#x3D; line1;
    cout &lt;&lt; line1.getTime() &lt;&lt; endl;
    cout &lt;&lt; line2.getTime() &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:C++&#x2F;构造函数.md</p>
<h3 id="析构函数-1"><a href="#析构函数-1" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</li>
<li>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</li>
</ul>
<p>下面的实例有助于更好地理解析构函数的概念</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line();   &#x2F;&#x2F; 这是构造函数声明
      ~Line();  &#x2F;&#x2F; 这是析构函数声明
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;
&#125;
Line::~Line(void)
&#123;
    cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line;
 
   &#x2F;&#x2F; 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre class="line-numbers language-none"><code class="language-none">Object is being created
Length of line : 6
Object is being deleted<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="为什么需要构造函数-1"><a href="#为什么需要构造函数-1" class="headerlink" title="为什么需要构造函数"></a>为什么需要构造函数</h3><ul>
<li>设置构造函数的初衷，很多程序错误，是对象(变量)未能初始化引起的，故设置一个构造函数，自动调用它来进行初始化，以避免这类错误</li>
<li>初始化成员变量，分配内存空间。</li>
<li>一般情况下（指类成员没有指针的情况）自定义类有没有构造函数影响不大。（但使用时要注意，因为默认构造函数下，成员是不被初始化的。）但如果有指针，而你又没有定义构造函数，那问题就大了。（使用没有初始化的指针会有什么问题？是不可预想的。）  <h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li>
<li>让类进行自动初始化，为指针分配空间  </li>
<li><h1 id="用于在创建不同对象时用不同的值初始化不同对象的各种数据元素"><a href="#用于在创建不同对象时用不同的值初始化不同对象的各种数据元素" class="headerlink" title="用于在创建不同对象时用不同的值初始化不同对象的各种数据元素"></a>用于在创建不同对象时用不同的值初始化不同对象的各种数据元素</h1></li>
</ul>
<p>运行结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">创建！
拷贝！
1649322232
1649322234
销毁！
销毁！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="听讲笔记"><a href="#听讲笔记" class="headerlink" title="听讲笔记"></a>听讲笔记</h2><p>struct aaa{};、class aaa{};均可。只是struct默认变量属性是公开，class默认变量属性是私有。<br>构造函数可以用于类型转换。<br>函数参数可以设置默认值<br>int a(int t1&#x3D;45,int t2&#x3D;12,char t3&#x3D;’s’){}<br>默认值可以少写函数重载。且只能最后省。中间不能省。</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>d4e1b68ac96726e4a840033d3c6291956bfef180:c++&#x2F;构造函数.md</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/HexoBlog/tags/C/">#C++</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/HexoBlog/2022/04/19/SpringIOC/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">SpringIOC</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">lj</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">默认构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">为什么需要构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">重载函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.4.</span> <span class="nav-text">拷贝构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">深拷贝和浅拷贝的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">为什么要使用深拷贝？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%A3%80%E9%AA%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%88%90%E5%8A%9F"><span class="nav-number">1.1.4.2.2.</span> <span class="nav-text">怎么检验深拷贝成功</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.1.4.2.3.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.1.4.2.4.</span> <span class="nav-text">深拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.1.5.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.1.6.</span> <span class="nav-text">为什么需要构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">优点</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E5%9C%A8%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E5%90%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="nav-number">2.</span> <span class="nav-text">用于在创建不同对象时用不同的值初始化不同对象的各种数据元素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AC%E8%AE%B2%E7%AC%94%E8%AE%B0"><span class="nav-number">2.1.</span> <span class="nav-text">听讲笔记</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/HexoBlog/js/utils.js"></script>

<script src="/HexoBlog/js/main.js"></script>

<script src="/HexoBlog/js/header-shrink.js"></script>

<script src="/HexoBlog/js/back2top.js"></script>

<script src="/HexoBlog/js/dark-light-toggle.js"></script>





    
<script src="/HexoBlog/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/HexoBlog/js/left-side-toggle.js"></script>

<script src="/HexoBlog/js/libs/anime.min.js"></script>

<script src="/HexoBlog/js/toc.js"></script>

    
</div>



</body>
</html>

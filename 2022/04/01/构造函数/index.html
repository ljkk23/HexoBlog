<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="lj">
    
    <title>
        
        LjBlog
    </title>
    
<link rel="stylesheet" href="/HexoBlog/css/style.css">

    <link rel="shortcut icon" href="/HexoBlog/images/logo.svg">
    
<link rel="stylesheet" href="/HexoBlog/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"ljkk23.github.io","root":"/HexoBlog/","language":"zh-cn"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/HexoBlog/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                LjBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/archives">归档</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation"></span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/HexoBlog/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">lj</span>
                        
                            <span class="author-label">Lv1</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-04-01 22:50:54</span>
        <span class="mobile">2022-04-01 22:50</span>
    </span>
    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。<br><br></p>
<p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。</p>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line();  &#x2F;&#x2F; 这是构造函数
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line;
 
   &#x2F;&#x2F; 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值<br><br></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line(double len);  &#x2F;&#x2F; 这是构造函数
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line( double len)
&#123;
    cout &lt;&lt; &quot;Object is being created, length &#x3D; &quot; &lt;&lt; len &lt;&lt; endl;
    length &#x3D; len;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line(10.0);
 
   &#x2F;&#x2F; 获取默认设置的长度
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
   &#x2F;&#x2F; 再次设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="为什么需要构造函数"><a href="#为什么需要构造函数" class="headerlink" title="为什么需要构造函数"></a>为什么需要构造函数</h4><ul>
<li>设置构造函数的初衷，很多程序错误，是对象(变量)未能初始化引起的，故设置一个构造函数，自动调用它来进行初始化，以避免这类错误</li>
<li>初始化成员变量，分配内存空间。</li>
<li>一般情况下（指类成员没有指针的情况）自定义类有没有构造函数影响不大。（但使用时要注意，因为默认构造函数下，成员是不被初始化的。）但如果有指针，而你又没有定义构造函数，那问题就大了。（使用没有初始化的指针会有什么问题？是不可预想的。）</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>让类进行自动初始化，为指针分配空间  </li>
<li>用于在创建不同对象时用不同的值初始化不同对象的各种数据元素</li>
</ul>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>上述中构造函数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Line::Line( double len)
&#123;
    length &#x3D; len;
    cout &lt;&lt; &quot;Object is being created, length &#x3D; &quot; &lt;&lt; len &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>也可以使用下面方法代替：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Line::Line( double len): length(len)
&#123;
    cout &lt;&lt; &quot;Object is being created, length &#x3D; &quot; &lt;&lt; len &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>当然当有多个值需初始化时就是下面这种格式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">C::C( double a, double b, double c): X(a), Y(b), Z(c)
&#123;
  ....
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。<br><br><br>一个类有且仅有一个析构函数。如果定义类时没写析构函数，则编译器生成默认析构函数。如果定义了析构函数，则编译器不生成默认析构函数。<br><br><br>析构函数在对象消亡时即自动被调用。可以定义析构函数在对象消亡前做善后工作。例如，对象如果在生存期间用 new 运算符动态分配了内存，则在各处写 delete 语句以确保程序的每条执行路径都能释放这片内存是比较麻烦的事情。有了析构函数，只要在析构函数中调用 delete 语句，就能确保对象运行中用 new 运算符分配的空间在对象消亡时被释放。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line();   &#x2F;&#x2F; 这是构造函数声明
      ~Line();  &#x2F;&#x2F; 这是析构函数声明
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;
&#125;
Line::~Line(void)
&#123;
    cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line;
 
   &#x2F;&#x2F; 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Object is being created
Length of line : 6
Object is being deleted
&#96;&#96;&#96;  

### 拷贝构造函数

#### 介绍

拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象。

- 复制对象把它作为参数传递给函数。

- 复制对象，并从函数返回这个对象。

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：

&#96;&#96;&#96;c++
classname (const classname &amp;obj) &#123;
   &#x2F;&#x2F; 构造函数的主体
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
class CExample
&#123;
private:
    int a;
public:
    &#x2F;&#x2F;构造函数
    CExample(int b)
    &#123;
        a&#x3D;b;
        printf(&quot;constructor is called\n&quot;);
    &#125;
    &#x2F;&#x2F;拷贝构造函数
    CExample(const CExample &amp; c)
    &#123;
        a&#x3D;c.a;
        printf(&quot;copy constructor is called\n&quot;);
    &#125;
    &#x2F;&#x2F;析构函数
    ~CExample()
    &#123;
        cout&lt;&lt;&quot;destructor is called\n&quot;;
    &#125;
    void Show()
    &#123;
        cout&lt;&lt;a&lt;&lt;endl;
    &#125;
&#125;;
int main()
&#123;
    CExample A(100);
    CExample B&#x3D;A;
    B.Show(); 
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="深拷贝和浅拷贝的区别"><a href="#深拷贝和浅拷贝的区别" class="headerlink" title="深拷贝和浅拷贝的区别"></a>深拷贝和浅拷贝的区别</h4><ul>
<li><p>浅拷贝：将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用</p>
</li>
<li><p>深拷贝：创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”</p>
</li>
</ul>
<h5 id="为什么要使用深拷贝？"><a href="#为什么要使用深拷贝？" class="headerlink" title="为什么要使用深拷贝？"></a>为什么要使用深拷贝？</h5><p>我们希望在改变新的数组（对象）的时候，不改变原数组（对象）</p>
<h5 id="怎么检验深拷贝成功"><a href="#怎么检验深拷贝成功" class="headerlink" title="怎么检验深拷贝成功"></a>怎么检验深拷贝成功</h5><p>改变任意一个新对象数组中的属性元素，都不改变原对象&#x2F;数组</p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Base&#123;
public:
    Base(): m_a(0), m_b(0)&#123; &#125;
    Base(int a, int b): m_a(a), m_b(b)&#123; &#125;
private:
    int m_a;
    int m_b;
&#125;;
int main()&#123;
    int a &#x3D; 10;
    int b &#x3D; a;  &#x2F;&#x2F;拷贝
    Base obj1(10, 20);
    Base obj2 &#x3D; obj1;  &#x2F;&#x2F;拷贝
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是浅拷贝。<br><br></p>
<p>对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;cstring&gt;
using namespace std;
&#x2F;&#x2F;变长数组类
class Array&#123;
public:
    Array(int len);
    Array(const Array &amp;arr);  &#x2F;&#x2F;拷贝构造函数
    ~Array();
public:
    int operator[](int i) const &#123; return m_p[i]; &#125;  &#x2F;&#x2F;获取元素（读取）
    int &amp;operator[](int i)&#123; return m_p[i]; &#125;  &#x2F;&#x2F;获取元素（写入）
    int length() const &#123; return m_len; &#125;
private:
    int m_len;
    int *m_p;
&#125;;
Array::Array(int len): m_len(len)&#123;
    m_p &#x3D; (int*)calloc( len, sizeof(int) );
&#125;
Array::Array(const Array &amp;arr)&#123;  &#x2F;&#x2F;拷贝构造函数
    this-&gt;m_len &#x3D; arr.m_len;
    this-&gt;m_p &#x3D; (int*)calloc( this-&gt;m_len, sizeof(int) );
    memcpy( this-&gt;m_p, arr.m_p, m_len * sizeof(int) );
&#125;
Array::~Array()&#123; free(m_p); &#125;
&#x2F;&#x2F;打印数组元素
void printArray(const Array &amp;arr)&#123;
    int len &#x3D; arr.length();
    for(int i&#x3D;0; i&lt;len; i++)&#123;
        if(i &#x3D;&#x3D; len-1)&#123;
            cout&lt;&lt;arr[i]&lt;&lt;endl;
        &#125;else&#123;
            cout&lt;&lt;arr[i]&lt;&lt;&quot;, &quot;;
        &#125;
    &#125;
&#125;
int main()&#123;
    Array arr1(10);
    for(int i&#x3D;0; i&lt;10; i++)&#123;
        arr1[i] &#x3D; i;
    &#125;
    Array arr2 &#x3D; arr1;
    arr2[5] &#x3D; 100;
    arr2[3] &#x3D; 29;
   
    printArray(arr1);
    printArray(arr2);
   
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2 的数据，就没有影响 arr1。<br><br></p>
<p>这种将对象所持有的其它资源一并拷贝的行为叫做深拷贝，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，请看下面的例子：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;ctime&gt;
#include &lt;unistd.h&gt;
using namespace std;
class Base&#123;
public:
    Base(int a &#x3D; 0, int b &#x3D; 0);
    Base(const Base &amp;obj);  &#x2F;&#x2F;拷贝构造函数
public:
    int getCount() const &#123; return m_count; &#125;
    time_t getTime() const &#123; return m_time; &#125;
private:
    int m_a;
    int m_b;
    time_t m_time;  &#x2F;&#x2F;对象创建时间
    static int m_count;  &#x2F;&#x2F;创建过的对象的数目
&#125;;
int Base::m_count &#x3D; 0;
Base::Base(int a, int b): m_a(a), m_b(b)&#123;
    m_count++;
    m_time &#x3D; time((time_t*)NULL);
&#125;
Base::Base(const Base &amp;obj)&#123;  &#x2F;&#x2F;拷贝构造函数
    this-&gt;m_a &#x3D; obj.m_a;
    this-&gt;m_b &#x3D; obj.m_b;
    this-&gt;m_count++;
    this-&gt;m_time &#x3D; time((time_t*)NULL);
&#125;
int main()&#123;
    Base obj1(10, 20);
    cout&lt;&lt;&quot;obj1: count &#x3D; &quot;&lt;&lt;obj1.getCount()&lt;&lt;&quot;, time &#x3D; &quot;&lt;&lt;obj1.getTime()&lt;&lt;endl;
   
    sleep(3);
   
    Base obj2 &#x3D; obj1;
    cout&lt;&lt;&quot;obj2: count &#x3D; &quot;&lt;&lt;obj2.getCount()&lt;&lt;&quot;, time &#x3D; &quot;&lt;&lt;obj2.getTime()&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="析构函数-1"><a href="#析构函数-1" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。</li>
<li>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。</li>
</ul>
<p>下面的实例有助于更好地理解析构函数的概念</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">include &lt;iostream&gt;
 
using namespace std;
 
class Line
&#123;
   public:
      void setLength( double len );
      double getLength( void );
      Line();   &#x2F;&#x2F; 这是构造函数声明
      ~Line();  &#x2F;&#x2F; 这是析构函数声明
 
   private:
      double length;
&#125;;
 
&#x2F;&#x2F; 成员函数定义，包括构造函数
Line::Line(void)
&#123;
    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;
&#125;
Line::~Line(void)
&#123;
    cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;
&#125;
 
void Line::setLength( double len )
&#123;
    length &#x3D; len;
&#125;
 
double Line::getLength( void )
&#123;
    return length;
&#125;
&#x2F;&#x2F; 程序的主函数
int main( )
&#123;
   Line line;
 
   &#x2F;&#x2F; 设置长度
   line.setLength(6.0); 
   cout &lt;&lt; &quot;Length of line : &quot; &lt;&lt; line.getLength() &lt;&lt;endl;
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果：</p>
<pre><code>Object is being created
Length of line : 6
Object is being deleted
</code></pre>
<h3 id="为什么需要构造函数-1"><a href="#为什么需要构造函数-1" class="headerlink" title="为什么需要构造函数"></a>为什么需要构造函数</h3><ul>
<li>设置构造函数的初衷，很多程序错误，是对象(变量)未能初始化引起的，故设置一个构造函数，自动调用它来进行初始化，以避免这类错误</li>
<li>初始化成员变量，分配内存空间。</li>
<li>一般情况下（指类成员没有指针的情况）自定义类有没有构造函数影响不大。（但使用时要注意，因为默认构造函数下，成员是不被初始化的。）但如果有指针，而你又没有定义构造函数，那问题就大了。（使用没有初始化的指针会有什么问题？是不可预想的。）  <h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4></li>
<li>让类进行自动初始化，为指针分配空间  </li>
<li>用于在创建不同对象时用不同的值初始化不同对象的各种数据元素</li>
</ul>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/HexoBlog/2022/04/01/test/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">test</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">lj</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.</span> <span class="nav-text">默认构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">为什么需要构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">1.1.3.</span> <span class="nav-text">析构函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">深拷贝和浅拷贝的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">为什么要使用深拷贝？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E6%A3%80%E9%AA%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%88%90%E5%8A%9F"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">怎么检验深拷贝成功</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">浅拷贝</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.1.4.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">1.1.5.</span> <span class="nav-text">为什么需要构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">优点</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/HexoBlog/js/utils.js"></script>

<script src="/HexoBlog/js/main.js"></script>

<script src="/HexoBlog/js/header-shrink.js"></script>

<script src="/HexoBlog/js/back2top.js"></script>

<script src="/HexoBlog/js/dark-light-toggle.js"></script>





    
<script src="/HexoBlog/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/HexoBlog/js/left-side-toggle.js"></script>

<script src="/HexoBlog/js/libs/anime.min.js"></script>

<script src="/HexoBlog/js/toc.js"></script>

    
</div>



</body>
</html>

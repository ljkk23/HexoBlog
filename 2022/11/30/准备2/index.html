<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="lj">
    
    <title>
        
            准备2 |
        
        LjBlog
    </title>
    
<link rel="stylesheet" href="/HexoBlog/css/style.css">

    <link rel="shortcut icon" href="/HexoBlog/images/logo.svg">
    
<link rel="stylesheet" href="/HexoBlog/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"ljkk23.github.io","root":"/HexoBlog/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/HexoBlog/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                LjBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">准备2</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/HexoBlog/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">lj</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-11-30 17:06:49</span>
        <span class="mobile">2022-11-30 17:06</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/categories/%E5%87%86%E5%A4%87/">准备</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/tags/%E5%87%86%E5%A4%87/">准备</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><h5 id="1-存储引擎是什么，"><a href="#1-存储引擎是什么，" class="headerlink" title="1.存储引擎是什么，"></a>1.存储引擎是什么，</h5><p>​    在百度百科上是这样说的：</p>
<pre class="line-numbers language-none"><code class="language-none"> MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。

 例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持[事务处理]的数据库(以确保事务处理不成功时数据的回退能力)。

这些不同的技术以及配套的相关功能在MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>总结：</p>
<p>​    1.mysql根据不同的使用者的不同需求，在存储机制、索引技巧以及锁等方面有不同的实现，这些不同的技术配套组合起来就称为存储引擎。</p>
<p>​    2.存储引擎是基于插件式架构，支持多重存储引擎，因为存储引擎是基于表的，所以我们甚至可以为不同的数据库设置不同的存储引擎，自己也可以根据mysql的标准存储引擎实现接口编写一个自己的存储引擎</p>
<h5 id="2-mysql中常见的存储引擎"><a href="#2-mysql中常见的存储引擎" class="headerlink" title="2.mysql中常见的存储引擎"></a>2.mysql中常见的存储引擎</h5><p>​     mysql 5.5之前的默认存储引擎是 MyISAM,MyISAM的性能也不错，在全文索引、压缩、空间函数等都体现不错，但是因为不支持事务和行级锁，而且崩溃后无法安全恢复数据，所以就在mysql5.5之后，取而代之的是InnoDB，对比一下两个常见的存储引擎：</p>
<p>1.是否支持行级锁：</p>
<p>  MyISAM只支持表级锁，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。所以在并发的时候就知道InnoDB的优势了</p>
<p>2.是否支持事务</p>
<p>MyISAM不提供支持事务</p>
<p>​    innoDB支持事务，实现了sql标准的四个隔离级别，默认使用的是可重复读，可以解决幻读。具体事务级别看后面</p>
<p>3.是否支持外键</p>
<p>​    myISAM不支持外键，innoDB支持外键。</p>
<p>​    外键的好处能对数据库的维护数据一致性有很好的帮助，但是在阿里的开发手册中明确提出禁止用外键，所以我们通常在开发项目的时候不再数据库层面使用外键，而将其在应用层实现，不过，到底用不用还是得看实际的项目</p>
<p>4.是否支持数据库崩溃之后数据的安全恢复</p>
<p>​    myISAM不支持。而mysql支持，mysql这个恢复i的过程基于redo log</p>
<p>5.索引的实现不一样</p>
<p>​    虽然都是用的B+树作索引，myISAM是索引文件而数据文件分离，innoDB数据文件就是索引文件，具体看后面</p>
<h5 id="数据库的事务隔离级别"><a href="#数据库的事务隔离级别" class="headerlink" title="数据库的事务隔离级别"></a>数据库的事务隔离级别</h5><p>（1）读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>问题：</p>
<p>​    在一个事务a开启之后数据为2，如果另一个事务b修改了这数据3，a再读取这数据就为3，但是b事务回滚了，数据又变成了2,这里就出现了脏读</p>
<p>（2）读已提交：可以解决脏读，在一个事务开启时，另一个事务修改的数据必须提交之后才能被其他事务读到</p>
<p>（3）可重复读：： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
<p>解决不可重复读：</p>
<p>​        当b事务提交之后，a再次读这个数据就为3了，但是之前b事务还没有提交的时候，a就读取了这个数据为2,这样就造成了前后读的数据不一致，这就是不可重复读，所以如果是这个级别，之后再读取这个数据就还会是2。</p>
<p>问题：</p>
<p>​    但是会出现幻读，和可重复读差不多，只不过这次b事务不是去修改a读过的数据，而是增加或修改了其他数据，导致a事务再次去读的时候，就出现了两条数据（如果之前是一条数据），</p>
<p>解决幻读：</p>
<ol>
<li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li>
</ol>
<p>（4）可串行化：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<p>总结：</p>
<p>1.因为隔离级别越低，事务请求的锁越少，所以可串行化对并发量不太友好，所以mysql中innoDB默认隔离级别是不可重复读且解决了幻读的问题，虽然一般的数据库是读已提交，但是innoDB的可重复读不会有任何性能损失。</p>
<p>2.innoDB解决幻读：通过MVCC机制快照读、使用Next-key Lock（Record Lock+Gap Lock）实现当前读</p>
<h5 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql 索引"></a>mysql 索引</h5><p>1.索引是什么：</p>
<p>索引是一种快速查找数据和检索数据的数据结构</p>
<p>2.索引的优缺点：</p>
<p>优点：</p>
<ul>
<li>大大加快了检索数据的速度</li>
<li>如果建立唯一性索引，还可以保证数据的唯一性</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引需要空间，耗费空间</li>
<li>创建和维护索引也需要一定的耗费时间，在对表进行增删查改的时候，有索引就需要维护索引，降低sql的执行效率</li>
</ul>
<p>3.索引底层数据结构</p>
<p>（1）hash表，虽然hash表查询速度很快，但是因为hash不支持顺序和范围查询，而且每次IO只能取一个数据</p>
<p>（2）b树和B+树：</p>
<p>​    b树的所有节点都存放数据和key,这就导致了枝干节点的能够存放key的存储空间就比完全存放key的存储空间小，所以就导致整个树存储的数据比B+树少。</p>
<p>​    b+树叶子节点有一条链表，在范围查询的时候比b树少一次IO</p>
<p>​    B+树检索效率稳定，因为数据都在叶子节点</p>
<p>4.myISAM和innoDB都是用的B+树</p>
<p>但是不同点：</p>
<p>​    myISAM用的是非聚簇索引，即叶子节点存放的是data的指针，找到叶子节点之后，需要多一次IO去读取真正的数据</p>
<pre><code> innoDb用的是聚簇索引，叶子节点直接存放的是data。
</code></pre>
<p>5.索引的类型</p>
<p>主键索引：拿主键作为索引，通过主键索引找到叶子节点存放的就是data</p>
<p>二级索引：通过二级索引找到叶子节点，存放的就是主键的信息，然后再通过主键去找到data</p>
<p>聚簇索引优缺点：</p>
<p>优点：</p>
<p>​    （1）查询data时速度更快，比较与非聚簇少一个IO操作</p>
<p>​    （2）<strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</p>
<p>缺点：</p>
<p>​    数据更改，索引就要更改，代价较大，非聚簇索引的数据改时，索引不用改，</p>
<p>非聚簇：</p>
<p>优点：</p>
<p>​    数据更改，索引的树不用更改</p>
<p>缺点：</p>
<p>​     可能会二次查询。</p>
<p>演示innoDB聚簇索引的主键索引和二级索引，和myIsam的非聚簇索引的主键索引和二级索引</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/suoying.png"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用”where id &#x3D; 14”这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</li>
<li>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</li>
</ol>
<p>MyISM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
<p><strong>选择合适的字段创建索引</strong></p>
<ul>
<li>经常查询的字段</li>
<li>不为空对象的字段</li>
<li>作为条件的字段</li>
<li>频繁作为连接的字段</li>
<li>频繁更新的不适合作为索引</li>
</ul>
<p>​    innoDB选择默认是主键作为索引，如果没有主键就找一个唯一且不为null的字段，如果都没有，就自己生成一个6字节的索引，所以主键一般不为uuid或字符串这种难排序的，最好是自增的，因为这样方便插入和排序。</p>
<h5 id="为什么主键通常建议使用自增id"><a href="#为什么主键通常建议使用自增id" class="headerlink" title="为什么主键通常建议使用自增id"></a><strong>为什么主键通常建议使用自增id</strong></h5><p>​    因为使用自增 id 可以避免页分裂，因为聚簇索引的物理存放顺序和索引顺序是一致的，只要索引相邻，对应的数据也相邻，如果主键不是自增id,那么就会不断的调整数据的物理分页。为什么呢？一下是解释</p>
<p>​    mysql 在底层又是以数据页为单位来存储数据的，一个数据页大小默认为 16k，当然你也可以自定义大小，也就是说如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。</p>
<p>​    如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。</p>
<p>​    如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。</p>
<p>​    当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上。</p>
<p>对主键 id 还有一个小小的要求，在满足业务需求的情况下，尽量使用占空间更小的主键 id，因为普通索引的叶子节点上保存的是主键 id 的值，如果主键 id 占空间较大的话，那将会成倍增加 mysql 空间占用大小</p>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h5 id="MyISAM-和-InnoDB-如何选择？"><a href="#MyISAM-和-InnoDB-如何选择？" class="headerlink" title="MyISAM 和 InnoDB 如何选择？"></a>MyISAM 和 InnoDB 如何选择？</h5><p>​    一般来说我们都选择innoDB,因为innoDB支持事务、行锁、崩溃后数据能够安全恢复，这几个myISAM都不能做到，但是这几个又是我们日常业务的必须，其实innoDB的速度并不一定比myISAM慢，比如聚簇索引就比非聚簇索引少一层IO操作</p>
<h5 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="MySQL 查询缓存"></a>MySQL 查询缓存</h5><p>​    在mysql8之前有，查询数据之前，会先查询缓存，但是在mysql8之后就移除了这个功能，原因是虽然缓存能够提高查询速度，但是维护和更新缓存无疑会增加带来额外开销，每一次操作之后都会做一次缓存操作，而且更新缓存和缓存不击中的情况比较多：（1）查询条件不同（2）缓存的数据的所在表更改（3）查询条件中函数以及临时表都不会缓存。</p>
<h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h5><p>参考：<a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html#%E4%BB%80%E4%B9%88%E6%98%AFmvcc" >https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html#%E4%BB%80%E4%B9%88%E6%98%AFmvcc<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="MVCC-是什么"><a href="#MVCC-是什么" class="headerlink" title="MVCC 是什么"></a>MVCC 是什么</h6><p>​    MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。是一种控制并发的方法，是一种理念，在数据库管理系统中，实现对数据库的并发，在编程语言中实现事务。</p>
<h6 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h6><p>​    在了解MVCC之前，先知道什么是当前读和快照读</p>
<p>​    当前读：读取的是数据的最新版本，读取时会对数据进行加锁，例如：像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读</p>
<p>​    快照读：不加锁的读就是快照读，之所以会出现快照读，是因为提高并发，所以快照读基于多版本并发，他避免了加锁，因为是多版本，所以难免会读到数据的旧版本。</p>
<p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<h6 id="MVCC-解决的问题以及好处"><a href="#MVCC-解决的问题以及好处" class="headerlink" title="MVCC 解决的问题以及好处"></a>MVCC 解决的问题以及好处</h6><p>数据库并发场景?</p>
<p>有三种, 分别为：</p>
<ul>
<li><strong>读-读</strong>：不存在任何问题，也不需要并发控制</li>
<li><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><strong>写-写</strong>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p>MVCC带来的好处是？</p>
<p>MVCC多版本并发控制是一种解决读写冲突的无锁非阻塞，他为每一个事务分配一个单向增长的时间戳，版本与该时间戳关联，读操作（快照读）只读取该事务开始的版本</p>
<p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p>
<h6 id="MVCC和当前读、快照读的关系"><a href="#MVCC和当前读、快照读的关系" class="headerlink" title="MVCC和当前读、快照读的关系"></a>MVCC和当前读、快照读的关系</h6><p>​    准确的说，MVCC只是一个理念，所以我们需要在数据库中实现，为了在数据库中实现这么一个理念，快照读就出来了，他解决了在读写问题中的阻塞问题。但其实MVCC整套理念的实现不仅只有一个快照读，MVCC模型的实现是靠4个隐式字段和undo log和readView实现的。</p>
<h6 id="4个隐式字段"><a href="#4个隐式字段" class="headerlink" title="4个隐式字段"></a>4个隐式字段</h6><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<ul>
<li><strong>DB_ROW_ID</strong> 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li><strong>DB_TRX_ID</strong> 6byte, 最近修改(修改&#x2F;插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong> 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
<li><strong>DELETED_BIT</strong> 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p>这里注意最后一个字段，</p>
<h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><p>不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p>
<h6 id="read-view（读视图）"><a href="#read-view（读视图）" class="headerlink" title="read view（读视图）"></a>read view（读视图）</h6><p>就是在事务快照读的时候，能够读到的数据是事务的哪些版本。</p>
<p>read view 有三个全局属性，这三个属性都是全局的</p>
<p><strong>trx_list</strong> 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID</p>
<p><strong>up_limit_id</strong> 记录trx_list列表中事务ID最小的ID</p>
<p><strong>low_limit_id</strong> ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</p>
<p>生成read view流程：</p>
<ul>
<li>1.在某一个事务中快照读取某个数据时，首先看该数据的事务的隐式字段事务id是否小于<strong>up_limit_id</strong> （记录trx_list列表中事务ID最小的ID），如果是，就说明这个是已经提交的数据，可以读</li>
<li>如果不小于当前活跃事务的最小id,就判断是否大于<strong>low_limit_id</strong>，如果是，说明该事务不符合可见性</li>
<li>如果不大于low_limit_id，说明该事务处于活跃中，则去该事务的undo log中找事务id,再次通过流程判断，直到符合可见性</li>
</ul>
<h6 id="MVCC相关问题：RR和RC级别下的read-view"><a href="#MVCC相关问题：RR和RC级别下的read-view" class="headerlink" title="MVCC相关问题：RR和RC级别下的read view"></a>MVCC相关问题：RR和RC级别下的read view</h6><p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View</strong>。</p>
<p>所以RC会出现不可重复读，RR会解决这个问题</p>
<h2 id="day-3-12-5"><a href="#day-3-12-5" class="headerlink" title="day 3 12.5"></a>day 3 12.5</h2><h5 id="mysql-锁"><a href="#mysql-锁" class="headerlink" title="mysql 锁"></a>mysql 锁</h5><h6 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h6><p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h6 id="行锁的使用的注意事项"><a href="#行锁的使用的注意事项" class="headerlink" title="行锁的使用的注意事项"></a>行锁的使用的注意事项</h6><p>​    innoDB的行锁的是针对索引字段，表极锁是针对非索引字段，所以当我们执行update delete语句时，如果where未命中索引或者索引失效的话，就会全表的所有行记录进行加锁，所以这里要注意。</p>
<p>​    这里需要注意的是，虽然我们用了索引，但是有些时候还会走全局扫描，所以这就是后面mysql优化器</p>
<h6 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h6><p>​    不论是表锁还是行锁，都有共享锁和排他锁，由于MVCC的存在，所以一般的select语句是不会加任何锁的，可以显式的加锁查询</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//共享锁</span>
select <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lock in share mode
 <span class="token comment">//排他锁</span>
    select <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> update   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>意向锁就是，在加表锁的时候，肯定需要去判断该表是否加了行锁，那怎么判断呢，如果一行一行的去遍历，性能太差，优秀的程序员怎么能容忍这种事情发生呢，所以就有了一个意向锁，在加共享锁或者排他锁之前，需要首先获得意向锁，比如加共享锁时，需要首先获得该记录的意向共享锁</p>
<h6 id="innoDb-有哪些行锁"><a href="#innoDb-有哪些行锁" class="headerlink" title="innoDb 有哪些行锁"></a>innoDb 有哪些行锁</h6><p>mysql 支持三种行锁</p>
<ul>
<li>记录锁（record lock），属于单个行的锁</li>
<li>间隙锁（Gap lock）：锁定一个范围，不包括记录本身</li>
<li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>mysql innoDB的RR是可以解决幻读的，本来一般的事务隔离级别为RR都不会解决幻读的，mysql innodb能解决是以下两种情况：</p>
<ul>
<li>快照读：通过mvcc机制保证不出现幻读，核心就是生成read view</li>
<li>当前读：使用next-key lock 来加锁解决幻读</li>
</ul>
<h5 id="mysql-三大日志"><a href="#mysql-三大日志" class="headerlink" title="mysql 三大日志"></a>mysql 三大日志</h5><h6 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h6><p>​    redo log （重做日志）是innodb独有的，这也是前面说过的innoDB相比于myISAM的优势：能够在宕机后安全的恢复数据，就是基于这个实现的</p>
<p>​    因为mysql 中的数据是以页为单位的，所以当你查询一条记录的时候，会把记所在的一页数据都加载到出来，放入到    BUffer pool，然后后续查找先去Buffer pool 中查找，包括更新数据也是先更新Buffer pool中的数据，然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/03.png"></p>
<p><strong>redo log的刷盘时机</strong></p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略</p>
<p><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</p>
<p><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</p>
<p><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p>redo log 是由一组日志文件组</p>
<h6 id="redo-log小结"><a href="#redo-log小结" class="headerlink" title="redo log小结"></a>redo log小结</h6><p>​    上面讲了redo log 的作用机制、刷盘时机以及存储形式。现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p> 这里就有几个不同：</p>
<ul>
<li>一是：每次修改数据页可能就修改了几byte，这样就刷盘的话，会浪费资源</li>
<li>二是：而且数据页的刷盘是随机读写，因为如果主键索没有用自增id,就有可能就造成数据页的刷盘的随机读写，性能很低，而日志文件都是一行记录占用byte少，而且日志文件是顺序读写，大大增强了性能，</li>
</ul>
<h6 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h6><p>​    redo log 是属于物理日志，记录的是在“某个数据页上做了什么修改”，属于innoDB存储引擎的;</p>
<p>​    而bin log 属于归档日志，记录的是sql语句或者说记录的是sql语句的逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于mysql server层的，不管用什么存储引擎，只要表数更改了，就会产生bin log</p>
<p>​    bin log 到底是干嘛的，有什么作用： binlog 主要用与数据库的备份、主从复制等，依靠bin log 来同步数据库，保持数据一致性。</p>
<p><strong>记录格式</strong></p>
<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><p><strong>statement</strong>：记录的是sql的原语句：</p>
</li>
<li><p><strong>row</strong>：记录的增强版的sql,来保持数据一致性，比如要主从之间复制当地时间，所以就需要在主机时，就将sql中的值修改为主机的获取当地时间。</p>
</li>
<li><p><strong>mixed</strong>：row这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>​    <code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p>​        <code>    binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>​    虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>​    首先我们先整体知道一下执行语句更新的时候，整体流程：在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/01-20220305234816065.png"></p>
<p> 所以想象这样一个场景，当redo log 写完之后，当写入bin log 时，数据库宕机了，这样就会导致bin log 并没有成功写完，所以就导致了从机通过bin log 同步数据的时候，和主机数据不一致（因为主机通过redo log 已经更改了数据）。</p>
<p>​    所以怎么解决这样一个问题呢，这明显是一个事务问题，所以我们这里就用了两阶段提交的方法，在更新数据之后，先将写redo log事务标记为prepare阶段，然后在写入bin log 之后，将redo log 事务标记为commit,然后就更新主机数据。这里就保证了数据的一致性。</p>
<p>那么对于这个流程，通过以下问题进一步深刻了解：</p>
<p>（1）有了bin log 为什么还需要redo log</p>
<ul>
<li>bin log 不知道数据库从哪一时刻丢了数据，所以只能从备份点开始对bin log 记录恢复数据，比较耗时，而redo log有一个check point</li>
<li>bin log 需要手动恢复数据，redo log是自动恢复</li>
<li>redo log 的wal+写缓存+异步刷盘提高IO利用</li>
</ul>
<p>（2）有了redo log 为什么还需要bin log</p>
<ul>
<li>bin log 是server 层的，redo log 是存储引擎innoDB的，其他存储引擎无法通过redo log 恢复</li>
<li>主从机之间是通过bin log复制。</li>
</ul>
<p>（3）保证数据一致性的流程</p>
<ul>
<li>如果在prepare阶段写完之后，在写bin log时宕机从机不会更改，此时重启mysql,通过redo log 恢复数据，看到redo log 事务的处于prepare阶段然后去判断bin log 是否有对应记录，因为还没有写完整，所以不会更改该redo log,这样主从就一致</li>
<li>如果在写bin log 之后，在提交的之前宕机，此时重启mysql,如果redo log是prepare,去判断bin log ，发现是完整的，然后就会更改主库</li>
<li>至于有了第二种情况，为什么还需要有commit,这是为了性能，因为每次都去判断bin log 难免效率太低下，所以一旦是commit,就直接提交</li>
</ul>
<h5 id="sql语句执行流程"><a href="#sql语句执行流程" class="headerlink" title="sql语句执行流程"></a>sql语句执行流程</h5><p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/13526879-3037b144ed09eb88.png"></p>
<p>以下面这条简单的 SQL 语句为例，我们来解释下执行器和 InnoDB 存储引擎在更新时做了哪些事情：</p>
<pre class="line-numbers language-none"><code class="language-none">updatetablesetage&#x3D;age+1whereid&#x3D;1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol>
<li>执行器：找<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D" >存储引擎<i class="fas fa-external-link-alt"></i></a>取到 id &#x3D; 1 这一行记录</li>
<li>存储引擎：根据主键索引树找到这一行，如果 id &#x3D; 1 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%B1%A0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D" >内存池<i class="fas fa-external-link-alt"></i></a>，然后再返回</li>
<li>执行器：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</li>
<li>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务<br>注意不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，[commit 命令](<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=commit" >https://www.zhihu.com/search?q=commit<i class="fas fa-external-link-alt"></i></a> 命令&amp;search_source&#x3D;Entity&amp;hybrid_search_source&#x3D;Entity&amp;hybrid_search_extra&#x3D;{“sourceType”%3A”answer”%2C”sourceId”%3A2280710259})就执行成功了。</li>
<li>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</li>
<li>执行器：调用存储引擎的提交事务接口</li>
<li>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</li>
</ol>
<h2 id="day4-12-12"><a href="#day4-12-12" class="headerlink" title="day4 12.12"></a>day4 12.12</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>​    确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<p>​    有六种实现方式：饿汉式、枚举式、懒汉式、同步锁、双重校验锁、静态内部类</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/2_singleton_1.png"></p>
<p>​    前面两种是初始化就加载对象，这种就需要满足初始化速度快而且占用内存小，不然会造成应用启动太慢。所以如果初始化速度慢或者占用内存大，就需要延迟加载，在初始化的时候不加载，而是使用的时候再加载，这样就节约了资源。</p>
<p>​    哪些时候需要初始化就加载，比如电商中的一些热点数据访问较多的，所以就可以提前加载，免得第一次访问还要去加载，而当有些数据可能很久都不会用到，这些就可以用到的时候再加载，避免了没用到时的资源浪费</p>
<p>（1）饿汉式：因为有new，所以就会直接加载类，后面会有类加载的时机，因为在初始化时就加载，所以不会存在线程安全问题。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（2）枚举：枚举的静态代码块本身就根据jvm的类加载机制加载，所以只有一次加载，因为是静态变量，所以存在于类中，不会因对象而改变，所以这里也是线程安全的</p>
<p>（3）懒汉式（线程不安全的版本）：因为多线程，所以if (uniqueInstance &#x3D;&#x3D; null) {这一段代码会有很多个线程进入，就造成了线程不安全</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（4）懒汉式同步锁：因为加了synchronized,所以性能消耗大</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（5）双重校验锁（DCL）：</p>
<p>这是在懒汉式同步锁上因为加了synchronized关键字导致性能下降的优化，加锁操作只需要对实例化那部分的代码进行，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：（1）这里为什么要双重校验的，因为是多线程，所以进入第一个if的有很多线程，如果不要synchronized里面的if判断，那么线程都会最终执行uniqueInstance &#x3D; new Singleton();只是拿到锁的先执行，后来的就后执行，所以这里就不是单例模式了。</p>
<p>​            （2）这里的实例必须用volatile修饰，因为uniqueInstance &#x3D; new Singleton();这一句是分为三个步骤执行的</p>
<ul>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向分配的内存空间</li>
</ul>
<p>但是在jvm的优化下，有可能会产生指令重排，就会出现1-》3-》2的顺序，所以这时如果在执行了3还未执行2的时候，来了新的线程判断对象不为空，就会直接返回给调用方，但是因为此时还未执行2初始化对象，所以这个时候返回给调用方的对象是不正确的，就会导致出错，所以这里必须使用volatile来禁止指令重排</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/20200425180018774.png"></p>
<p>（6）静态内部类：因为初始化在加载外部类的时候，是不会加载内部类的（静态内部类就属于被动引用的行列），所以就实现了延迟加载，又因为这里getInstantce时并没有去new,而是去获得内部的变量，这时就加载该内部类，有因为是静态内部类，所以在jvm加载时自动就保证了线程安全。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>使用单例模式的好处</strong> :</p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>​    工厂模式分为三种：简单工厂、工厂方法、抽象工厂。</p>
<p>（1）简单工厂：就是将实例化的操作放在一个类来实现，调用方不用在意实例化的类的内部具体实现，只需要按照规则使用new对象即可。</p>
<p>工厂类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>dev<span class="token operator">-</span>spec<span class="token operator">/</span>pattern<span class="token operator">/</span><span class="token number">3_</span>simple_factory<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用方：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">SimpleFactory</span> simpleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Product</span> product <span class="token operator">=</span> simpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// do something with the product</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>dev<span class="token operator">-</span>spec<span class="token operator">/</span>pattern<span class="token operator">/</span><span class="token number">3_</span>simple_factory<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（2）工厂方法：生成一个接口，由子类去选择实例化哪个对象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 定义一个抽象的咖啡工厂
 * @author Lsj
 */</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>
    
    <span class="token comment">/**
     * 生产可制造的咖啡
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 中国咖啡工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChinaCoffeeFactory</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Cappuccino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 美国咖啡工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericaCoffeeFactory</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Americano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 工厂方法测试
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryMethodTest</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Coffee</span> coffee <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coffee<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">CoffeeFactory</span> chinaCoffeeFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChinaCoffeeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chinaCoffees <span class="token operator">=</span> chinaCoffeeFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中国咖啡工厂可以生产的咖啡有："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>chinaCoffees<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CoffeeFactory</span> americaCoffeeFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericaCoffeeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> americaCoffees <span class="token operator">=</span> americaCoffeeFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"美国咖啡工厂可以生产的咖啡有："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>americaCoffees<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（3）抽象工厂：定义一系列有关的接口：也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 抽象的饮料产品家族制造工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">/**
     * 制造咖啡
     * @return
     */</span>
    <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * 制造茶
     * @return
     */</span>
    <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * 制造碳酸饮料
     * @return
     */</span>
    <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 中国饮品工厂
 * 制造咖啡与茶
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChinaDrinksFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MilkTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 美国饮品制造工厂
 * 制造咖啡和碳酸饮料
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericaDrinksFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CocaCola</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 抽象工厂测试类
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactoryTest</span> <span class="token punctuation">&#123;</span>
    
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Drink</span> drink<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>drink <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品：--"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品："</span> <span class="token operator">+</span> drink<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">AbstractDrinksFactory</span> chinaDrinksFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChinaDrinksFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span> coffee <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Tea</span> tea <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Sodas</span> sodas <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中国饮品工厂有如下产品："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>tea<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>sodas<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">AbstractDrinksFactory</span> americaDrinksFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericaDrinksFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        coffee <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tea <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sodas <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"美国饮品工厂有如下产品："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>tea<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>sodas<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="建造器模式"><a href="#建造器模式" class="headerlink" title="建造器模式"></a>建造器模式</h5><p>​    当我们需要实例化一个比较复杂类，而且还要根据要求实例化不同结构和不同内部状态的对象时，我们可以用类将其不同的实例化逻辑封装，这些类就叫建造者。</p>
<p>建造者分为四种角色：</p>
<ul>
<li>Product(产品类) :我们具体需要生成的类对象</li>
<li>Builder(抽象建造者类)：为我们需要生成的类对象，构建不同的模块属性，即：公开构建产品类的属性，隐藏产品类的其他功能</li>
<li>ConcreteBuilder(具体建造者类)：实现我们要生成的类对象</li>
<li>Director(导演类)：确定构建我们的类对象具体有哪些模块属性，在实际应用中可以不需要这个角色，直接通过client处理</li>
</ul>
<p>在电商中有多种不同类型的商品 <strong>普通实物商品</strong>，<strong>电子卡券商品</strong>，<strong>虚拟视频学习商品</strong> 等多种不同的商品，他们都是商品但是他们的属性却不一样，电子卡券：独有券码，学习视频：独有视频链接等。</p>
<p>具体:<a class="link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h7iEyxgN34FPn191S8qUpA" >https://mp.weixin.qq.com/s/h7iEyxgN34FPn191S8qUpA<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>​    原型模式出现的原因：场景：当我们实例化对象时需要耗费很多资源以及硬件密集型操作而且已有实例对象与新对象的各方面结构或者状态一致的话，我们可以通过克隆来产生新对象。</p>
<p>​    假设现在我们有这么一种场景，公司搞一场活动有五万个商品参加此次活动，我们需要从后台能定时同步每个商品的销量，方便我们为后面的活动做商品分析，我们要怎么处理这个销量同步问题？</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/clone.png"></p>
<p>​    这里设计浅拷贝和深拷贝。其实在其他的地方我们可以用到原型模式，比如我们在发松活动的PUSH通知，针对平台百万、千万、甚至上亿的用户发送通知的时候通知的内容基本都是一样的只是推送用户不一样或者有些特别字段值的小改动，那我们这里就可以用原型模式来做，同时开启多线程来做push，需要注意的是这里的线程安全问题，所以在每个线程内部去做copy对象。在一般情况下是不建议用这种模式的除非创建的对象成本特别大，或者在一些特殊场景使用</p>
<h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><p>​    这个模式充分体现了设计原则中的最少知道原则，也就是说客户对象所需要交互的对象应当尽可能少。</p>
<p>​    外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。</p>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。</p>
<p>​    例如spring mvc中的DispatcherServlet根据请求信息调用handlermappering,然后由handlerAadpter对目标类适配，就解决了不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。</p>
<h2 id="day-5-12-13"><a href="#day-5-12-13" class="headerlink" title="day 5 12.13"></a>day 5 12.13</h2><h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>​    就是将抽象和实现分开，某些类型由于自身的逻辑，它具有两个或多个维度的变化，</p>
<ul>
<li>比如在电脑商城中有分类</li>
</ul>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/qiaojie.png"></p>
<p>我们用代码实现就需要台式电脑和笔记本继承电脑，然后华硕、小米继承台式以及继承笔记本，那这时增加了平板电脑（在电脑类型维度上变化），此时就需要增加华硕、小米继承平板电脑，这就导致了不是一个维度变化。还有这是增加了索尼品牌，也需要增加。所以我们这里如果根据桥接模式，就分为品牌和电脑类型，那么增加了电脑类型就只修改电脑类型，不会影响品牌。</p>
<ul>
<li>比如在driver驱动程序，有mysql的driver和OracleDriver，那么根据桥接模式实现，实现和抽象分开，driver和drivermanager分开，就能实现这种在driver和drivermanager维度变化互不影响</li>
</ul>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h5><p>​    什么时候需要用到组合模式，当你想要将对象组合成树形结构，使单个对象和组合对象具有一致性的时候，这个时候就需要用到组合模式。</p>
<p>​    组合模式有三个角色：</p>
<ul>
<li>一个是统一的对象声明接口：对象都需要实现该接口。</li>
<li>一个是定义有枝节点行为，用来存储子部件。</li>
<li>一个是叶子节点，就是没有子节点</li>
</ul>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><p>​    享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。比如我们的jdbc连接池，作为共享的对象，其中一个特点就是，该对象的某些属性值是相同的，那么就可以用享元模式，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><p>就是在装饰一个功能时，给被装饰者的功能加上对应的处理</p>
<h4 id="行为性设计模式"><a href="#行为性设计模式" class="headerlink" title="行为性设计模式"></a>行为性设计模式</h4><h5 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h5><p>将请求和接收方解耦，让多个接收对象都能够处理该请求，将这些对象串成一条链，并沿着该请求传递请求，直到链上某个对象处理该请求为止。</p>
<p>​    优点：</p>
<ul>
<li>增加新的请求处理类很方便。</li>
<li>降低耦合度。它将请求的发送者和接收者解耦。</li>
</ul>
<p>使用场景：SpringMVC中的 <strong>ServletFilter</strong>以及<strong>SpringInterceptor</strong>，</p>
<p>自己实现一个责任链设计模式来实现日志打印，不同的信息调用同一个接口，来实现日志打印的不同效果。</p>
<p>INFO打印在console,DEBUG打印在file中等等</p>
<p><a class="link"   target="_blank" rel="noopener" href="http://www.bjpowernode.com/shejimoshi/1599.html" >http://www.bjpowernode.com/shejimoshi/1599.html<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>​    当一个对象发现变化时，同时能够通知到与他相关的对象，当一个对象的状态发生改变时，已经登记的其他对象能够观察到这一改变从而作出自己相对应的改变。通过这种方式来达到减少依赖关系，解耦合的作用。</p>
<ul>
<li>Subject（主题）: 主要由类实现的可观察的接口，通知观察者使用attach方法，以及取消观察的detach方法。</li>
<li>ConcreteSubject（具体主题）: 是一个实现主题接口的类，处理观察者的变化</li>
<li>Observe（观察者）: 观察者是一个由对象水岸的接口，根据主题中的更改而进行更新。</li>
</ul>
<p>类似与消息队列的原理</p>
<p>​    熟悉JDK的人应该知道 在java.util 包下 除了常用的 集合 和map之外还有一个<strong>Observable</strong>类，他的实现方式其实就是观察者模式。里面也有<strong>添加、删除、通知</strong>等方法。</p>
<p>这里需要注意是的 他是用Vector 作为订阅关系的容器，同时在他的定义方法中都添加synchronized关键字修饰类，以达到线程安全的目的。</p>
<p>应用场景：当前现在有更加好的中间件<strong>MQ消息队列</strong>来处理这个业务问题，使得我们更加从容的面对这类场景问题，但是一些资源不足，不想引入新的系统。还是可以用这种方式来处理问题的。</p>
<h2 id="day-6-12-14"><a href="#day-6-12-14" class="headerlink" title="day 6 12.14"></a>day 6 12.14</h2><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>​    定义一系列算法，封装每个算法，不同的策略可以调用不同的算法。</p>
<p>​    用大白话来讲，就是调用方根据不同的参数传入进去之后，会根据这个参数有不同的算法逻辑处理。</p>
<ul>
<li>Strategy（抽象策略）：抽象策略类，并且定义策略执行入口</li>
<li>ConcreteStrategy（具体策略）：实现抽象策略，实现algorithm方法</li>
<li>Context（环境）：运行特定的策略类。</li>
</ul>
<p>一个抽象策略接口Strategy，然后各种具体的策略实现该接口ConcreteStrategy，然后实现context来运行策略接口方法，</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/celue.png"></p>
<p>context对象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">private</span> <span class="token class-name">Strategy</span> strategy<span class="token punctuation">;</span>
 
   <span class="token keyword">public</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token class-name">Strategy</span> strategy<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 
   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">doOperation</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyPatternDemo</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token class-name">Context</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 + 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationSubtract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 - 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationMultiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 * 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>框架的应用：</p>
<p><strong>ThreadPoolExecutor</strong>中的里面实现线程池的异常策略,传入什么参数，就是什么策略</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/xianchengchi.png"></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AFbt7VJMASenD2S8KbPKJQ" >https://mp.weixin.qq.com/s/AFbt7VJMASenD2S8KbPKJQ<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>​    定义一个模板，模板里面有子类必须实现的接口（abstract），也有可以选择重写的接口，也有直接写好了的方法（final）</p>
<p>框架应用：HttpServlet 继承GenericServlet中也还是模版方法的体现，可以自己实现doget等</p>
<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>​    我们可以用相同的方式处理集合，无论它是列表还是数组，它都提供了一种迭代其元素而不用暴露其内部结构的机制，更重要的是，不同的类型的集合都可以使用相同的统一机制</p>
<p> 这里需要注意在java 集合遍历的时候，是不允许增删数据的，因为会导致指针位置变化，导致遍历的时候，数据漏掉或重复。</p>
<h3 id="设计模式总结："><a href="#设计模式总结：" class="headerlink" title="设计模式总结："></a>设计模式总结：</h3><p><a class="link"   target="_blank" rel="noopener" href="http://www.bjpowernode.com/shejimoshi/1595.html" >http://www.bjpowernode.com/shejimoshi/1595.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/dev-spec/pattern/1_overview.html" >https://pdai.tech/md/dev-spec/pattern/1_overview.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/AobingJava/JavaFamily" >https://github.com/AobingJava/JavaFamily<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="day-7-12-15"><a href="#day-7-12-15" class="headerlink" title="day 7  12.15"></a>day 7  12.15</h2><h3 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="jdk、jre、jvm-jit编译器、Aot"><a href="#jdk、jre、jvm-jit编译器、Aot" class="headerlink" title="jdk、jre、jvm jit编译器、Aot"></a>jdk、jre、jvm jit编译器、Aot</h5><h5 id="为什么说java是解释与编译型语言结合"><a href="#为什么说java是解释与编译型语言结合" class="headerlink" title="为什么说java是解释与编译型语言结合"></a>为什么说java是解释与编译型语言结合</h5><p>​    编译型语言：直接编译为机器可以执行的代码，执行速度快，但是开发效率低，比如C++、GO等</p>
<p>​    解释型语言：<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80" >解释型语言open in new window<i class="fas fa-external-link-alt"></i></a>会通过<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8" >解释器open in new window<i class="fas fa-external-link-alt"></i></a>一句一句的将代码解释（interpret）为机器代码后再执行。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/compiled-and-interpreted-languages.png"></p>
<p>java 是先编译在解释：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/java-code-to-machine-code.png"></p>
<h5 id="java-和C-的区别"><a href="#java-和C-的区别" class="headerlink" title="java 和C++的区别"></a>java 和C++的区别</h5><ul>
<li>java 没有指针，不能直接操作内存，程序更加安全，但其实是有unsafe类可以操作内存的，在cas中就是通过unsafe获取对应内存的值来比较，unsafe操作的是堆外内存</li>
<li>java 单继承</li>
<li>java 有自动垃圾回收机制（GC），C++没有，需要程序员自己手动释放</li>
<li>java 不支持运算符重载</li>
</ul>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>对象存在于堆内存，局部变量则存在于栈内存</li>
<li>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量会被 <code>final</code> 关键字修饰成为常量</li>
</ul>
<h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>​    静态变量和静态方法是属于类的，静态方法不能调用非静态成员或者非静态方法，因为静态是属于类的，在类的加载时就分配内存了，非静态方法属于对象的，类加载的时候，这时候没有对象，自然就不能调用非静态方法或者变量。</p>
<p>​    静态方法是通过类调用的</p>
<h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p>​    重载是对同一个类的，重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，下面就是对构造方法重载</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StringBuilder</span> sb2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>重写就是子类在继承的时候，可以选择性的重写方法，要求方法名和参数都一致，返回值应该比夫类的返回值类型更小或相等，一般都是相等。但是，父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法。protected只能儿子继承。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>八种基本数据类型：</p>
<p>  6种数字类型：byte short int long float double；1种字符类型：char，1种boolean</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/data.png"></p>
<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p> 1.包装类型和基本数据类型的区别：</p>
<ul>
<li>包装类型是对象，所以不赋值，默认就是null,而基本数据类型一般有默认值的</li>
<li>包装类型因为是对象，所以存在堆中，而基本数据类型的局部变量存在栈中</li>
</ul>
<p>2.包装类型的缓存机制</p>
<p><code>    Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210422164544846.png">    3.包装类型的自动拆装箱：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h4 id="浮点数运算丢失精度"><a href="#浮点数运算丢失精度" class="headerlink" title="浮点数运算丢失精度"></a>浮点数运算丢失精度</h4><p>​    这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>​    用BigDecimal来实现浮点数计算，该包装类比较应该用compareto，对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对低。</p>
<h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><h4 id="对象的引用和对象实体"><a href="#对象的引用和对象实体" class="headerlink" title="对象的引用和对象实体"></a>对象的引用和对象实体</h4><ul>
<li>对象实体实在堆内存中，对象引用是在栈内存中。</li>
<li>对象的相等一般比较的是内存中存放的内容是否相等，引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>浅拷贝在拷贝的时候，如果拷贝的有引用类型，直接指向该引用类型，而深拷贝是拷贝引用类型时，新建一个该引用类型的对象，然后赋值引用。这里主要体现在链表的操作：分割链表。</p>
<h4 id="Object常用方法"><a href="#Object常用方法" class="headerlink" title="Object常用方法"></a>Object常用方法</h4><p>​    equal方法，引用比较的是对象的内存地址，因为本身就是存储的对象的值。不重写默认就是&#x3D;&#x3D;</p>
<p>​    hashcode，<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回，那么为什么需要hashcode呢，因为在hashmap、hashset中是根据hashcode来快速确定对象的位置，提高效率，不用一个一个去比较。</p>
<ul>
<li><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p>
</li>
</ul>
<p>重写equal时也必须重写hashcode,因为重写了equal导致有可能导致对象equal返回true,但是hashcode不一样。</p>
<h4 id="String类："><a href="#String类：" class="headerlink" title="String类："></a>String类：</h4><p>1.String、Stringbuilder、StringBuffer</p>
<ul>
<li>String：不可变，因为由final和private修饰的value（且没有暴露操作value的方法）,操作string对象，然后将指针指向新的 <code>String</code> 对象。。线程安全</li>
<li>StringBuilder：可变，并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>StringBuffer：<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li>
</ul>
<p>2.<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<h2 id="day-8-2-5"><a href="#day-8-2-5" class="headerlink" title="day 8 2.5"></a>day 8 2.5</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>java 异常类层次结构图概览</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图"></p>
<h4 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h4><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<h4 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> fnfe<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fnfe<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>basis<span class="token operator">/</span>java<span class="token operator">-</span>basic<span class="token operator">-</span>questions<span class="token operator">-</span><span class="token number">03.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型类、泛型接口、泛型接口</p>
<h3 id="java-SPI"><a href="#java-SPI" class="headerlink" title="java SPI"></a>java SPI</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>
<p>SPI是基于serviceLoader来实现的</p>
<h3 id="java-序列化"><a href="#java-序列化" class="headerlink" title="java 序列化"></a>java 序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>下面是序列化和反序列化常见应用场景：</p>
<ul>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
<p>不想被序列化：transient，反序列化之后就是默认值</p>
<h3 id="java内存结构"><a href="#java内存结构" class="headerlink" title="java内存结构"></a>java内存结构</h3><p><a class="link"   target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/memory-area.html#%E5%89%8D%E8%A8%80" >https://javaguide.cn/java/jvm/memory-area.html#%E5%89%8D%E8%A8%80<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><p><strong>JDK 1.8 之前</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.8 之前）"></p>
<p><strong>JDK 1.8 之后</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存</li>
</ul>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>​    是进程私有的，里面记录着程序目前运行着的字节码行 数，字节码解释器通过程序计数器来控制整个程序的流程控制，包括：循环、跳转以及多线程的线程恢复。</p>
<p>​    注意：不会出现outofMerroyError,因为记录的是内存地址</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>​    每个进程都有一个虚拟机栈，栈存储的每个单位为栈帧。</p>
<p>​    栈帧中存储着：局部变量表、操作数栈、动态链接、方法返回值</p>
<ul>
<li>局部 变量表：存放的就是在编译时期已知的基础变量以及对象引用（有可能是指针也有可能是句柄）。</li>
<li>操作数栈：就是在计算中暂时存放结果的地方</li>
<li>动态链接：就是在调用另外一个方法时在使用符号引用时，将符号引用转换为内存的直接引用。（在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里）</li>
<li>方法返回值：就是方法的结果返回地址</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>当虚拟机使用一个类时，他需要读取并且解析class文件，然后将类的有关信息存入到方法区中。方法区会存储类信息、字段信息、静态常量等。</p>
<p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p>
<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p>
<p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p>
<p><img src="https://img-blog.csdnimg.cn/20210425134508117.png" alt="img"></p>
<p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
<p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​    运行时常量池实在方法区中的，存储着各种编译时的字面量、符号引用、以及常量池表。</p>
<p>​    字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。</p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在堆中创建字符串对象”ab“</span>
<span class="token comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span>
<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
<span class="token comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。</p>
<p><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></p>
<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/method-area-jdk1.6.png" alt="method-area-jdk1.6"></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/method-area-jdk1.7.png" alt="method-area-jdk1.7"></p>
<p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p>
<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<p>相关问题：<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/57109429/answer/151717241" >JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎open in new window<i class="fas fa-external-link-alt"></i></a></p>
<p>最后再来分享一段周志明老师在<a class="link"   target="_blank" rel="noopener" href="https://github.com/fenixsoft/jvm_book" >《深入理解 Java 虚拟机（第 3 版）》样例代码&amp;勘误open in new window<i class="fas fa-external-link-alt"></i></a> Github 仓库的 <a class="link"   target="_blank" rel="noopener" href="https://github.com/fenixsoft/jvm_book/issues/112" >issue#112open in new window<i class="fas fa-external-link-alt"></i></a> 中说过的话：</p>
<blockquote>
<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>
</blockquote>
<h3 id="hotSpot的对象"><a href="#hotSpot的对象" class="headerlink" title="hotSpot的对象"></a>hotSpot的对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><h5 id="一-类加载检查"><a href="#一-类加载检查" class="headerlink" title="一:类加载检查"></a>一:类加载检查</h5><p>虚拟机遇到new之后，会去方法区中的常量池中去检查是否有该类的符号引用，并检查该类有没有加载、解析初始化过，如果没有，再进行类的加载过程。</p>
<h5 id="二：分配空间"><a href="#二：分配空间" class="headerlink" title="二：分配空间"></a>二：分配空间</h5><p>在类加载检查之后，发现需要加载，这个时候在堆中分配一块内存给该对象。分配空间的方式又有两种：选择哪种分配方式与java堆是否是规整的，是否是规整又取决与垃圾回收器的回收算法，是否有 整理压缩。 </p>
<p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞 ： <ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ： <ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS著作权归所有 原文链接：<a class="link"   target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/memory-area.html" >https://javaguide.cn/java/jvm/memory-area.html<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h5 id="三：初始化零值"><a href="#三：初始化零值" class="headerlink" title="三：初始化零值"></a>三：初始化零值</h5><p>内存分配完成之后，需要将分配的内存空间都初始化为零值，这样就可以保证对象的实例字段在java代码中不赋值就可以使用，程序就能访问带字段数据对应的“零值”</p>
<h5 id="四：设置对象头"><a href="#四：设置对象头" class="headerlink" title="四：设置对象头"></a>四：设置对象头</h5><p>初始化零值之后，就需要对对象进行设置，比如该对象是哪一个类 的实例、GC年代、以及对象的哈希码等，这些都存储在对象头中，根据虚拟机的状态不同，也许还有偏向锁等</p>
<h5 id="五：执行init方法"><a href="#五：执行init方法" class="headerlink" title="五：执行init方法"></a>五：执行init方法</h5><p>在上面的工作执行完之后，对于虚拟机来说，对象就创建出来了，但是对于java程序来说，还会执行init方法，按照程序员的意思创建对象。</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象在内存中存储时包含三部分：对象头、实例数据、对齐填充</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>
<h5 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h5><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p>
<h5 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h5><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p>
<p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p>
<h3 id="day-9-2-8"><a href="#day-9-2-8" class="headerlink" title="day 9 2.8"></a>day 9 2.8</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h4 id="collection-list"><a href="#collection-list" class="headerlink" title="collection-list"></a>collection-list</h4><p>ArrayList和Vector的区别：底层都是用Object[],但是Vector是线程安全的，ArrayList不是线程安全的</p>
<p>ArrayList和LinkedList的区别：</p>
<p>​    主要是底层数据结构的不同导致的区别：</p>
<ul>
<li>ArrayList是有Object[]数组构成的，所以他支持随机访问，以及在对集合的增删改查的时候的时间复杂度受元素个属影响，因为是数组，所以在list列表结尾会预留空间</li>
<li>LinkedList因为是由链表构成的list,所以不支持随机访问，在访问元素的时候需要从头开始，在对集合的增删改查的时间复杂度不受元素个数影响，因为是链表所以每一个元素需要存储后指针，所以需要更多的空间。</li>
</ul>
<h5 id="arraylist源码扩容分析"><a href="#arraylist源码扩容分析" class="headerlink" title="arraylist源码扩容分析"></a>arraylist源码扩容分析</h5><p>无参构造的默认大小为10,判断是否扩容，就是在minCapacity - elementData.length（元素的容量） &gt; 0，如果大于，则扩容，不大于不会进入 （执行）<code>grow(minCapacity)</code> 方法，扩容是扩minCapacity，每次扩为之前的1.5倍）左右，是位运算（（向右移一位相等于是除以2，然后加起来），最大Integer.MAX_VALUE - 8，如果大于就会为Integer.MAX_VALUE</p>
<h5 id="ensureCapacity"><a href="#ensureCapacity" class="headerlink" title="ensureCapacity"></a>ensureCapacity</h5><p>通过运行结果，我们可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以提升性能。不过，这个性能差距几；；乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素</p>
<h4 id="collection-set"><a href="#collection-set" class="headerlink" title="collection-set"></a>collection-set</h4><p>定制排序：</p>
<p>1.实现Comparator中的compare</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>collection<span class="token operator">/</span>java<span class="token operator">-</span>collection<span class="token operator">-</span>questions<span class="token operator">-</span><span class="token number">01.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.在类中实现接口以及重写compareto方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token comment">/**
     * T重写compareTo方法实现按年龄来排序
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">&lt;</span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>collection<span class="token operator">/</span>java<span class="token operator">-</span>collection<span class="token operator">-</span>questions<span class="token operator">-</span><span class="token number">01.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>HashSet、LinkedHashSet 和 TreeSet的异同：</p>
<p> 都不是线程安全的，底层数据结构不同：HashSet是hashmap,LinkedHashSet是链表加hashmap,满足FIFO,TreeSet是红黑树，支持定制排序，所以对应的应用场景也不同。</p>
<h4 id="collection-queue"><a href="#collection-queue" class="headerlink" title="collection-queue"></a>collection-queue</h4><p>deque是queue的扩展，注意PriorityQueue，可以定制排序。</p>
<h4 id="collection-map"><a href="#collection-map" class="headerlink" title="collection-map"></a>collection-map</h4><p>1.8之后在解决hash冲突的时候变成了，链表的长度大于阈值的时候，就将装换为红黑树，将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</p>
<p>hashMap初始容量是16，扩容之后变为原来的两倍，什么时候扩容：</p>
<p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<h5 id="Hashmap和hashtable的区别"><a href="#Hashmap和hashtable的区别" class="headerlink" title="Hashmap和hashtable的区别"></a>Hashmap和hashtable的区别</h5><p>hashmap是非线程安全的，hashtable是线程安全的，但是即使要考虑线程安全，也不要用hashtable,尽量用concurrentmap</p>
<h5 id="hashset和hashmap"><a href="#hashset和hashmap" class="headerlink" title="hashset和hashmap"></a>hashset和hashmap</h5><p>hashset就是基于hashmap实现的，只不过套了一层。</p>
<h5 id="hashmap和treemap"><a href="#hashmap和treemap" class="headerlink" title="hashmap和treemap"></a>hashmap和treemap</h5><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p>
<h5 id="concurrentmap"><a href="#concurrentmap" class="headerlink" title="concurrentmap"></a>concurrentmap</h5><p>线程安全的，在jdk 1.7时使用的segment+分段锁+数组+链表实现的。每个segment一把锁，想要访问该segment里的元素就需要获取锁，在1.8时就用的是node数组加+链表或者数组</p>
<p><strong>线程安全实现方式</strong> ：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p>
<p><strong>并发度</strong> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p>
<h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><p>就是BIO,应用程序发起IO请求，会一直阻塞，直到内核把数据拷贝到用户空间</p>
<h4 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h4><p>应用程序发起IO请求，不会一直阻塞，会一直询问，</p>
<p> <strong>同步非阻塞 IO 模型</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<h4 id="AIO-异步"><a href="#AIO-异步" class="headerlink" title="AIO 异步"></a>AIO 异步</h4><p>请求回调</p>
<h3 id="java-并发"><a href="#java-并发" class="headerlink" title="java 并发"></a>java 并发</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指：多个线程在运行的时候，同时被阻塞，阻塞的原因是因为一个或者多个都在互相等待资源释放，造成了无限循环等待，这就是死锁</p>
<h5 id="预防和破坏死锁"><a href="#预防和破坏死锁" class="headerlink" title="预防和破坏死锁"></a>预防和破坏死锁</h5><p>一次性申请所有资源、申请不到资源就释放自己占用的资源、</p>
<h4 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait 和sleep"></a>wait 和sleep</h4><p>wait会释放锁，需要其他线程来notify，sleep是thread的方法，不会释放锁</p>
<p>直接使用thread.run是错误的，<strong>调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS是用来实现乐观锁，CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。ABA问题：解决方法：先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志    </p>
<h4 id="volatile（结合单例模式的线程安全的双重检查来记忆）"><a href="#volatile（结合单例模式的线程安全的双重检查来记忆）" class="headerlink" title="volatile（结合单例模式的线程安全的双重检查来记忆）"></a>volatile（结合单例模式的线程安全的双重检查来记忆）</h4><p>单例模式：</p>
<p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>保证了变量的可见性，每个线程每次获取该变量的时候，都需要去主存中获取拷贝到自己的共享变量副本中，</p>
<p>禁止指令重排（为了性能优化，JMM在不改变正确语义的情况下会允许编译器和处理器对指令序列进行重排序），通过插入内存屏障来实现，内存屏障就是在java编译器在指定的地方插入内存屏障指令来禁止处理器进行重排序</p>
<p>不保证 变量的原子性</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p> 解决的是多线程访问资源的同步性，可以方法或者代码块线程安全。</p>
<p>早期synchronized是重量级锁，因为监视器锁monitor是基于操作系统的来实现的，挂起或者恢复线程的时候都需要操作系统在内核态和用户态之间切换，所以    性能不高。</p>
<p>在java6之后，synchronized有了很大的优化：自旋锁、适应自旋锁、锁粗化、偏向锁以及轻量级锁</p>
<p>使用：</p>
<ul>
<li>修饰实例方法：锁的是对象</li>
<li>修饰静态方法：锁的是类，因为静态方法属于类</li>
<li>修饰代码块：锁对象或者类</li>
</ul>
<p>从字节码分析：</p>
<p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p>不过两者的本质都是对对象监视器 monitor 的获取。</p>
<p>java6对synchronized的优化：无锁、偏向锁、轻量级锁、重量级锁。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是针对一个线程来说的，假如有两个线程来竞争的话，就升级成轻量级锁。</p>
<p> 为什么要这样做呢？<em>因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因</em></p>
<p>我们假设线程A曾经拥有锁（不确定是否释放锁）， 线程B来竞争锁对象，如果当线程A不在拥有锁时或者死亡时，线程B直接去尝试获得锁（根据是否 允许重偏向（<code>rebiasing</code>），获得偏向锁或者轻量级锁）；如果线程A仍然拥有锁，那么锁 升级为轻量级锁，线程B自旋请求获得锁</p>
<h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h4><p>线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录（<code>Lock Record</code>）的指针， 如上图所示。如果成功，当前线程获得轻量级锁，如果失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数 达到界限值（<code>threshold</code>），轻量级锁将会膨胀为重量级锁。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>​    重量级锁（<code>heavy weight lock</code>），是使用操作系统互斥量（<code>mutex</code>）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。但是注意，当锁膨胀（<code>inflate</code>）为重量锁时，就不能再退回到轻量级锁</p>
<p>​    首先要明确一点是引入这些锁是为了提高获取锁的效率, 要明白每种锁的使用场景, 比如偏向锁适合一个线程对一个锁的多次获取的情况; 轻量级锁适合锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况.</p>
<h4 id="synchronized和reentrantlock"><a href="#synchronized和reentrantlock" class="headerlink" title="synchronized和reentrantlock"></a>synchronized和reentrantlock</h4><p>​    都是可重入锁，可重入锁就是自己可以获取自己获取到的对象锁，就在对象锁的锁计数器加一，jdk的lock接口实现的锁都是可重入锁，包括synchronized。</p>
<p>Renentrantlock比synchronized增加的功能：</p>
<ul>
<li>可以实现非公平锁和公平锁</li>
<li>可以实现选择性唤醒：<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</li>
<li>等待可中断：通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
</ul>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>​    是指每一个线程私有的本地变量，不会被其他线程访问。</p>
<p>原理：其实底层使用threadlocalmap来实现的，就是hashmap，调用api：set以及get。</p>
<p>内存泄漏问题：</p>
<p>​    因为threadlocalmap中的key是弱引用，如果垃圾回收的时候，key被回收，但是value是强引用，    所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h4 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h4><p>原子类就是具有原子操作的类，类在多个线程中是线程安全的，主要是使用CAS加volatile和native方法，通过Unsafe类中的objectFieldOffset（），是一个本地方法，获取原来的值的内存地址，然后通过volatile在主存中获取该值的最新值。</p>
<h5 id="Atomic主要分为四类"><a href="#Atomic主要分为四类" class="headerlink" title="Atomic主要分为四类"></a>Atomic主要分为四类</h5><ul>
<li><p>基本类型：AtomicInteger、AtomicBoolean</p>
</li>
<li><p>数组类型：AtomicIntegerArray</p>
</li>
<li><p>引用类型：AtomicReference：引用类型原子类;</p>
<p><code>AtomicStampedReference</code> ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题</p>
</li>
<li><p>对象的属性修改类型 ：</p>
</li>
</ul>
<h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><p>​    JMM是java内存模型，注意这里和jvm中的java内存结构区分，这里的JMM是指的在java多线程开发的时候，为了防止在多线程开发出现因CPU缓存和指令重排序出现问题的一系列规范。</p>
<h5 id="为什么需要JMM"><a href="#为什么需要JMM" class="headerlink" title="为什么需要JMM"></a>为什么需要JMM</h5><p>​    在操作系统层面，也有内存模型，编程语言完全可以复用操作系统的内存模型，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p>
<p>​    对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的</p>
<h5 id="保证共享变量在主内存和线程本地内存的一致性"><a href="#保证共享变量在主内存和线程本地内存的一致性" class="headerlink" title="保证共享变量在主内存和线程本地内存的一致性"></a>保证共享变量在主内存和线程本地内存的一致性</h5><p>八种同步操作：解锁、锁定、read、load….</p>
<p>还有八种规则保证这八种操作的正确执行。</p>
<h5 id="Happens-before"><a href="#Happens-before" class="headerlink" title="Happens-before"></a>Happens-before</h5><p>通过happens-before来实现在多线程下，确保编译器和处理器对指令的重排序不出问题。</p>
<h3 id="day-9-2-9"><a href="#day-9-2-9" class="headerlink" title="day 9 2.9"></a>day 9 2.9</h3><h4 id="java-线程"><a href="#java-线程" class="headerlink" title="java 线程"></a>java 线程</h4><h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul>
<li>降低资源的消耗：频繁的建立和销毁线程会消耗大量资源</li>
<li>提高响应时间：在任务到达时，不用等待线程创建的时间</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的建立，不仅消耗资源，还会降低系统的稳定性，使用线程池可以统一的分配以及监控管理（可以用对应的APi获取当前线程池的线程数以及活跃线程数以及等待数）</li>
</ul>
<h5 id="建议使用ThreadPoolExecutor构造函数建议线程池"><a href="#建议使用ThreadPoolExecutor构造函数建议线程池" class="headerlink" title="建议使用ThreadPoolExecutor构造函数建议线程池"></a>建议使用ThreadPoolExecutor构造函数建议线程池</h5><p>​    强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM</li>
</ul>
</blockquote>
<h5 id="ThreadPoolExecutor构造函数参数解析"><a href="#ThreadPoolExecutor构造函数参数解析" class="headerlink" title="ThreadPoolExecutor构造函数参数解析"></a>ThreadPoolExecutor构造函数参数解析</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的核心线程数量</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的最大线程数</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//时间单位</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//任务队列，用来储存等待执行任务的队列</span>
                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//线程工厂，用来创建线程，一般默认即可</span>
                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>
                               <span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p>
<h5 id="线程池运行"><a href="#线程池运行" class="headerlink" title="线程池运行"></a>线程池运行</h5><h5 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h5><p>execute –&gt; addWorker –&gt;runworker (getTask)</p>
<p>AddWorker：addWorker主要负责创建新的线程并执行任务 线程池创建新线程执行任务时，需要 获取全局锁:</p>
<h5 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h5><p>submit任务，等待线程池execute</p>
<p>执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中， 并阻塞等待运行结果；</p>
<p>FutureTask任务执行完成后，通过UNSAFE设置waiters相应的waitNode为null，并通过LockSupport类unpark方法唤醒主线程；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> es<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">return</span> <span class="token string">"future result"</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">String</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>java<span class="token operator">/</span>thread<span class="token operator">/</span>java<span class="token operator">-</span>thread<span class="token operator">-</span>x<span class="token operator">-</span>juc<span class="token operator">-</span>executor<span class="token operator">-</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="任务的关闭"><a href="#任务的关闭" class="headerlink" title="任务的关闭"></a>任务的关闭</h5><p>shutdown：将线程池里的线程状态设置成SHUTDOWN状态, 然后中断所有没有正在执行任务的线程.</p>
<p>shutdownNow:将线程池里的线程状态设置成STOP状态, 然后停止所有正在执行或暂停任务的线程. 只要调用这两个关闭方法中的任意一个, isShutDown() 返回true. 当所有任务都成功关闭了, isTerminated()返回true</p>
<h5 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h5><p>​    如果设置太小，在高请求时，就会造成任务队列满了，导致大量请求无法处理，或者大量请求堆积导致OOM；如果设置太大，那么大量线程都在竞争CPU,就会导致上下文切换太多，影响整体效率</p>
<p>​    CPU密集：n+1,加一是防止某一个线程偶发的缺页中断或者其他原因导致的任务暂停，多一个先就可以利用该暂停的时间</p>
<p>​    IO密集：因为IO时间段是不会使用CPU的，就可以把CPU交给其他线程。</p>
<h5 id="使用线程池的注意事项："><a href="#使用线程池的注意事项：" class="headerlink" title="使用线程池的注意事项："></a>使用线程池的注意事项：</h5><p>不同业务类别使用不同的线程池，不然会造成死锁。</p>
<p>试想这样一种极端情况：假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 **”死锁”**。</p>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h5 id="AQS是什么："><a href="#AQS是什么：" class="headerlink" title="AQS是什么："></a>AQS是什么：</h5><p>​    AQS是一个用来构建锁和同步器的框架，使用AQS能够简单且高效的构造出大量的同步器，包括：reentrantlock、semaphore，因为他是一个框架，所以我们自己也能构造出自定义需求的同步器。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队&#x2F;唤醒出队等)，AQS已经在上层已经帮我们实现好了</p>
<h5 id="AQS的核心思想："><a href="#AQS的核心思想：" class="headerlink" title="AQS的核心思想："></a>AQS的核心思想：</h5><p>​    如果被请求的资源空闲，则将请求该资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的资源被占用，则需要一套线程阻塞唤醒以及被唤醒时锁分配的机制。这个机制是用CLH队列锁来实现的。AQS将请求资源的线程封装成CLH的node节点来实现锁的分配。</p>
<pre><code>  AQS使用一个int变量来表示同步状态，AQS使用CAS对该变量进行修改，private volatile int state;//共享变量，使用volatile修饰保证线程可见性。
</code></pre>
<h5 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h5><ul>
<li>独占模式：只有一个线程能够执行，reentrantlock</li>
<li>共享模式：多个线程都能访问，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock</li>
</ul>
<h5 id="AQS底层使用了模板模式的设计模式"><a href="#AQS底层使用了模板模式的设计模式" class="headerlink" title="AQS底层使用了模板模式的设计模式"></a>AQS底层使用了模板模式的设计模式</h5><p>​    使用者继承AbstractQueuedSynchronizer并重写指定的方法。自定义同步器需要重写以下AQS的模板方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
<span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
<span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>java<span class="token operator">/</span>thread<span class="token operator">/</span>java<span class="token operator">-</span>thread<span class="token operator">-</span>x<span class="token operator">-</span>lock<span class="token operator">-</span><span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<h5 id="AQS-数据结构"><a href="#AQS-数据结构" class="headerlink" title="AQS 数据结构"></a>AQS 数据结构</h5><p>除了刚刚说的CLH队列，还有一个重要的就是AQS将请求的线程作为node加入到CLH中。</p>
<p>Node中重要的几个属性:</p>
<p>解释一下几个方法和属性值的含义：</p>
<table>
<thead>
<tr>
<th align="left">方法和属性值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">waitStatus</td>
<td align="left">当前节点在队列中的状态</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示处于该节点的线程</td>
</tr>
<tr>
<td align="left">prev</td>
<td align="left">前驱指针</td>
</tr>
<tr>
<td align="left">predecessor</td>
<td align="left">返回前驱节点，没有的话抛出 npe</td>
</tr>
<tr>
<td align="left">nextWaiter</td>
<td align="left">指向下一个处于 CONDITION 状态的节点（由于本篇文章不讲述 Condition Queue 队列，这个指针不多介绍）</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">后继指针</td>
</tr>
</tbody></table>
<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHARED</td>
<td align="left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td align="left">EXCLUSIVE</td>
<td align="left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>waitStatus 有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个 Node 被初始化的时候的默认值，值为0，表示当前节点在sync queue中，等待着获取锁</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为 1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为-3，当前线程处在 SHARED 情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为-1，表示线程已经准备好了，就等资源释放了，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作</td>
</tr>
</tbody></table>
<h5 id="AQS过程"><a href="#AQS过程" class="headerlink" title="AQS过程"></a>AQS过程</h5><p>当一个线程调用acquire时，调用方法流程如下</p>
<p><img src="https://pdai.tech/images/thread/java-thread-x-juc-aqs-2.png" alt="image"></p>
<p>（1）首先调用acquire,调用此方法会试图在独占模式下获取资源，如果能够获得，就获得资源；否则调用addWaiter,将请求的线程封装成一个node放入CLH队列中</p>
<p>（2）然后调用accquireQueued,方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。具体流程是：</p>
<p>​    首先获取当前节点的前驱节点，判断是否是head节点并且能否获取资源，如果能，就获取该资源，将state+1,并且设置当前节点为头节点；否则，调用shouldParkAfterFailAcquire和parkAndCheckInterrupt</p>
<p>accquireQueued源码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 标记是否成功拿到资源</span>
	<span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 标记等待过程中是否中断过</span>
		<span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token comment">// 开始自旋，要么获取锁，要么中断</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// 获取当前节点的前驱节点</span>
			<span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token comment">// 获取锁成功，头指针移动到当前node</span>
				<span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
				p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
				failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
			<span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>concurrent<span class="token operator">/</span>reentrantlock<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（3）shouldParkAfterFailAcquire </p>
<p>​    为了防止因死循环导致 CPU 资源被浪费（没有获取到资源，会自旋），我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire 流程）：</p>
<p><img src="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png" alt="img"></p>
<h5 id="AQS总结"><a href="#AQS总结" class="headerlink" title="AQS总结"></a>AQS总结</h5><p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>A：是 CLH 变体的 FIFO 双端队列。</p>
<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
<p>A：可以详细看下 2.3.1.3 小节。</p>
<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见 2.3.2 小节。</p>
<p>Q：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？</p>
<p>A：AQS 的 Acquire 会调用 tryAcquire 方法，tryAcquire 由各个自定义同步器实现，通过 tryAcquire 完成加锁过程</p>
<p>每一个结点都是由前一个结点唤醒</p>
<p>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。</p>
<p>condition queue中的结点向sync queue中转移是通过signal操作完成的。</p>
<p>当结点的状态为SIGNAL时，表示后面的结点需要运行</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/reentrantlock.html#_2-1-%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88" >https://javaguide.cn/java/concurrent/reentrantlock.html#_2-1-%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#abstractqueuedsynchronizer%E6%80%BB%E7%BB%93" >https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#abstractqueuedsynchronizer%E6%80%BB%E7%BB%93<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="day-10-2-10"><a href="#day-10-2-10" class="headerlink" title="day 10 2.10"></a>day 10 2.10</h3><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h5 id="堆空间的结构"><a href="#堆空间的结构" class="headerlink" title="堆空间的结构"></a>堆空间的结构</h5><p>新生代、老年代、永久代（元空间）。</p>
<h5 id="内存分配以及基本原则"><a href="#内存分配以及基本原则" class="headerlink" title="内存分配以及基本原则"></a>内存分配以及基本原则</h5><ul>
<li>对象优先分配在eden区</li>
<li>大对象直接进入老年代：比如数组以及字符串这种需要较大的连续空间的对象</li>
<li>长期存活的对象进入老年代：在mior GC的时候，如果eden的对象存活，就会在age上加一，直到达到阈值就会晋升到老年代，（JDK8动态年龄判定：当虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，而是在Survivor中的相同年龄的对象的总和大小大于survivor的空间的一半，则大于或者等于的就可以进入图老年代中）</li>
<li>空间担保原则：在发生minor GC的之前，因为minor GC 中会有新生代的对象会晋升到老年代中来，所以需要确保在老年代中有“足够的空间”，虚拟机会检查老年代中的可用连续空间是否大于新生代对象总大小或者历次晋升的平均水平，如果大于就可以进行minor GC,如果小于就需要FUll GC</li>
</ul>
<h5 id="死亡对象而判断方法"><a href="#死亡对象而判断方法" class="headerlink" title="死亡对象而判断方法"></a>死亡对象而判断方法</h5><p>1.引用计数法：引用了该对象就在计数器上加一。</p>
<p>​    会出现一个问题：相互循环引用，这两个对象的不被外部任何引用，只被两个对象相互循环引用，这就导致了永远无法回收他们。</p>
<p>2.可达性分析：以GC Roots作为起点，一个对象到GC root是如果没有一条引用练，就视为可以被回收。</p>
<p>哪些对象可以作为GC ROOTs：</p>
<ul>
<li>虚拟机栈（本地变量表）中引用的对象</li>
<li>本地方法栈中的对象（native方法中）</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>被同步锁的对象</li>
</ul>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul>
<li>强引用：一个对象具有强引用，垃圾回收器是不会回收的，当内存不足的时候，JVM宁愿抛出OOM错误,也不会随意回收强引用的对象来解决内存不足的问题。</li>
<li>软引用：如果内存空间不足，就会回收这些内存</li>
<li>弱引用：和软引用差不多，但是区别在于只具有弱引用的对象生命周期更短，在垃圾回收器线程扫描对象的时候，一旦发现了只具有弱引用的对象，不管内存空间是否不足，都会回收。</li>
<li>虚引用：任何时候都会可能被回收</li>
</ul>
<p>使用弱引用和虚引用较少，使用软引用较多，可以加速jvm对垃圾内存的回收速度，放置内存溢出等问题的产生。</p>
<h4 id="如何判断常量是垃圾"><a href="#如何判断常量是垃圾" class="headerlink" title="如何判断常量是垃圾"></a>如何判断常量是垃圾</h4><p>在jdk1.7之后字符串常量池在堆中，运行常量池还在方法区中，当字符串常量池中的没有任何String对象引用他，就会视为垃圾</p>
<h4 id="如何判断类是无用的类"><a href="#如何判断类是无用的类" class="headerlink" title="如何判断类是无用的类"></a>如何判断类是无用的类</h4><p>该类的所有实例对象都被回收；该类的classloader已经被回收；该类的class对象没有在任何地方被引用。但是就算是无用的类，也不一定就被回收</p>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul>
<li>标记-清除算法</li>
<li>标记-复制</li>
<li>标记-整理</li>
</ul>
<p>为什么要分代：因为根据不同代的对象的特点可以选择不同的垃圾回收算法，提升效率。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择标记-复制算法，因为可以有分配担保原则，而且只需要付出少量的对象的复制成本。而在老年代中对象存活几率较大，而且没有额外的空间分配担保，所以选择标记-清除或者标记-整理</p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="serial-收集器"><a href="#serial-收集器" class="headerlink" title="serial 收集器"></a>serial 收集器</h5><p>单线程收集器，意味着在垃圾回收的时候是单线程，而且在垃圾回收的时候会STW。适用于client这种客户机</p>
<p><img src="https://javaguide.cn/assets/46873026.3a9311ec.png" alt=" Serial 收集器 "></p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>是serial收集器的多线程版本，新生代采用标记-复制，老年代采用标记-整理</p>
<p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="ParNew 收集器 "></p>
<h5 id="Parallel-Scanvenge收集器"><a href="#Parallel-Scanvenge收集器" class="headerlink" title="Parallel Scanvenge收集器"></a>Parallel Scanvenge收集器</h5><p>他和ParNew大概一致，区别就在于Parallel Scanvenge注重的是吞吐量， Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量</p>
<h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/cms.png" alt="CMS 垃圾收集器 "></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li>对CPU资源铭感</li>
<li>浮动垃圾</li>
<li>标记清除算法产生大量内存碎片</li>
</ul>
<h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1收集器是一款面向服务器的垃圾回收器，在多CPU和大内存的场景下有很好的性能。</p>
<p>其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p>
<p>通过引入region的概念，从而将原来的大空间分为了许多小空间，使得每个小空间都可以进行垃圾的单独回收，这样就使得了可预测的停顿模型成为可能，通过记录每个region垃圾回收时间和所回收的获得空间值（这两个值是通过过去获得的经验），并维护一个优先列表，每次根据允许的收集时间来优先选择需要回收的region.</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描</p>
<p>在局部是标记复制，整体看来是标记整理</p>
<p><strong>主要优点</strong></p>
<ul>
<li>空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>加载-验证-准备-解析-初始化-使用-卸载</p>
<p>加载：</p>
<ol>
<li>将class文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li>
</ol>
<p>验证：验证文件格式以及元数据的格式以及字节码的流程正确，确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</p>
<p>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a &#x3D; 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</p>
<p>解析：虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p>初始化：</p>
<p><strong>JVM初始化步骤</strong></p>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
</ul>
<h6 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h6><ul>
<li>启动类加载器;最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类</li>
<li>扩展类加载器类：它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器</li>
<li>应用程序类加载器：它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
<h5 id="双亲委派机制："><a href="#双亲委派机制：" class="headerlink" title="双亲委派机制："></a>双亲委派机制：</h5><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
<h3 id="Java-执行流程"><a href="#Java-执行流程" class="headerlink" title="Java 执行流程"></a>Java 执行流程</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png" alt="img"></p>
<h3 id="jdk自带的监控工具"><a href="#jdk自带的监控工具" class="headerlink" title="jdk自带的监控工具"></a>jdk自带的监控工具</h3><ul>
<li>jps查看java所有进程</li>
<li>jmap生成堆转储快照</li>
<li>jstack生成当前线程快照</li>
<li>jstat;查看虚拟机运行状态信息</li>
</ul>
<p>可视化：jconsole</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p> 主要提供终端设备之间的应用程序之间的信息通讯，在应用层方面定义了消息的格式。</p>
<p>常见的应用层协议：</p>
<ul>
<li>http：超文本传输协议</li>
<li>SMTP：简单的邮件传输协议</li>
<li>FTP：文件传输协议</li>
<li>Telnet：远程登陆协议</li>
<li>SSH：安全的网络传输协议</li>
</ul>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>负责终端设备进程之间的数据传输：</p>
<p><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</p>
<p><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>​    将传输层的数据在网络逻辑地址之间传输。</p>
<p>常见的网络层协议：</p>
<ul>
<li>IP：IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。有IPv4和IPv6</li>
<li>ARP：解决的是网络层地址和链路层地址之间的转换问题。将iP转换为mac地址的协议</li>
<li>NAT：应用于内部网到外部网的地址转换，局域网下的ip转换为互联网的公网IP</li>
<li>RIP、OSPF路由选择协议</li>
</ul>
<h5 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h5><p>是数据链路层和物理层的组合。</p>
<p>数据链路层负责将网络层的数据组装为帧，在相邻节点上传输帧（地址信息和差错校验）</p>
<p>物理层则是相邻节点的比特流的传输</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul>
<li>是否面向连接，tcp是面向连接的，而udp是不需要连接的</li>
<li>tcp是基于字节流的，udp是基于报文的</li>
<li>tcp是可靠传输，在tcp传递数据的时候，首先会有建立连接，其次在传输数据时，有消息确认、滑动窗口、和消息重传以及拥塞控制，而UDP不是可靠传输，消息发出去就完了</li>
<li>传输效率:tcp多了连接、确认、重传，所以传输效率比udp低</li>
<li>传输开销：tcp的首部4开销比udp首部开销大</li>
<li>tcp只支持点对点，而udp支持多对多</li>
<li>tcp讲究数据的准确率，而udp讲究速率。</li>
</ul>
<h4 id="什么时候选择-TCP-什么时候选-UDP"><a href="#什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="什么时候选择 TCP,什么时候选 UDP?"></a>什么时候选择 TCP,什么时候选 UDP?</h4><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等</li>
</ul>
<p>运行在udp之上的协议：DHCP和DNS</p>
<h4 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解"></p>
<ul>
<li>第一次：客户端向服务器发送syn&#x3D;x的请求数据包，然后客户端今日SYN_SEND状态，等待服务器响应</li>
<li>第二次：服务器受到客户端的数据包，向客户端返回一个SYN&#x3D;y,ACK&#x3D;x+1的数据包，然后服务器进入SYN_RECV状态</li>
<li>第三次：客户端收到服务器的数据包，向服务器发送ACK&#x3D;y+1的数据包，然后都进入ESTABLELISH,然后就可以传输数据了</li>
</ul>
<p><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解"></p>
<p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN &#x3D; 1），报文中会指定一个序列号 seq &#x3D; u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p>
<blockquote>
<p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p>
</blockquote>
<p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p>
<blockquote>
<p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p>
</blockquote>
<p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p>
<blockquote>
<p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p>
</blockquote>
<p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态，等待客户端的确认。</p>
<blockquote>
<p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p>
</blockquote>
<p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack &#x3D; w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq&#x3D;u+1），此时客户端处于 <strong><code>TIME_WAIT</code> （时间等待）状态</strong>。</p>
<blockquote>
<p><code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p>
</blockquote>
<p>🚨 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，<strong>需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 <code>CLOSED</code> 状态</strong>（这样做的目的是确保服务端收到自己的 ACK 报文。如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。服务端收到 ACK 报文之后，就关闭连接了，处于 <code>CLOSED</code> 状态。</p>
<p>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</p>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<p>为什么需要四次挥手：<br>    由于 TCP 的<strong>半关闭</strong>（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。</p>
<p>​    举个例子：A 和 B 打电话，通话即将结束后，A 说 “我没啥要说的了”，B 回答 “我知道了”，于是 A 向 B 的连接释放了。但是 B 可能还会有要说的话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，于是 B 向 A 的连接释放了，这样整个通话就结束了</p>
<p>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</p>
<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<h2 id="day-11-2-12"><a href="#day-11-2-12" class="headerlink" title="day 11 2.12"></a>day 11 2.12</h2><h4 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h4><ul>
<li>基于数据&#x2F; 块传输，应用数据被分割成最适合发送的数据块，然后传给网络层，称为报文段</li>
<li>校验和;TCP保持首部和数据的校验和，这是一个端对端的数据传输，目的是为了保证在传输过程中数据没有发生变化，如果受到的校验和有差错，就表示该数据在传输过程中发生变化，就会丢掉该数据包</li>
<li>排序数据包以及去重：对每个数据包都有序号，在接收端受到相同序号的数据包时丢掉就可以实现去重</li>
<li>超时重传</li>
<li>流量控制：在发送和接受端都有一定的缓冲空间，接收端只允许发送端发送接受端能够接受的数据大小，这会在接收端返回ACK时发送还能接受的缓冲空间</li>
<li>拥塞控制：TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong></li>
</ul>
<h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p>自动重传协议：分为两种：停止等待重传以及连续等待重传</p>
<h4 id="从输入URL到页面到底展示了什么"><a href="#从输入URL到页面到底展示了什么" class="headerlink" title="从输入URL到页面到底展示了什么"></a>从输入URL到页面到底展示了什么</h4><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p>
<ul>
<li>首先是DNS的解析，因为每台机器在互联网上真正意义的地址是ip,所以需要将输入的域名解析为ip,那么首先就会去浏览器缓存或者本地域名解析缓存以及自己连接的路由器缓存中查询是否有缓存，如果没有就会产生递归查询的dns解析，本地域名解析没有就向根域名解析服务器请求，如果根域名解析器没有，就会向顶级域名解析服务器请求。当然在域名服务器中也有缓存。</li>
<li>TCP连接：三次握手，这里因为是http协议，所以会将请求报文首先在应用层封装，然后通过tcp连接发送</li>
<li>服务器接受到请求之后，返回http响应报文：状态码、响应包头、响应报文</li>
<li>浏览器解析并且渲染报文</li>
</ul>
<h4 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h4><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="HTTP 状态码"></p>
<h4 id="HTTPS-和HTTP"><a href="#HTTPS-和HTTP" class="headerlink" title="HTTPS 和HTTP"></a>HTTPS 和HTTP</h4><p>​    HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>SSL&#x2F;TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>
<blockquote>
<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>
<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>
<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>
</blockquote>
<p><img src="/HexoBlog/assets/public-key-cryptography.22f51898.png" alt="img"></p>
<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>使用 SSL&#x2F;TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL&#x2F;TLS 实际对消息的加密使用的是对称加密。</p>
<blockquote>
<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>
</blockquote>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png" alt="img"></p>
<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL&#x2F;TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性</p>
<h5 id="公钥传输的信赖性"><a href="#公钥传输的信赖性" class="headerlink" title="公钥传输的信赖性"></a>公钥传输的信赖性</h5><p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<h4 id="ARP："><a href="#ARP：" class="headerlink" title="ARP："></a>ARP：</h4><p>​    它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ul>
<li>进程：一个进程就是CPU执行的单个任务的过程，是程序在执行过程中CPU资源分配的最小单位，</li>
<li>线程：是CPU调度的最小单位，和同一个进程的其他线程共享该进程的资源</li>
</ul>
<h4 id="进程的五个状态："><a href="#进程的五个状态：" class="headerlink" title="进程的五个状态："></a>进程的五个状态：</h4><ul>
<li>创建</li>
<li>就绪</li>
<li>运行</li>
<li>阻塞</li>
<li>结束</li>
</ul>
<h4 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h4><ul>
<li>管道：有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信，有名管道严格遵循<strong>先进先出(first in first out)</strong></li>
<li>信号：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>消息队列：消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li>
<li>共享内存：信号量和互斥锁，用于进程之间的同步操作</li>
<li>套接字</li>
</ul>
<h4 id="进程之间同步的实现"><a href="#进程之间同步的实现" class="headerlink" title="进程之间同步的实现"></a>进程之间同步的实现</h4><ul>
<li>互斥锁：只有持有互斥对象的线程才能拥有该资源，例如java中的synchronized以及lock</li>
<li>信号量：限制同一时刻资源能被访问的最大线程数</li>
<li>线程唤醒：:Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步</li>
</ul>
<h4 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h4><ul>
<li>先来先服务</li>
<li>短作业优先</li>
<li>最高响应比</li>
<li>时间片轮转</li>
<li>静态优先级</li>
</ul>
<h4 id="死锁的4个必要条件"><a href="#死锁的4个必要条件" class="headerlink" title="死锁的4个必要条件"></a>死锁的4个必要条件</h4><ul>
<li>资源互斥</li>
<li>非抢占：资源被占有之后就不能被其他进程抢占，只有等待拥有资源的进程释放</li>
<li>占有并等待：拥有资源，等待另一个资源</li>
<li>循环等待</li>
</ul>
<h4 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h4><p>针对每一个必要条件预防：</p>
<ul>
<li>互斥：使得资源可以共享，磁盘就是这种方法管理，但是一般资源都是不能共同访问的</li>
<li>非抢占：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所有的资源，会导致 <strong>资源利用率下降</strong></li>
<li>占有并等待：静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行，也降低了资源利用率</li>
<li>循环等待：（1）层次分配，将资源分为多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的（2）在一定时间内获取不到资源就释放拥有的资源</li>
</ul>
<p>避免死锁：</p>
<p>在申请资源时，作安全性检查：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<h4 id="（二）内存管理"><a href="#（二）内存管理" class="headerlink" title="（二）内存管理"></a>（二）内存管理</h4><p>主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情</p>
<h4 id="常见的内存管理机制"><a href="#常见的内存管理机制" class="headerlink" title="常见的内存管理机制"></a>常见的内存管理机制</h4><p>简单的分为连续分配和非连续分配，连续分配如：块式分配；非连续为：段和页</p>
<p><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</p>
<p><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址</p>
<p><strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
<h4 id="快表和多极页表"><a href="#快表和多极页表" class="headerlink" title="快表和多极页表"></a>快表和多极页表</h4><p>在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题</li>
</ol>
<h5 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h5><p>​    为了提高虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。</p>
<p>根据虚拟地址中的页号查快表；</p>
<p>如果该页在快表中，直接从快表中读取相应的物理地址；</p>
<p>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</p>
<p>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</p>
<h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中</p>
<h4 id="分页机制和分段机制的共同以及区别"><a href="#分页机制和分段机制的共同以及区别" class="headerlink" title="分页机制和分段机制的共同以及区别"></a>分页机制和分段机制的共同以及区别</h4><p>共同：</p>
<ul>
<li>都是为了提高内存利用率，减少内存碎片</li>
<li>都是离散存储的。</li>
</ul>
<p>区别：</p>
<ul>
<li>页的大小是固定的，有操作系统决定；而段是由程序决定的</li>
<li>页是仅仅为操作系统内存分配的，而段能够体现逻辑信息：比如代码段、数据段</li>
</ul>
<h3 id="（三）虚拟内存"><a href="#（三）虚拟内存" class="headerlink" title="（三）虚拟内存"></a>（三）虚拟内存</h3><h4 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h4><p>​    虚拟内存为每一个进程提供了一致、私有的地址空间，让进程产生了一种独享主存的感觉，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<p>​    虚拟内存的重要意义就在于定义了连续的虚拟地址空间，然后内存扩展到了硬盘空间。</p>
<h4 id="为什么要有虚拟地址空间"><a href="#为什么要有虚拟地址空间" class="headerlink" title="为什么要有虚拟地址空间"></a>为什么要有虚拟地址空间</h4><p>没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ul>
<li>用户程序随意访问内存，容易破坏操作系统</li>
<li>想要同时运行多个程序很困难</li>
</ul>
<p>使用虚拟内存的优势：</p>
<ul>
<li>程序可以使用相邻的虚拟地址来访问不相邻的物理内存</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动</li>
</ul>
<h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>​    局部性原理是虚拟内存技术的基础，局部性原理是指的：在程序运行的过程中往往呈现出一种局部性规律，也就是在某个短时间内，程序执行局限于某一部分，存储空间也局限与某一部分。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过近来运行的指令和数据保存到高速缓存器中，空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p>
<p>虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存</p>
<p>​    基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——<strong>虚拟存储器</strong>。</p>
<h4 id="虚拟内存技术的实现"><a href="#虚拟内存技术的实现" class="headerlink" title="虚拟内存技术的实现"></a>虚拟内存技术的实现</h4><p>​    虚拟内存的技术的实现是基于离散性的内存管理上的，</p>
<p>虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p>需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰</li>
</ul>
<h2 id="day-12-2-14"><a href="#day-12-2-14" class="headerlink" title="day 12 2.14"></a>day 12 2.14</h2><h3 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h3><h4 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h4><p>同步阻塞IO，是指在用户线程通过系统调用调用read发起IO操作，由用户空间转到内核空间，然后内核处理进行IO操作之后，得到数据包，将数据包拷贝到用户空间，完成read操作，整个操作用户线程是阻塞等待内核空间的IO的</p>
<p><img src="http://images.cnitblog.com/blog/405877/201411/142330286789443.png" alt="img"></p>
<p><strong>缺点</strong>：</p>
<ul>
<li>一个线程处理一个用户的请求，在高并发下，整个服务器创建线程的数量是有限制的，所以并发量不高</li>
<li>而且在处理能够承受的并发时，线程数多，会导致cpu在线程的切换频繁，导致效率低下</li>
<li>而且一个请求建立一个线程导致线程的建立和摧毁花费大量时间，这个可以用线程池解决</li>
</ul>
<h4 id="同步非阻塞IO-1"><a href="#同步非阻塞IO-1" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h4><p>用户线程在发起系统调用后，用户线程立即返回，不会一直阻塞，会但是因为是同步的，为了等到数据，需要不断的轮询、重复请求，消耗了大量的CPU资源。</p>
<p><img src="http://images.cnitblog.com/blog/405877/201411/142332004602984.png" alt="img"></p>
<h4 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>I&#x2F;O多路复用就是通过一种机制，一个进程可以监视多个描述符（socket），一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作</p>
<p><img src="http://images.cnitblog.com/blog/405877/201411/142332187256396.png" alt="img"></p>
<pre><code> 用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回。当数据到达时，socket被激活，select函数返回，用户线程正式发起read请求，读取数据并继续执行
</code></pre>
<p>​    看起来虽然和同步阻塞没有太大区别，甚至还多了socket监视和select函数的调用，但是使用select之后，用户可以在一个线程内同时处理多个socket的IO请求，这就是它的最大优势。用户可以注册多个socket，然后不断调用select读取被激活的socket，<strong>即可达到同一个线程同时处理多个IO请求的目的</strong>。而在同步阻塞模型中，必须通过多线程方式才能达到这个目的。<strong>所以IO多路复用设计目的其实不是为了快，而是为了解决线程&#x2F;进程数量过多对服务器开销造成的压力。</strong></p>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>​    select本质是设置或检查fd标志位的数据结构来进行处理的，这样的缺点就是：</p>
<ul>
<li>一个进程所能打开的fd是有限的，1024,</li>
<li>每次调用select都需要将fd从用户态拷贝到内核态，需要一个用来存放大量fd的数据结构，在用户空间和内核空间之间复制会开销大</li>
<li>对socket采取的是轮询，随着fd增多，效率降低</li>
</ul>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>和select差不多，主要区别就在于他用来存储fd的是链表结构，所以对fd连接数没有限制</p>
<h5 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h5><p><code>epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次</code>。还有一个特点是，<code>epoll使用“事件”的就绪通知方式</code>，通过epoll_ctl注册fd，<code>一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd</code>，epoll_wait便可以收到通知。</p>
<p>优点：</p>
<ul>
<li><code>没有最大并发连接的限制</code>，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。</li>
<li><code>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降</code>。只有活跃可用的FD才会调用callback函数；<code>即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关</code>，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll</li>
<li><code>内存拷贝</code>，利用mmap()文件映射内存加速与内核空间的消息传递；<code>即epoll使用mmap减少复制开销</code>。</li>
</ul>
<h4 id="select、poll、epoll区别"><a href="#select、poll、epoll区别" class="headerlink" title="select、poll、epoll区别"></a>select、poll、epoll区别</h4><ol>
<li><strong>支持一个进程所能打开的最大连接数</strong></li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-a9f94d9cbaccc8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1170/format/webp" alt="img"></p>
<p>输入图片说明</p>
<ol>
<li><strong>FD剧增后带来的IO效率问题</strong></li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-34d8955371a90dad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1168/format/webp" alt="img"></p>
<p>输入图片说明</p>
<ol>
<li><strong>消息传递方式</strong></li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/2062729-4798b7e2d5199e6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1168/format/webp" alt="img"></p>
<h4 id="netty的线程模型Reactor"><a href="#netty的线程模型Reactor" class="headerlink" title="netty的线程模型Reactor"></a>netty的线程模型Reactor</h4><p>Reactor基于事件驱动，采用多路复用将事件分发给相应的handler处理，适合海量IO的场景。</p>
<p>netty中基于NIOEventloopGroup线程池来实现线程模型，实现服务端的时候一般初始化两个线程组</p>
<ul>
<li>bossGroup：用于连接</li>
<li>workGroup:用于具体的处理，交给各种handler</li>
</ul>
<h4 id="netty网络框架比JDK自带NIO编程便利："><a href="#netty网络框架比JDK自带NIO编程便利：" class="headerlink" title="netty网络框架比JDK自带NIO编程便利："></a>netty网络框架比JDK自带NIO编程便利：</h4><p>在jdk自带的NIO的api中，NIO在面对粘包、编码、以及自带的一些协议栈、更方便的api</p>
<h4 id="netty的应用场景"><a href="#netty的应用场景" class="headerlink" title="netty的应用场景"></a>netty的应用场景</h4><ul>
<li>RPC的远程调用</li>
<li>http服务器</li>
<li>即时通讯</li>
<li>消息推送</li>
</ul>
<h4 id="TCP粘包-x2F-拆包"><a href="#TCP粘包-x2F-拆包" class="headerlink" title="TCP粘包&#x2F;拆包"></a>TCP粘包&#x2F;拆包</h4><p>因为tcp是面向字节流的连接，所以必须在应用层对数据进行拆包，正确接受数据，</p>
<ul>
<li>使用编解码器，换行符分割编码器、固定长度编码器、基于长度字段的解码器</li>
<li>使用自定义序列化编码器</li>
</ul>
<h4 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h4><p>因为有些时候由于网络设备的原因，底层的tcp连接已经断了，但是在应用层并未感知，如果应用层一直不删除连接channel,就会造成资源浪费，所以需要一个机制来解决这个问题，这就是心跳机制。</p>
<p>就是在一定时间自动发送心跳包，来确定连接正确。</p>
<h4 id="netty的零拷贝"><a href="#netty的零拷贝" class="headerlink" title="netty的零拷贝"></a>netty的零拷贝</h4><p> 一般在操作系统层面上所谓的零拷贝就是避免在用户态和内核态之间拷贝数据导致的开销，在操作系统上mmap就通过用户态和内核态共用一块内存。</p>
<p>在netty中的零拷贝就是指数据操作的优化：</p>
<p>bytebuf的合并以及切片都是在逻辑上合并或者拆开，实际上没有发生拷贝。</p>
<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>使用redis的好处：</p>
<ul>
<li>redis是基于内存的，所以访问速度比访问磁盘速度快很多</li>
<li>redis有优化过后丰富的数据结构，提高了性能以及便利</li>
<li>能够支持持久化</li>
<li>基于reactor实现了一套高效的事件处理机制，采用单线程循环加IO多路复用</li>
<li>可以实现集群部署</li>
</ul>
<p>redis除了能够用来做缓存还可以做什么：</p>
<ul>
<li>分布式锁：redisson</li>
<li>限流</li>
<li>消息队列</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜</li>
</ul>
<h4 id="redis的数据结构"><a href="#redis的数据结构" class="headerlink" title="redis的数据结构"></a>redis的数据结构</h4><h5 id="String"><a href="#String" class="headerlink" title="String"></a>String</h5><p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象</p>
<p>内部实现：简单动态字符串SDS,为什么没有用C语言的字符串呢？</p>
<ul>
<li>SDS既可以存储文本信息，也可以存储二进制信息，例如图片、音频</li>
<li>SDS获取字符串长度的复杂度是O（1），而C语言中是O（n）</li>
<li>SDS的API是安全的，拼接字符串不会造成缓冲区溢出</li>
<li>节省了内存空间，取消编译时期的结构体字节对齐</li>
</ul>
<p>因为SDS的数据结构是有字符串长度、分配的空间、SDS类型（决定了<strong>len 和 alloc 成员变量的数据类型不同</strong>）、字节数组</p>
<p>应用场景：</p>
<ul>
<li>存储常规数据：缓存session、图片、序列化后的对象（消耗内存比hash少）</li>
<li>需要计数的场景:用户单位时间的请求数（简单的限流）、页面单位时间的访问数</li>
<li>分布式锁：setnx key value</li>
</ul>
<h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>内部实现：</p>
<p>在redis3.2之前就是用压缩列表和双向链表实现的：</p>
<ul>
<li>当列表的元素少于512个（默认，可以自己设置），而且每个元素的值都小于64字节，就会用压缩列表作为底层的数据结构，反之，则用双向链表</li>
</ul>
<p>但是在redis 3.2之后就使用的quicklist来代替了</p>
<p>应用场景：信息流展示：最新文章以及最新动态、</p>
<p>消息队列：</p>
<ul>
<li>消息保序：使用 LPUSH + RPOP；</li>
<li>阻塞读取：使用 BRPOP；</li>
<li>重复消息处理：生产者自行实现全局唯一 ID；</li>
<li>消息的可靠性：使用 BRPOPLPUSH</li>
</ul>
<h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><p>内部实现：</p>
<p>之前使用压缩列表或者哈希表实现的，如果希类型元素个数小于 <code>512</code> 个（默认值，可由 <code>hash-max-ziplist-entries</code> 配置），所有值小于 <code>64</code> 字节（默认值，可由 <code>hash-max-ziplist-value</code> 配置）的话，Redis 会使用<strong>压缩列表</strong>作为 Hash 类型的底层数据结构。</p>
<p><strong>Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong></p>
<p>应用场景：对象存储：用户信息、实体信息</p>
<h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>无序集合:但是是唯一的</p>
<p>内部实现：</p>
<p>​    当元素个数少于512时，就是用整数集合实现的，否则就是用的哈希表</p>
<p><strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong></p>
<p>应用场景：</p>
<ul>
<li>需要存放的数据是不能重复的场景：某一个网站的人数统计（如果数量较大还是HyperLogLog更适合）</li>
<li>需要获取多个数据源交集、并集、差：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等</li>
<li>需要随即获取数据源中的数据且不能重复：抽奖</li>
</ul>
<h5 id="Sored-Set"><a href="#Sored-Set" class="headerlink" title="Sored Set"></a>Sored Set</h5><p>有序集合</p>
<p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p>
<ul>
<li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li>
<li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li>
</ul>
<p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了</strong></p>
<p>应用场景：</p>
<ul>
<li>需要根据某个权重来实现排序：微信步数的排行榜</li>
</ul>
<h5 id="Bit-map"><a href="#Bit-map" class="headerlink" title="Bit map"></a>Bit map</h5><p>只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 </p>
<p>应用场景:只用0或1就能表示的场景：用户是否活跃、用户是否签到、用户行为统计（是否点赞）</p>
<h5 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h5><p><code>HyperLogLog</code>，下面简称为<code>HLL</code>，它是 <code>LogLog</code> 算法的升级版，作用是能够提供不精确的去重计数</p>
<p>应用场景：数量极大（百万、千万级别以上）的计数场景：热门网站访问ip的统计</p>
<h5 id="Geospatial-index"><a href="#Geospatial-index" class="headerlink" title="Geospatial index"></a>Geospatial index</h5><p>主要用于存储地理位置信息，基于 Sorted Set 实现</p>
<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用</p>
<p>应用场景：附近的人</p>
<h5 id="存储对象String和hash的区别"><a href="#存储对象String和hash的区别" class="headerlink" title="存储对象String和hash的区别"></a>存储对象String和hash的区别</h5><p>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</p>
<p>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</p>
<p>绝大部分用String存储。</p>
<h4 id="redis-的线程模型"><a href="#redis-的线程模型" class="headerlink" title="redis 的线程模型"></a>redis 的线程模型</h4><p> redis基于reactor模式开发了一套高效的事件处理模型。</p>
<p>​    文件事件处理器使用 I&#x2F;O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</p>
<p>​    当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件</p>
<p>​    <strong>文件事件处理器以单线程方式运行，但通过使用 I&#x2F;O 多路复用程序来监听多个套接字</strong></p>
<pre><code> **I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**
</code></pre>
<p>为什么redis不使用多线程：</p>
<p>（1）主要原因是因为redis的性能瓶颈不在于CPU,所以多线程带来的充分利用CPU并没有多大益处，这些数据的读写由于只发生在内存中，所以处理速度是非常快的；整个服务的瓶颈在于网络传输带来的延迟和等待客户端的数据传输，也就是网络 I&#x2F;O，所以使用多线程模型处理全部的外部请求可能不是一个好的方案</p>
<p>（2）用单线程使代码开发和维护成本降低</p>
<p>为什么在redis6之后引入了多线程呢？</p>
<p>​    因为在 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率</p>
<h4 id="redis的内存管理"><a href="#redis的内存管理" class="headerlink" title="redis的内存管理"></a>redis的内存管理</h4><h5 id="给key设置过期时间"><a href="#给key设置过期时间" class="headerlink" title="给key设置过期时间"></a>给key设置过期时间</h5><p>为什么呢？</p>
<ul>
<li>如果每个键都不设置过期时间，一直保存在内存中，那么如果数据增多，就会报OOM</li>
<li>业务场景需要：例如短信验证码在一分钟之内有用。</li>
</ul>
<h5 id="redis-是如何判断数据过期呢"><a href="#redis-是如何判断数据过期呢" class="headerlink" title="redis 是如何判断数据过期呢"></a>redis 是如何判断数据过期呢</h5><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间，过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间。</p>
<p>过期的数据删除策略了解吗？</p>
<ul>
<li>惰性删除：只会在取出key的时候才对数据进行检查，这样对CPU最友好，但是会造成大量key没有被删除。</li>
<li>定期删除：每隔一段时间抽取一批key执行删除策略操作。为了减少删除操作对CPu的影响，redis在底层限制了删除操作的频率和时长。</li>
</ul>
<p>仅仅设置过期时间还是有问题的，因为在惰性删除或者定期删除后，也会漏掉一些key,这样还是有可能大量的key会堆积在内存中，所以还需要<strong>redis的内存淘汰机制</strong></p>
<h5 id="redis-的内存淘汰机制"><a href="#redis-的内存淘汰机制" class="headerlink" title="redis 的内存淘汰机制"></a>redis 的内存淘汰机制</h5><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
<p>redis 提供8中内存淘汰机制：</p>
<ul>
<li>volatile-lru：在设置了过期时间的key中，淘汰最近最少使用的</li>
<li>volatile-ttl：在设置了过期时间的key中，淘汰将要过期的key</li>
<li>volatile-lfu：在设置了过期时间的key中，淘汰最不经常使用的key</li>
<li>volatile-random：在设置了过期时间的key中，随机选择数据淘汰</li>
<li>allkey-lru：在所有key中，淘汰最近最少使用的</li>
<li>allkey-lfu：在所有key中，淘汰最不经常使用的key</li>
<li>allkey-random：随机选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据</li>
</ul>
<h4 id="redis的持久化机制"><a href="#redis的持久化机制" class="headerlink" title="redis的持久化机制"></a>redis的持久化机制</h4><p><strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong></p>
<h5 id="什么是RDB快照"><a href="#什么是RDB快照" class="headerlink" title="什么是RDB快照"></a>什么是RDB快照</h5><p>redis可以通过创建快照来获取在内存中某个时间点的副本，创建快照后，可以复制给其他服务器（来实现主从），也可以保存在原地以便服务器的重启。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">save <span class="token number">900</span> <span class="token number">1</span>           #在<span class="token number">900</span>秒<span class="token punctuation">(</span><span class="token number">15</span>分钟<span class="token punctuation">)</span>之后，如果至少有<span class="token number">1</span>个key发生变化，<span class="token class-name">Redis</span>就会自动触发bgsave命令创建快照。

save <span class="token number">300</span> <span class="token number">10</span>          #在<span class="token number">300</span>秒<span class="token punctuation">(</span><span class="token number">5</span>分钟<span class="token punctuation">)</span>之后，如果至少有<span class="token number">10</span>个key发生变化，<span class="token class-name">Redis</span>就会自动触发bgsave命令创建快照。

save <span class="token number">60</span> <span class="token number">10000</span>        #在<span class="token number">60</span>秒<span class="token punctuation">(</span><span class="token number">1</span>分钟<span class="token punctuation">)</span>之后，如果至少有<span class="token number">10000</span>个key发生变化，<span class="token class-name">Redis</span>就会自动触发bgsave命令创建快照。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li>通过save保存时是用主线程执行，会阻塞主线程</li>
<li>bgsave：子线程执行，不会阻塞主线程，默认</li>
</ul>
<h5 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h5><p>与RDB快照相比，AOF持久化的实时性更好，默认redis没有开启，需要appendonly yes开启</p>
<p>开启AOF持久化之后，每执行一条命令都会将该命令写入 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件</p>
<p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度</p>
<h6 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h6><p>当执行的命令越来越多的时候。因为AOF是记录命令的，所以就会导致AOF文件会越来越大，那么每次重写就会花费较大开销以及阻塞时间较长，所以这个时候就有了AOF的重写。</p>
<p>AOF重写就是，主线程fork一个子线程，子线程去写一个新的AOF文件来保存当前数据库的状态，体积会比之前小，因为有了一些优化，然后主线程继续接收redis的命令，将该命令写在AOF缓冲区，然后子线程写完之后，再将AOf缓冲区追加到新的AOF文件中。</p>
<h4 id="RDB和AOF的选择"><a href="#RDB和AOF的选择" class="headerlink" title="RDB和AOF的选择"></a>RDB和AOF的选择</h4><p>RDB比AOF好：</p>
<ul>
<li>RDB是存储的是压缩过后的二进制数据，保存着某个时间点的数据集，文件很小。但是AOF因为存储的是每一次的命令，所以文件很大</li>
<li>RDB存储的是数据，所以直接解析还原数据就可以了，而AOF还需要依次执行命令，速度慢，所以在还原大数据的时候RDB速度更快</li>
</ul>
<p>AOF比RDB好：</p>
<ul>
<li>AOF的实时性比RDB好，AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题</li>
</ul>
<h4 id="redis的事务"><a href="#redis的事务" class="headerlink" title="redis的事务"></a>redis的事务</h4><p>redis 的事务不支持原子性，就是在某条命令执行错误不会回滚，：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>还有一点就是redis中事务的每条命令都会和redis服务器进行网络交互，比较浪费资源。所以在日常开发中是不建议使用redis事务</p>
<p>如何解决redis事务中每条命令都与redis进行网络交互？</p>
<p>lua脚本，使用lua脚本，就会使一个脚本中的命令一次性执行，不会每条命令都进行网络交互</p>
<h4 id="避免写入bigkey"><a href="#避免写入bigkey" class="headerlink" title="避免写入bigkey"></a>避免写入bigkey</h4><h4 id="大量key集中过期"><a href="#大量key集中过期" class="headerlink" title="大量key集中过期"></a>大量key集中过期</h4><p>在定时删除过程中，如果大量key在同一时间过期，客户端请求就必须等待定时删除key的线程执行完成，因为这个线程是主线程，所以就会造成客户端响应慢，所以就最好是给key设置随机过期时间</p>
<h4 id="redis-生产问题"><a href="#redis-生产问题" class="headerlink" title="redis 生产问题"></a>redis 生产问题</h4><h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><p>缓存穿透是指大量的key是不合理的，在redis 和数据库中都没有的数据，那么就导致这些请求，直接到了数据库这层，就有可能导致数据宕机。</p>
<p>解决方法：</p>
<ul>
<li>做好参数校验：比如对于数据库的id不能小于0,以及邮箱格式的校验</li>
<li>缓存无效key:如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间,但是如果黑客的key变化很频繁，就会造成大量无效key</li>
<li>布隆过滤器：布隆过滤器就是一个能够判断一个数据是否存在海量数据的数据结构，把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走，</li>
</ul>
<p>​    <strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在<strong>位数组</strong>中把对应下标的值置为 1。</li>
</ol>
<p>​    我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li><p>对给定元素再次进行相同的哈希计算；</p>
</li>
<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
</li>
<li><p>举个简单的例子：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-hash%E8%BF%90%E7%AE%97.png" alt="布隆过滤器hash计算"></p>
<p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p>
<p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数</strong></p>
</li>
</ol>
<h5 id="缓存击穿："><a href="#缓存击穿：" class="headerlink" title="缓存击穿："></a>缓存击穿：</h5><p>​    请求的数据是热点key,该数据存在数据库中，但是不存在缓存中（多是已经过期），比如秒杀缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力</p>
<p>解决：</p>
<ul>
<li>热点数据的过期时间比较长</li>
<li>热点数据提前预热，并且设置合理的过期时间</li>
</ul>
<h5 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h5><p><strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力</strong></p>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效（不太推荐，实用性太差）。</li>
<li>设置二级缓存。</li>
</ol>
<h4 id="！！数据库和缓存双写一致性2-19"><a href="#！！数据库和缓存双写一致性2-19" class="headerlink" title="！！数据库和缓存双写一致性2.19"></a>！！数据库和缓存双写一致性2.19</h4><p><a class="link"   target="_blank" rel="noopener" href="http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/" >http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/<i class="fas fa-external-link-alt"></i></a></p>
<p>为什么需要数据库和缓存写一致性：</p>
<p>​    因为缓存中存储的数据是有数据库里面热点数据以及一些根据数据库数据来计算暂存的数据（登陆的个人信息），所以如果缓存是存储的是数据库里的数据，那么就需要数据库里面的数据和缓存一致，因为我们再更新数据库之后，也必须去更新缓存，不然就会造成数据不一致，导致业务请求出问题。</p>
<p>因为要双写，所以就自然有两种情况：（1）先更新数据库，在更新缓存（2）先更新缓存，再更新数据库</p>
<p>出现的问题：    </p>
<p>（1）就算先不考虑并发，就会有一个事务的问题，如果第一步成功了，第二步不成功，都会导致问题。</p>
<p>（2）如果有并发，就会有写写、请求的并发。</p>
<p>逐一解决：</p>
<p>（1）事务的问题，这里就有两种方法（本质是通过重试补偿进行的）：更新数据库之后+消息队列，更新数据库+binlog（订阅变更日志）当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p>
<p><a target="_blank" rel="noopener" href="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/09/16310431074053.jpg"><img src="https://kaito-blog-1253469779.cos.ap-beijing.myqcloud.com/2021/09/16310431074053.jpg" alt="img"></a></p>
<p>（2）写写请求并发：两个线程都更新，</p>
<ol>
<li>线程 A 更新数据库（X &#x3D; 1）</li>
<li>线程 B 更新数据库（X &#x3D; 2）</li>
<li>线程 B 更新缓存（X &#x3D; 2）</li>
<li>线程 A 更新缓存（X &#x3D; 1）</li>
</ol>
<p> A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」</p>
<p>​    这里就需要给缓存设置分布式锁。</p>
<h5 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h5><p>这种数据库的数据更新后，就去无脑更新缓存，因为有可能该数据不一定会很快被查到，这样反而更新了一些不常访问数据的过期时间，所以不仅缓存利用率不高，而且浪费机器性能，所以就有了每次更新数据库之后都删除缓存，等到需要读取时再去数据库查到然后放入缓存中。</p>
<p>那么这里又会有并发的问题，不管是先更新数据库+删除缓存还是先删除缓存再更新数据库，都会有可能导致数据不一致，但是我们这里选择先更新数据库再删除缓存，关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题</p>
<p>所以我们这里选择<strong>缓存延迟双删策略</strong>，</p>
<p>在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。</p>
<p><strong>解决第二个问题</strong>：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。</p>
<ul>
<li>1：延迟时间要大于「主从复制」的延迟时间</li>
<li>2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间</li>
</ul>
<h3 id="day-13-2-16"><a href="#day-13-2-16" class="headerlink" title="day 13 2.16"></a>day 13 2.16</h3><h4 id="mysql-的复习"><a href="#mysql-的复习" class="headerlink" title="mysql 的复习"></a>mysql 的复习</h4><h5 id="mysql中MVCC"><a href="#mysql中MVCC" class="headerlink" title="mysql中MVCC"></a>mysql中MVCC</h5><p>mysql 的事务隔离级别：</p>
<ul>
<li>读未提交，脏读，不可重复读、以及幻读</li>
<li>读已提交，解决脏读，但是任然有不可重复读和幻读</li>
<li>可重复读RR,解决脏读、可重复读，但是不可避免幻读</li>
<li>串行化：所有事务依次执行</li>
</ul>
<p>虽然大部分数据库系统都是采用的是读已提交，但是innodb采用的是可重复读，不会有太多的性能损失，而且innodb的可重复读能够解决幻读的情况，采用的是MVCC+快照读、行锁和间隙锁+当前读来实现</p>
<p>MVCC的实现是4个隐式字段+readView+undo log,</p>
<ul>
<li>DB_id,如果没有设置主键或者唯一非空索引的，就用该id生成默认索引</li>
<li>回滚指针，</li>
<li>最后一次操作该记录的事务id</li>
</ul>
<p>read View 中的字段</p>
<ul>
<li>所有事务中最小id</li>
<li>活跃事务的list（未提交的）</li>
<li>最大事务id加一</li>
</ul>
<p>整个流程：</p>
<p>…..</p>
<p>RC和RR的不同就在于，RC在每次快照读的时候都会生成一个新的read view,所以就会导致不可重复读；而RR在事务中第一次快照读生成read view 之后就不会再生成了。</p>
<h5 id="三大日志"><a href="#三大日志" class="headerlink" title="三大日志"></a>三大日志</h5><p>1、redo log:</p>
<p>​    为什么有redo log：</p>
<p>​    每次在更新数据时，如果都将整个数据页都刷盘，那么可能修改的数据只有几byte,但是刷盘就是整个页，而且数据页的数据有可能是随机读写的，就会导致性能大大下降，所以在更改数据的时候，先更新redo log buffer,然后根据刷盘的策略刷到redo log中，并更新内存，这个时候更新就算完成了，操作内存比操作磁盘要快的多。同时，InnoDB 会在适当的时候，将 redo log 中的记录更新到磁盘文件中。这个更新往往是系统空闲时做。</p>
<p> redo log 文件组：他有两个指针，write pos和check point,文件满了就会进行处理。</p>
<p>redo log 适合突然宕机时恢复数据，因为在write pos和check point之间就是还没有刷盘的数据，这些数据的更新只在内存，用redo log 就可以恢复这些数据。</p>
<p>2、bin log：</p>
<p>​    bin log 用于数据库主从之间的数据备份同步，bin log 是基于server 层的，bin log的文件格式有statement和row,row主要是为了在主从之间例如时间或者需要根据实际函数计算的数据。</p>
<p>3、两阶段提交：因为redo log是在事务执行时不断写入，而bin log是事务提交时才写入，所以就会出现在写bin log时出现错误，这样就导致了数据库主从数据不一致</p>
<h3 id="day-14-2-19"><a href="#day-14-2-19" class="headerlink" title="day 14 2.19"></a>day 14 2.19</h3><h5 id="一条sql语句执行的过程"><a href="#一条sql语句执行的过程" class="headerlink" title="一条sql语句执行的过程"></a>一条sql语句执行的过程</h5><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" alt="img"></p>
<p>连接器：登陆、权限认证</p>
<p>查询缓存：mysql8之前，会首先查询缓存</p>
<p>分析器：语法分析：分析sql语句的正确性，词法分析：关键字：select、哪张表字段，</p>
<p>优化器：按照mysql认为的最优化的方式去执行，比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序</p>
<p>执行器：首先会校验该用户是否有权限，如果有权限就去调用引擎的接口，然后执行</p>
<p>查询语句就比较简单，就跟着以上步骤就可以，只不过在更新的时候有一点小区别：</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">update tb_student A set A.age='19' where A.name=' 张三 ';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>更新数据也需要以上几个步骤将数据刷到缓冲池中，然后在缓冲池中将age改为19,同时记录redo log，redo log进入prepare,然后告诉执行器，随机可以提交，然后执行器收到通知后记录bin log，记录bin log之后，就调用引擎接口，将数据存入磁盘，然后将redo log设置为commit阶段。（这里有一个两阶段提交，保证redo log和bin log的一致来保证数据库集群的数据一致）</p>
<h5 id="索引失效的几种场景"><a href="#索引失效的几种场景" class="headerlink" title="索引失效的几种场景"></a>索引失效的几种场景</h5><ul>
<li><p>使用select *</p>
</li>
<li><p>创建了组合索引，但是查询条件没有遵守最左匹配原则</p>
</li>
<li><p>在索引列上进行函数计算</p>
</li>
<li><p>发生隐式转换：左边为字符串的时候，右边是数字，就会进行转为浮点数比较，但是字符串转为浮点数的规矩：（1）不以数字开头的字符串都为0,例如：abc、ds12都为0</p>
<p>（2）<strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>&#39;123abc&#39;</code>会转换为<code>123</code>，<code>&#39;012abc&#39;</code>会转换为<code>012</code>也就是<code>12</code>，<code>&#39;5.3a66b78c&#39;</code>会转换为<code>5.3</code>，其他同理</p>
<p>所以就会使索引失效</p>
</li>
</ul>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Autowired-和-Resource"><a href="#Autowired-和-Resource" class="headerlink" title="@Autowired 和@Resource"></a>@Autowired 和@Resource</h4><p>@Autowired是根据bytype,但是如果一个接口有多个实现类，就需要byname,@Resource就是byname,但是@Autowired也可以用@Qualifier来指定是哪一个实现类</p>
<h4 id="Spring-中的bean是线程安全的吗"><a href="#Spring-中的bean是线程安全的吗" class="headerlink" title="Spring 中的bean是线程安全的吗"></a>Spring 中的bean是线程安全的吗</h4><p>Spring 中的bean默认是单例模式的，当然也有prototype即多例模式（每次都新建一个bean），多例模式肯定不会有线程安全的问题，而在默认的单例模式中，因为多个线程共用一个对象，所以如果是无状态的对象，不会有线程安全的问题，如果是有状态的对象，就会出现线程安全的问题，解决线程安全的方法：</p>
<ul>
<li>@Scope(value &#x3D; “prototype”)设置为多例模式</li>
<li>将必须定义的变量封装在threadlocal中</li>
</ul>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>AOP基于代理模式，主要用于与业务没有太大直接联系但是又需要的，应用场景：日志打印、权限管理。</p>
<p>代理模式：对象实现了接口，代理就可以用JDK Proxy代理（基于反射），如果没有实现接口就用CGlib,修改字节码。</p>
<p>反射：通过类来反射生产实例对象，能够知道类的信息包括是否有注解（就可以实现代理模式），应用场景：读取配置文件。</p>
<h4 id="Spring-中涉及的设计模式"><a href="#Spring-中涉及的设计模式" class="headerlink" title="Spring 中涉及的设计模式"></a>Spring 中涉及的设计模式</h4><ul>
<li>工厂模式：spring使用工厂模式通过beanFactory、ApplicationContext创建对象</li>
<li>代理模式：AOP</li>
<li>单例设计模式:spring中的bean默认都是单例的</li>
<li>适配器模式：spring MVC 中也是用到了适配器模式适配<code>Controller</code></li>
<li>观察者模型：Spring 事件驱动就是观察者</li>
<li>装饰者模式：inputStream和fileInputStream</li>
</ul>
<h4 id="spring事务"><a href="#spring事务" class="headerlink" title="spring事务"></a>spring事务</h4><p>spring的事务传播行为：</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<h5 id="事务原理："><a href="#事务原理：" class="headerlink" title="事务原理："></a>事务原理：</h5><p>​    <code>       @Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。Spring 容器就会在启动的时候为其创建一个代理类，在调用被<code>@Transactional</code> 注解的 public 方法的时候，实际调用的是，<code>TransactionInterceptor</code> 类中的 <code>invoke()</code>方法。这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务</p>
<p>​    若同一类中的其他没有 <code>@Transactional</code> 注解的方法内部调用有 <code>@Transactional</code> 注解的方法，有<code>@Transactional</code> 注解的方法的事务会失效。</p>
<p>​    这是由于<code>Spring AOP</code>代理的原因造成的，因为只有当 <code>@Transactional</code> 注解的方法在类以外被调用的时候，Spring 事务管理才生效。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h4 id="消息队列有什么用"><a href="#消息队列有什么用" class="headerlink" title="消息队列有什么用"></a>消息队列有什么用</h4><p>1.通过异步处理提高性能（减少响应所需时间）：</p>
<p><strong>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合</strong>，比如用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功，以免交易纠纷。这就类似我们平时手机订火车票和电影票</p>
<p>2.削峰&#x2F;限流</p>
<p><strong>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉</strong></p>
<p>3.降低系统耦合</p>
<p>使用消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，</p>
<h4 id="消息队列带来的维护"><a href="#消息队列带来的维护" class="headerlink" title="消息队列带来的维护"></a>消息队列带来的维护</h4><p>需要考虑消息丢失、消息重复消费、消息未正确消费、以及mq宕机等问题</p>
<h4 id="JMS和AMQP"><a href="#JMS和AMQP" class="headerlink" title="JMS和AMQP"></a>JMS和AMQP</h4><p>JMS是java的<strong>API 是一个消息服务的标准或者说是规范</strong>，仅支持两种消息类型：点对点和发布订阅模型（广播）</p>
<p>AMQP一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>，提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub&#x2F;sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</p>
<h3 id="day-15-2-20"><a href="#day-15-2-20" class="headerlink" title="day 15 2.20"></a>day 15 2.20</h3><h3 id="Rabbitmq"><a href="#Rabbitmq" class="headerlink" title="Rabbitmq"></a>Rabbitmq</h3><h4 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h4><p>当消息在一个队列中变成死信 (<code>dead message</code>) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列，</p>
<p>死信的几种原因：</p>
<ul>
<li>消息被消费者拒绝，basic.reject</li>
<li>消息过期时间到</li>
<li>队列满</li>
</ul>
<p>死信队列应用场景：</p>
<ul>
<li>消息异常处理</li>
<li>延迟队列</li>
</ul>
<h4 id="rabbit-消息怎么传输"><a href="#rabbit-消息怎么传输" class="headerlink" title="rabbit 消息怎么传输"></a>rabbit 消息怎么传输</h4><p>因为tcp连接的创建和销毁开销都挺大，且并发数受系统资源限制，会造成性能瓶颈。所以 RabbitMQ 使用信道的方式来传输数据。每个tcp连接中建立成千上万个信道，这个 TCP 被多个线程共享</p>
<h4 id="rabbitmq的工作模式"><a href="#rabbitmq的工作模式" class="headerlink" title="rabbitmq的工作模式"></a>rabbitmq的工作模式</h4><ul>
<li>简单模式：一对一</li>
<li>work模式：一对多，一个消息只能被一个消费者消费</li>
<li>发布订阅模式：交换机发布订阅把消息发送到所有消息队列中,对应消息队列的消费者拿到消息进行消费</li>
<li>路由模式：交换机根据路由键，将消息传输给队列</li>
<li>topic主题模式：其实就是路由模式的模糊匹配</li>
</ul>
<h4 id="rabbitmq消息可靠性"><a href="#rabbitmq消息可靠性" class="headerlink" title="rabbitmq消息可靠性"></a>rabbitmq消息可靠性</h4><ul>
<li>生产者到mq服务器（broker）：可以使用事务或者Confirm机制，mq服务器收到消息会向生产者发送ack应答消息，如果在一段时间内没有收到ack或者说收到了nack（mq服务器不能够处理该消息），那么就可以在生产者重发</li>
<li>mq自身存储的时候：如果消息在存储在mq服务器的时候，mq服务器宕机，就会导致在mq内存中的消息丢失，所以这里我们需要设置队列和消息是持久化的，这样就可以在mq服务器重启的时候进行数据的恢复；还有就是可以通过镜像队列实现集群，避免单点故障</li>
<li>消费端未能成功消费：当消息到达消费者之后，如果消费者的进程挂了，导致消息未能成功消费，所以这里需要设置消费端成功消费之后的应答，让mq服务器知道消费无异常，mq自动的消费端的ack是只要消息到达消费者就ack,这样就有问题。所以我们需要关闭消费端的自动应答，在我们的消费之后的代码中手动应答</li>
</ul>
<h4 id="rabbit-的高可用"><a href="#rabbit-的高可用" class="headerlink" title="rabbit 的高可用"></a>rabbit 的高可用</h4><ul>
<li>普通集群模式：在多台机器中创建多个rabbitmq实例，但是创建的queue只存在某一个实例中，其他实例存储这该queue的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例），然后每次都需要去该queue的真实实例中去拉取消息，就会有单点故障</li>
<li>镜像集群：就是每个实例都有queue的所有数据，不会有单点故障，但是在所有机器上的消息同步，网络开销太大</li>
</ul>
<h4 id="rabbit-mq-的消息挤压问题"><a href="#rabbit-mq-的消息挤压问题" class="headerlink" title="rabbit mq 的消息挤压问题"></a>rabbit mq 的消息挤压问题</h4><p>​    出现消息挤压的问题多是消费端消费出现问题，<strong>一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行。</strong> <strong>消费端的性能优化除了优化消费业务逻辑以外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能</strong>。</p>
<p>消息挤压出现后解决方法：</p>
<ul>
<li>服务降级，关闭一些非核心业务，减少消息生产。</li>
<li>临时扩容，先修复消费者的问题，然后再停掉当前所有消费者，新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息</li>
</ul>
<h3 id="day-16-2-21"><a href="#day-16-2-21" class="headerlink" title="day 16 2.21"></a>day 16 2.21</h3><h3 id="手写一个RPC（javaGuide）解析"><a href="#手写一个RPC（javaGuide）解析" class="headerlink" title="手写一个RPC（javaGuide）解析"></a>手写一个RPC（javaGuide）解析</h3><p>梳理一下整个使用的整个流程：</p>
<ul>
<li><p>首先服务器端启动，在服务器端将有RpcService注解的服务注册到zookeeper。</p>
</li>
<li><p>然后客户端想要调用远程服务，就需要将本地服务标记为远程服务，怎么标记呢，就是通过注解来生成代理对象，</p>
</li>
<li><pre><code class="java">@RpcReference(version = &quot;version1&quot;, group = &quot;test1&quot;)
private HelloService helloService;
<pre class="line-numbers language-none"><code class="language-none">
- 然后本地调用该服务时，就会去发起远程调用

- &#96;&#96;&#96;java
  String hello &#x3D; this.helloService.hello(new Hello(&quot;111&quot;, &quot;222&quot;));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>服务器收到远程调用，调用方法，返回结果给客户端</p>
</li>
<li><p>客户端收到结果</p>
</li>
</ul>
<p>下面根据流程顺序来解析：服务端向zookeeper注册服务、客户端本地发起远程调用、服务端收到远程调用发起调用并返回结果给、客户端收到数据</p>
<h4 id="服务端向zookeeper注册服务"><a href="#服务端向zookeeper注册服务" class="headerlink" title="服务端向zookeeper注册服务"></a>服务端向zookeeper注册服务</h4><p>​    首先我们知道zookeeper是可以进行服务注册和服务调用，简单的理解就是被远程调用的服务注册到上面，然后远程调用方就可以在上面去找到，然后并调用。然后我们这里使用的是Curators来操控zookeeper创建、删除、获取节点数据的。</p>
<p>​    创建节点：在CuratorsUtils中的createPersistentNode是创建节点</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createPersistentNode</span><span class="token punctuation">(</span><span class="token class-name">CuratorFramework</span> zkClient<span class="token punctuation">,</span> <span class="token class-name">String</span> path<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>​    里面最核心的就是下面这一行代码，负责创建节点</p>
<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;eg: &#x2F;my-rpc&#x2F;github.javaguide.HelloService&#x2F;127.0.0.1:9999
zkClient.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(path);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p> 在zookeeper中注册服务方法的代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZkServiceRegistryImpl</span> <span class="token keyword">implements</span> <span class="token class-name">ServiceRegistry</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">registerService</span><span class="token punctuation">(</span><span class="token class-name">String</span> rpcServiceName<span class="token punctuation">,</span> <span class="token class-name">InetSocketAddress</span> inetSocketAddress<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> servicePath <span class="token operator">=</span> <span class="token class-name">CuratorUtils</span><span class="token punctuation">.</span>ZK_REGISTER_ROOT_PATH <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> rpcServiceName <span class="token operator">+</span> inetSocketAddress<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CuratorFramework</span> zkClient <span class="token operator">=</span> <span class="token class-name">CuratorUtils</span><span class="token punctuation">.</span><span class="token function">getZkClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CuratorUtils</span><span class="token punctuation">.</span><span class="token function">createPersistentNode</span><span class="token punctuation">(</span>zkClient<span class="token punctuation">,</span> servicePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> 在服务器端调用该方法的位置：在服务端的ZKServiceProvider中有一个publish方法，来发布服务</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publishService</span><span class="token punctuation">(</span><span class="token class-name">RpcServiceConfig</span> rpcServiceConfig<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> host <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addService</span><span class="token punctuation">(</span>rpcServiceConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//发布服务，即创建节点</span>
        serviceRegistry<span class="token punctuation">.</span><span class="token function">registerService</span><span class="token punctuation">(</span>rpcServiceConfig<span class="token punctuation">.</span><span class="token function">getRpcServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> <span class="token class-name">NettyRpcServer</span><span class="token punctuation">.</span>PORT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnknownHostException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"occur exception when getHostAddress"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后在标记了@RpcService的方法，都将其方法发布在zookeeper中，那么这里就有一个自定义注解的使用</p>
<h5 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h5><p><strong>步骤一</strong>：首先先写一个注解：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Inherited</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">RpcService</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">/**
     * Service version, default value is empty string
     */</span>
    <span class="token class-name">String</span> <span class="token function">version</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * Service group, default value is empty string
     */</span>
    <span class="token class-name">String</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>步骤二</strong>：因为需要把自定义的注解在应用启动时就被扫描，然后将其标记了@rpcService的bean动态注入到容器中，所以这里就需要动态注入：</p>
<p>ImportBeanDefinitionRegistrar接口是也是spring的扩展点之一,它可以支持我们自己写的代码封装成<code>BeanDefinition</code>对象;实现此接口的类会回调<code>postProcessBeanDefinitionRegistry</code>方法.</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomScannerRegistrar</span> <span class="token keyword">implements</span> <span class="token class-name">ImportBeanDefinitionRegistrar</span><span class="token punctuation">,</span> <span class="token class-name">ResourceLoaderAware</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>步骤三：</strong>bean注入完毕之后，在实例化的时候，在实例化之前就可以通过实现BeanPostProcessor接口，BeanPostProcessor给了我们一个机会对Spring管理的bean进行再加工。比如：我们可以修改bean的属性，可以给bean生成一个动态代理实例等等，</p>
<p>所以我们在bean实例化之前，我们将加有@RPCservice注解的服务，调用zookeeperService将服务注册到zookeeper中</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessBeforeInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isAnnotationPresent</span><span class="token punctuation">(</span><span class="token class-name">RpcService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"[&#123;&#125;] is annotated with  [&#123;&#125;]"</span><span class="token punctuation">,</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">RpcService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// get RpcService annotation</span>
            <span class="token class-name">RpcService</span> rpcService <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">RpcService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// build RpcServiceProperties</span>
            <span class="token class-name">RpcServiceConfig</span> rpcServiceConfig <span class="token operator">=</span> <span class="token class-name">RpcServiceConfig</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>rpcService<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span>rpcService<span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">service</span><span class="token punctuation">(</span>bean<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            serviceProvider<span class="token punctuation">.</span><span class="token function">publishService</span><span class="token punctuation">(</span>rpcServiceConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在实例化之后我们将加有@rpcreference注解的bean生成一个代理对象返回给客户端，该代理对象帮我们去发送和接收消息</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">postProcessAfterInitialization</span><span class="token punctuation">(</span><span class="token class-name">Object</span> bean<span class="token punctuation">,</span> <span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> targetClass <span class="token operator">=</span> bean<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Field</span><span class="token punctuation">[</span><span class="token punctuation">]</span> declaredFields <span class="token operator">=</span> targetClass<span class="token punctuation">.</span><span class="token function">getDeclaredFields</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Field</span> declaredField <span class="token operator">:</span> declaredFields<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">RpcReference</span> rpcReference <span class="token operator">=</span> declaredField<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span><span class="token class-name">RpcReference</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rpcReference <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">RpcServiceConfig</span> rpcServiceConfig <span class="token operator">=</span> <span class="token class-name">RpcServiceConfig</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>rpcReference<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span>rpcReference<span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">RpcClientProxy</span> rpcClientProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcClientProxy</span><span class="token punctuation">(</span>rpcClient<span class="token punctuation">,</span> rpcServiceConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Object</span> clientProxy <span class="token operator">=</span> rpcClientProxy<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span>declaredField<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                declaredField<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    declaredField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>bean<span class="token punctuation">,</span> clientProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>

        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> bean<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>这样就服务就注册完毕了，以下是补充。</p>
<p>注意这里的addService,就是在服务器端用一个map来存储了service,当客户端远程调用的消息过来之后，比如过来的是需要调用helloService,那么服务端就可以直接在这个map里面getByName获取到该service,然后调用该方法</p>
<h4 id="客户端本地发起远程调用"><a href="#客户端本地发起远程调用" class="headerlink" title="客户端本地发起远程调用"></a>客户端本地发起远程调用</h4><p> 在本地调用远程服务时，需要给服务加上注解@RPCreference来标记这是远程调用服务，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RpcReference</span><span class="token punctuation">(</span>version <span class="token operator">=</span> <span class="token string">"version1"</span><span class="token punctuation">,</span> group <span class="token operator">=</span> <span class="token string">"test1"</span><span class="token punctuation">)</span>
<span class="token keyword">private</span> <span class="token class-name">HelloService</span> helloService<span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>​    因为我们想暴露给使用者就是直接加上注解，然后调用就可以了，所以具体的发起调用的细节，我们需要隐藏，那么我们这里就使用了代理模式，在客户调用方法时，我们生成代理对象，去帮我们通过netty发起远程调用。</p>
<p>​    代理对象帮我们执行的：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"invoked method: [&#123;&#125;]"</span><span class="token punctuation">,</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RpcRequest</span> rpcRequest <span class="token operator">=</span> <span class="token class-name">RpcRequest</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">methodName</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">parameters</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">interfaceName</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getDeclaringClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">paramTypes</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">requestId</span><span class="token punctuation">(</span>UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>rpcServiceConfig<span class="token punctuation">.</span><span class="token function">getGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span>rpcServiceConfig<span class="token punctuation">.</span><span class="token function">getVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RpcResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> rpcResponse <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rpcRequestTransport <span class="token keyword">instanceof</span> <span class="token class-name">NettyRpcClient</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">//发送消息</span>
            <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RpcResponse</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span> completableFuture <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RpcResponse</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">)</span> rpcRequestTransport<span class="token punctuation">.</span><span class="token function">sendRpcRequest</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
            rpcResponse <span class="token operator">=</span> completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rpcRequestTransport <span class="token keyword">instanceof</span> <span class="token class-name">SocketRpcClient</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            rpcResponse <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RpcResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span><span class="token punctuation">)</span> rpcRequestTransport<span class="token punctuation">.</span><span class="token function">sendRpcRequest</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">check</span><span class="token punctuation">(</span>rpcResponse<span class="token punctuation">,</span> rpcRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> rpcResponse<span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接着我们来看rpcRequestTransport.sendRpcRequest(rpcRequest);中：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">sendRpcRequest</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> rpcRequest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// build return value</span>
        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">RpcResponse</span><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span><span class="token punctuation">></span></span> resultFuture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// get server address</span>
        <span class="token class-name">InetSocketAddress</span> inetSocketAddress <span class="token operator">=</span> serviceDiscovery<span class="token punctuation">.</span><span class="token function">lookupService</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// get  server address related channel</span>
        <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">getChannel</span><span class="token punctuation">(</span>inetSocketAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>channel<span class="token punctuation">.</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// put unprocessed request</span>
            unprocessedRequests<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">.</span><span class="token function">getRequestId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> resultFuture<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">RpcMessage</span> rpcMessage <span class="token operator">=</span> <span class="token class-name">RpcMessage</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">codec</span><span class="token punctuation">(</span><span class="token class-name">SerializationTypeEnum</span><span class="token punctuation">.</span>HESSIAN<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">compress</span><span class="token punctuation">(</span><span class="token class-name">CompressTypeEnum</span><span class="token punctuation">.</span>GZIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">messageType</span><span class="token punctuation">(</span><span class="token class-name">RpcConstants</span><span class="token punctuation">.</span>REQUEST_TYPE<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            channel<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>rpcMessage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ChannelFutureListener</span><span class="token punctuation">)</span> future <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"client send message: [&#123;&#125;]"</span><span class="token punctuation">,</span> rpcMessage<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    resultFuture<span class="token punctuation">.</span><span class="token function">completeExceptionally</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Send failed:"</span><span class="token punctuation">,</span> future<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">return</span> resultFuture<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先去zookeeper中找到服务的地址，然后发送信息，</p>
<p>然后我们再来看看client的配置：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// initialize resources such as EventLoopGroup, Bootstrap</span>
       eventLoopGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       bootstrap<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>eventLoopGroup<span class="token punctuation">)</span>
               <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
               <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">)</span>
               <span class="token comment">//  The timeout period of the connection.</span>
               <span class="token comment">//  If this time is exceeded or the connection cannot be established, the connection fails.</span>
               <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>CONNECT_TIMEOUT_MILLIS<span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span>
               <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                   <span class="token annotation punctuation">@Override</span>
                   <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                       <span class="token class-name">ChannelPipeline</span> p <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       <span class="token comment">// If no data is sent to the server within 15 seconds, a heartbeat request is sent</span>
                       p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IdleStateHandler</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RpcMessageEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RpcMessageDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                       p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NettyRpcClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                   <span class="token punctuation">&#125;</span>
               <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>IdleStateHandler就是发送心跳包，避免因为底层的tcp连接网络设备断开，但是上层感知不到，所以就需要发送心跳包来避免这个问题。出发事件后的发送心跳包：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">userEventTriggered</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> evt<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>evt <span class="token keyword">instanceof</span> <span class="token class-name">IdleStateEvent</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">IdleState</span> state <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">IdleStateEvent</span><span class="token punctuation">)</span> evt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>state <span class="token operator">==</span> <span class="token class-name">IdleState</span><span class="token punctuation">.</span>WRITER_IDLE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"write idle happen [&#123;&#125;]"</span><span class="token punctuation">,</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">Channel</span> channel <span class="token operator">=</span> nettyRpcClient<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">RpcMessage</span> rpcMessage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                rpcMessage<span class="token punctuation">.</span><span class="token function">setCodec</span><span class="token punctuation">(</span><span class="token class-name">SerializationTypeEnum</span><span class="token punctuation">.</span>PROTOSTUFF<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                rpcMessage<span class="token punctuation">.</span><span class="token function">setCompress</span><span class="token punctuation">(</span><span class="token class-name">CompressTypeEnum</span><span class="token punctuation">.</span>GZIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                rpcMessage<span class="token punctuation">.</span><span class="token function">setMessageType</span><span class="token punctuation">(</span><span class="token class-name">RpcConstants</span><span class="token punctuation">.</span>HEARTBEAT_REQUEST_TYPE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rpcMessage<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">RpcConstants</span><span class="token punctuation">.</span>PING<span class="token punctuation">)</span><span class="token punctuation">;</span>
                channel<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>rpcMessage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token class-name">ChannelFutureListener</span><span class="token punctuation">.</span>CLOSE_ON_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">userEventTriggered</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> evt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>RpcMessageEncoder：是对发送消息的编码：</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/encode.png"></p>
<p>先序列化之后再写body长度，编码器是为了解决粘包问题，这里的序列化方式，是通过读Dubbo 的SPI机制，将有可能的文件放在META-INF&#x2F;extensions下，然后通过ExtensionLoader去读取加载对应的序列化方式。</p>
<p>序列化方式：我们不采用jdk的是因为有漏洞而且效率不高，所以我们选择了kryo,其变长存储，通过算法，有更小的字节码体积</p>
<p>我们在发送消息完之后会等到服务器端处理完毕后返回数据，所以我们发送完消息之后这里返回的是一个completableFuture，通过他在handler和主线程之间异步等待数据的返回，具体怎么实现的：</p>
<ul>
<li>主线程调用sendMsg,然后进入到sendMsg,里面在未处理的request的map集合（requestid-&gt;completableFuture）中加入该request，然后发送信息，然后当结果过来了，就在handler中，在未处理的request集合中删除该request，然后并且将该completableFuture中赋值，这样主线程就可以拿到数据，异步等待</li>
</ul>
<h4 id="服务端收到远程调用发起调用并返回结果给"><a href="#服务端收到远程调用发起调用并返回结果给" class="headerlink" title="服务端收到远程调用发起调用并返回结果给"></a>服务端收到远程调用发起调用并返回结果给</h4><p>服务端的sever配置：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SneakyThrows</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">CustomShutdownHook</span><span class="token punctuation">.</span><span class="token function">getCustomShutdownHook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">clearAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> host <span class="token operator">=</span> <span class="token class-name">InetAddress</span><span class="token punctuation">.</span><span class="token function">getLocalHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHostAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">EventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">EventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">DefaultEventExecutorGroup</span> serviceHandlerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultEventExecutorGroup</span><span class="token punctuation">(</span>
            <span class="token class-name">RuntimeUtil</span><span class="token punctuation">.</span><span class="token function">cpus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span>
            <span class="token class-name">ThreadPoolFactoryUtil</span><span class="token punctuation">.</span><span class="token function">createThreadFactory</span><span class="token punctuation">(</span><span class="token string">"service-handler-group"</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
                <span class="token comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span>
                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>TCP_NODELAY<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
                <span class="token comment">// 是否开启 TCP 底层心跳机制</span>
                <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
                <span class="token comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span>
                <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">LoggingHandler</span><span class="token punctuation">(</span><span class="token class-name">LogLevel</span><span class="token punctuation">.</span>INFO<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token comment">// 当客户端第一次进行请求的时候才会进行初始化</span>
                <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token annotation punctuation">@Override</span>
                    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token comment">// 30 秒之内没有收到客户端请求的话就关闭连接</span>
                        <span class="token class-name">ChannelPipeline</span> p <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">IdleStateHandler</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RpcMessageEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RpcMessageDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                        p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>serviceHandlerGroup<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">NettyRpcServerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 绑定端口，同步等待绑定成功</span>
        <span class="token class-name">ChannelFuture</span> f <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> PORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 等待服务端监听端口关闭</span>
        f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"occur exception when start server:"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"shutdown bossGroup and workerGroup"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        serviceHandlerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>服务端的handler：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token keyword">instanceof</span> <span class="token class-name">RpcMessage</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"server receive msg: [&#123;&#125;] "</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span> messageType <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RpcMessage</span><span class="token punctuation">)</span> msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMessageType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">RpcMessage</span> rpcMessage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RpcMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            rpcMessage<span class="token punctuation">.</span><span class="token function">setCodec</span><span class="token punctuation">(</span><span class="token class-name">SerializationTypeEnum</span><span class="token punctuation">.</span>HESSIAN<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            rpcMessage<span class="token punctuation">.</span><span class="token function">setCompress</span><span class="token punctuation">(</span><span class="token class-name">CompressTypeEnum</span><span class="token punctuation">.</span>GZIP<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>messageType <span class="token operator">==</span> <span class="token class-name">RpcConstants</span><span class="token punctuation">.</span>HEARTBEAT_REQUEST_TYPE<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                rpcMessage<span class="token punctuation">.</span><span class="token function">setMessageType</span><span class="token punctuation">(</span><span class="token class-name">RpcConstants</span><span class="token punctuation">.</span>HEARTBEAT_RESPONSE_TYPE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                rpcMessage<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token class-name">RpcConstants</span><span class="token punctuation">.</span>PONG<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">RpcRequest</span> rpcRequest <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RpcRequest</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">RpcMessage</span><span class="token punctuation">)</span> msg<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// Execute the target method (the method the client needs to execute) and return the method result</span>
                <span class="token class-name">Object</span> result <span class="token operator">=</span> rpcRequestHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>
                log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"server get result: %s"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                rpcMessage<span class="token punctuation">.</span><span class="token function">setMessageType</span><span class="token punctuation">(</span><span class="token class-name">RpcConstants</span><span class="token punctuation">.</span>RESPONSE_TYPE<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">RpcResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> rpcResponse <span class="token operator">=</span> <span class="token class-name">RpcResponse</span><span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> rpcRequest<span class="token punctuation">.</span><span class="token function">getRequestId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    rpcMessage<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>rpcResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">RpcResponse</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">></span></span> rpcResponse <span class="token operator">=</span> <span class="token class-name">RpcResponse</span><span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token class-name">RpcResponseCodeEnum</span><span class="token punctuation">.</span>FAIL<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    rpcMessage<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>rpcResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"not writable now, message dropped"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>rpcMessage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token class-name">ChannelFutureListener</span><span class="token punctuation">.</span>CLOSE_ON_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">//Ensure that ByteBuf is released, otherwise there may be memory leaks</span>
        <span class="token class-name">ReferenceCountUtil</span><span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>跳到Object result &#x3D; rpcRequestHandler.handle(rpcRequest);里面看看</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> rpcRequest<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Object</span> service <span class="token operator">=</span> serviceProvider<span class="token punctuation">.</span><span class="token function">getService</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">.</span><span class="token function">getRpcServiceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">invokeTargetMethod</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">,</span> service<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">/**
 * get method execution results
 *
 * @param rpcRequest client request
 * @param service    service object
 * @return the result of the target method execution
 */</span>
<span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">invokeTargetMethod</span><span class="token punctuation">(</span><span class="token class-name">RpcRequest</span> rpcRequest<span class="token punctuation">,</span> <span class="token class-name">Object</span> service<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">Object</span> result<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">Method</span> method <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span>rpcRequest<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rpcRequest<span class="token punctuation">.</span><span class="token function">getParamTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> rpcRequest<span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"service:[&#123;&#125;] successful invoke method:[&#123;&#125;]"</span><span class="token punctuation">,</span> rpcRequest<span class="token punctuation">.</span><span class="token function">getInterfaceName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rpcRequest<span class="token punctuation">.</span><span class="token function">getMethodName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> <span class="token operator">|</span> <span class="token class-name">IllegalArgumentException</span> <span class="token operator">|</span> <span class="token class-name">InvocationTargetException</span> <span class="token operator">|</span> <span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RpcException</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>解析：就是服务器收到消息之后，拿到servicename就去之前的注册的map中拿到service,然后执行方法，最后返回给客户端。客户端怎么接收数据，前面已经说了，就是通过complateFuture+未处理的request的map来实现异步等待</p>
<h3 id="day-17-2-22"><a href="#day-17-2-22" class="headerlink" title="day 17 2.22"></a>day 17 2.22</h3><h4 id="bean-的生命周期："><a href="#bean-的生命周期：" class="headerlink" title="bean 的生命周期："></a>bean 的生命周期：</h4><ul>
<li>实例化：beanFactory实例是在使用时实例化，而applicationContext则是启动就实例化</li>
<li>属性赋值：若bean实现了aware接口，则会注入依赖，spring提供的依赖：注入当前bean的name以及classloader</li>
<li>初始化：BeanPostProcessor，可以在bean初始化实现前置和后置功能，包括AOP返回代理对象，</li>
<li>销毁</li>
</ul>
<p>三级缓存解决循环依赖：</p>
<p>两个对象相互依赖，在注入进容器时就会出现循环问题。</p>
<p>因为根据bean的生命周期，我们就可以在beanA实例化后，还未属性赋值和初始化，这个时候就将半成品的bean放入缓存中，然后依赖的对象B在实例化、属性赋值的时候，就可以拿到A的引用，然后就可以顺利初始化，接着A开始初始化，这就解决了循环依赖，但是我们知道在spring 中有很多对象都是需要动态代理的，而动态代理又是必须在初始化之后的，所以如果只有二级缓存，那么B拿到的引用就是原始bean（如果这里有代理，就会出现问题）,所以我们这里放一个三级缓存，三级缓存存的是代理对象的工厂，里面调用的是getEarlyBeanReference，就可以拿到可能代理了的对象的引用，这样就解决了代理的问题</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023647227" >https://segmentfault.com/a/1190000023647227<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="day-18-2-23"><a href="#day-18-2-23" class="headerlink" title="day 18 2.23"></a>day 18 2.23</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>为什么要用联合索引：</p>
<ul>
<li>每新建一个索引，都会增加数据库的开销和磁盘开销，所以如果一个联合索引能够实现的事情为什么不用呢</li>
<li>联合索引也就促使覆盖索引的出现，因为有了联合索引，所以在查询字段覆盖了索引，那么就可以直接获取数据，而不需要去回表产生IO开销</li>
<li>索引列越多，能够过滤的数据就越多，回表时比对时的数据就越少</li>
</ul>
<p>使用有什么需要注意的：</p>
<ul>
<li>索引列不要参与计算，对于模糊匹配等阻断索引排序的尽量放在后面；</li>
<li>索引尽量建立在选择性高的字段，例如唯一辨识度的</li>
<li>索引数量尽量少，尽量扩展为联合索引，但是不超过4个字段</li>
<li>合适使用索引列顺序</li>
<li>不要创建和包含关系的索引</li>
</ul>
<p>最左匹配原则</p>
<p>如何建立索引：索引建立好，优化器会优化sql的执行顺序</p>
<p>索引下堆：在支持ICP优化后，MySQL会在取出索引的同时，<strong>判断是否可以进行where条件过滤再进行索引查询</strong>，也就是说提前执行where的部分过滤操作，在某些场景下，可以大大减少回表次数，从而提升整体性能。</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/401198674" >https://zhuanlan.zhihu.com/p/401198674<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>类加载器有四种：</p>
<ul>
<li>启动类加载器：bootstrap classloader，主要加载java核心库：JRE——home&#x2F;lib下面的</li>
<li>扩展类加载器：extention classloader，加载JRE_Home&#x2F;lib&#x2F;ext下面的</li>
<li>应用程序类加载器：application  classloader，加载当前应用的classpath下的</li>
<li>用户自定义类加载器：user classloader，加载指定路径的class</li>
</ul>
<p>双亲委派机制的好处：可以避免类的重复加载，也保证了安全性，核心库的API得到保护</p>
<p>但是有些时候需要破坏双亲委派机制：比如tomcat,因为每个web应用可能依赖同一个第三方库的不同版本，且路径名一样，这样的话不破坏双亲委派机制，在jvm中就是同一个类，那么就会出错，所以需要打破。每一个应用自己的类加载器——WebAppClassLoader负责加载本身的目录下的class文件</p>
<h3 id="day-19-2-24"><a href="#day-19-2-24" class="headerlink" title="day 19 2.24"></a>day 19 2.24</h3><h4 id="索引优化："><a href="#索引优化：" class="headerlink" title="索引优化："></a>索引优化：</h4><ul>
<li>覆盖索引，这样就可以在二级索引直接查找到数据，可以减少回表</li>
<li>前缀索引：减少索引大小，一个索引页就能存储更多索引</li>
<li>主键索引自增：因为设置为自增，一方面是在数据库存储的时候，直接顺序读写，避免使用非自增主键导致的页分裂的情况以及内存碎片和索引结构不紧凑的原因</li>
</ul>
<h4 id="索引失效："><a href="#索引失效：" class="headerlink" title="索引失效："></a>索引失效：</h4><ul>
<li>索引实现左或者左右模糊匹配，因为索引根据前缀匹配</li>
<li>对索引使用函数</li>
<li>对索引使用表达式计算</li>
<li>对索引隐式类型转换：字符串转为数字，如果数据库中是字符串，但是sql语句中是整形，就会索引失效；但是如果数据库是数字，sql中是字符串，就不会</li>
<li>最左匹配</li>
<li>or</li>
<li>优化器选择，数据量占总表的百分比过大导致索引失效</li>
<li>分区</li>
</ul>
<h2 id="day-20-2-26"><a href="#day-20-2-26" class="headerlink" title="day 20 2.26"></a>day 20 2.26</h2><h4 id="redis-中的list链表"><a href="#redis-中的list链表" class="headerlink" title="redis 中的list链表"></a>redis 中的list链表</h4><p>结构中有头指针、尾指针、和len</p>
<p>链表分配内存的不是连续的，他只是通过指针来实现逻辑上的有序，他的优点是在查询节点数量时候的是O（1），在新增和删除效率比较高，而且链表可以存储各种类型</p>
<p>缺点：</p>
<p>（1）因为内存不连续，所以无法很好CPU缓存，因为CPU缓存的结构是数组；</p>
<p>（2）内存消耗大，每个节点都需要链表节点结构头的分配</p>
<p>所以就有了压缩列表。list在数据量小的时候采用压缩列表，在后来就改为了quicklist</p>
<h4 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h4><p>内存紧凑型结构，占用连续的内存空间，每个节点都存储了前一个节点的len,</p>
<p>缺点：虽然节省了内存，但是在插入数据时，有可能会发生prelen的变化，如果在数据量较大的情况下，会有连锁更新的问题</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>哈希表底层就是数组，通过key进行hash函数计算，然后对哈希桶总数进行取摸运算，然后放到对应的哈希桶中，会产生哈希冲突，解决哈希冲突：链式哈希，但是链式哈希会有问题，当某一个哈希桶的链表数据过多，在该链表中查找会O（n），所以就有了rehash,对哈希表进行扩展，在对哈希表进行拷贝时，如果数据过多会造成阻塞，所以有了渐进式哈希，rehash触发条件：负载因子&gt;1</p>
<h4 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h4><p>当一个 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现。</p>
<p>整数升级：再需要升级的时候再升级，节省了内存空间</p>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><p> Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p><strong>跳表是在链表基础上改进过来的，实现了一种「多层」的有序链表</strong></p>
<h4 id="跳表与hash与平衡树比较："><a href="#跳表与hash与平衡树比较：" class="headerlink" title="跳表与hash与平衡树比较："></a>跳表与hash与平衡树比较：</h4><p>hash 适合查询单个key,在较低的哈希冲突率下时间复杂度为O（1），而跳表和平衡树都是O（logn）。</p>
<p>跳表和平衡树适合范围查询，跳表内存占用更灵活平衡树每个节点2个指针，而跳表平均包含1.33,更有优势</p>
<p>在查询范围时，平衡树找到指定的最小值之后，还需要中序遍历找到不超过最大值的节点，而跳表找到    小值之后直接遍历第一层即可</p>
<p>跳表比平衡树实现更简单，平衡树有可能会涉及子树的调整，而跳表直接修改相邻节点的指针</p>
<h4 id="为什么mysql使用B-树、redis使用跳表"><a href="#为什么mysql使用B-树、redis使用跳表" class="headerlink" title="为什么mysql使用B+树、redis使用跳表"></a>为什么mysql使用B+树、redis使用跳表</h4><p>都是范围查询，都是时间复杂度为O（logn）</p>
<p>mysql使用B+树是因为他的高度层数平衡，所以存满2kw数据才需要3次磁盘IO,而跳表的层数是通过新建节点时根据随机函数来的，所以同样的2kw数据需要大概2的24次方</p>
<p>redis因为基于内存，所以不需要io,再加上查找范围时，不需要中序遍历，以及实现简单</p>
<h4 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h4><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p>
<h4 id="listpack"><a href="#listpack" class="headerlink" title="listpack"></a>listpack</h4><p>listpack，目的是替代压缩列表,它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p>
<h2 id="day-21-3-1"><a href="#day-21-3-1" class="headerlink" title="day 21 3.1"></a>day 21 3.1</h2><p>复习了arrarylist扩容以及hashmap以及concurrentmap（为什么1.7用reentranlock，1.8用synchrnized（轻量级粒度）</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/wojiao228925661/article/details/98520706" >https://blog.csdn.net/wojiao228925661/article/details/98520706<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁，只能降级不能升级。</p>
<p>为什么不能升级：假设升级，如果线程ABC,都先获取读锁，然后这个时候A想要升级获取写锁，就需要等待BC释放读锁，因为读写锁不能同时被持有，那么等待BC释放读锁就可以了，但是如过在A想要升级获取写锁的时候，这个时候B也想要写锁，那么B也要等带A释放读锁，就形成了死锁。</p>
<p>那为什么可以降级呢：因为先申请写锁的时候，就保证了其他线程没有锁，那么申请读锁的时候就不会造成死锁</p>
<h2 id="day-22-3-2"><a href="#day-22-3-2" class="headerlink" title="day 22 3.2"></a>day 22 3.2</h2><h3 id="谈谈Spring-IOC和AOP"><a href="#谈谈Spring-IOC和AOP" class="headerlink" title="谈谈Spring IOC和AOP"></a>谈谈Spring IOC和AOP</h3><p>IOC是什么，为什么需要IOC,怎么实现的</p>
<p>IOC就是控制反转，就是指的在对对象的创建和管理交给不使用资源的容器spring,那么为什么要这样做呢，因为我们自己去每使用一个对象就new的话，就有两个问题，第一就是每次使用都创建对象会造成创建很多对象，那么就会导致资源浪费，第二个就是代码耦合度高，维护难度大，那么IOC是怎么解决这两个问题的呢，就是通过依赖注入，需要该对象就依赖注入到该方法，这样的话，因为容器里面的对象默认是单例的，所以就解决了资源浪费，因为对象由容器管理，所以如果需要修改对象那么就直接在容器里面修改，就不用在每个使用到的的地方修改。</p>
<p>AOP就是为了那些非核心业务代码而实现的，比如一些日志、安全性能监控，都需要在方法前进行前置或者后置处理，</p>
<h3 id="谈谈redis-持久化的RDB和AOF"><a href="#谈谈redis-持久化的RDB和AOF" class="headerlink" title="谈谈redis 持久化的RDB和AOF"></a>谈谈redis 持久化的RDB和AOF</h3><p>RDB是每隔一段时间生成数据库的快照，便于在主从服务器之间的复制，通过save命令是主线程执行，而bgsave是子4线程去生成，所以就有一个缺点就是在子线程去保存rdb文件的时候，这个时候主线程修改的操作就会留到下一次，那么实时性就不好（优点在于因为是二进制数据，体积小，而且恢复起来速度快）。而AOF是记录操作redis的命令，每执行一条命令就追加到AOF文件后面，通过appendfsync可以配置刷盘的时机，如果配置为每秒，那么损失的数据就是秒级的。因为是命令，所以AOF文件会越来越大，所以就有AOF的重写：子线程生成一个新的AOF文件，然后去保存该数据库的状态，然后将在这之间的命令追加到后面。</p>
<p>混合式RDB和AOF，AOF重写的时候就以RDB方式写入AOF,然后在重写的时候修改的就以AOF写在后面</p>
<h3 id="做过的sql优化"><a href="#做过的sql优化" class="headerlink" title="做过的sql优化"></a>做过的sql优化</h3><ul>
<li>只返回必要的列，用具体的字段列表代替 select * 语句</li>
<li>尽量走索引：避免索引失效：（1）对索引进行函数操作（2）在字段前面使用模糊查询（3）不符合联合索引最左匹配原则（4）隐式转换</li>
<li>多表关联查询时，小表在前，大表在后。</li>
<li>用join替换子查询，子查询会在内存中创建临时表</li>
</ul>
<h3 id="消息重复消费、消息确认、消息挤压"><a href="#消息重复消费、消息确认、消息挤压" class="headerlink" title="消息重复消费、消息确认、消息挤压"></a>消息重复消费、消息确认、消息挤压</h3><p>重复消费：幂等性设计，redis</p>
<p>消息可靠：从生产者到mq,comfirm机制，mq自身持久化以及集群配置，消费端消费成功的bacikAck,手动确认，保证了业务逻辑执行了</p>
<h3 id="NIO-reactor"><a href="#NIO-reactor" class="headerlink" title="NIO reactor"></a>NIO reactor</h3><p>BIO就是在用户线程发起IO调用的时候，需要阻塞直到内核态数据到达，这样的话，就导致一个线程处理一个连接，性能低下，同步非阻塞就是，不阻塞，就不用线程上下文切换导致开销，但是会浪费CPU资源，NIO就是线程向内核态发送申请时，是向内核发起select调用，那么一个线程就可以注册多个socket,当select事件到达的时候激活线程来处理。在java中，服务端用一个bossworker线程专门接收连接，然后有了事件就通知线程来进行网络读写和计算，这样工作线程没有网络事件时可以处理其他的任务，而不用像传统IO那样必须阻塞等待</p>
<h3 id="谈谈你熟悉的设计模式"><a href="#谈谈你熟悉的设计模式" class="headerlink" title="谈谈你熟悉的设计模式"></a>谈谈你熟悉的设计模式</h3><p>单例模式：为什么需要：因为在计算机中，有些类只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务</p>
<p>进程在内存中保证了对象在内存中全局的唯一性，避免了对象实例的重复创建，节约了系统资源。</p>
<p>静态内部类为什么线程安全：因为每一个类或接口C，都有一个唯一的<code>初始化锁LC</code>，果多个线程同时去初始化一个类，那么只有一个线程能获取到初始化锁LC去执行这个类的类构造器</p>
<p>代理模式：通过代理对象来增强目标对象的功能，实现方式有静态代理，需要接口，动态代理：JDK：需要实现接口，cglib不用实现接口，而是在字节码的时候增强功能。</p>
<p>动态代理的实现：（1）首先通过proxy.getproxyClass,传入class文件以及该类的加载器，（2）然后获取构造函数（3）然后通过构造函数传入invokehandler实现增强方法逻辑</p>
<p>或者直接通过newProxyInstance,传入class，类加载器，invokehandlerlai</p>
<h3 id="谈谈spring-security的流程"><a href="#谈谈spring-security的流程" class="headerlink" title="谈谈spring security的流程"></a>谈谈spring security的流程</h3><p><img src="https://pic1.zhimg.com/80/v2-3dd196b393134e8f8fb6902144224fe4_720w.webp" alt="img"></p>
<p>首先在主方法中封装一个token（一般来说就是userNamePasswordToken），然后通过authenticationManager就是providerManager，去通过责任链模式去遍历provider的集合，每个provider通过support去判断主方法的token是否是自己去authencate,如果不是就传给下一个，如果是的话，就将认证好的用户信息封装在userDetails中然后存在securityContext中，然后后面的provider就不会去验证了。</p>
<p>注意：这里的token可以是userNamePasswordtoken，还有很多，可以自定义，</p>
<p>自定义一套验证机制，不用自带的provider,就需要首先定义provider（继承）,然后就是provider匹配的token（继承现有的），以及provider中需要重写suppot方法，然后设置setUserDetailsService，</p>
<p>授权就是，在认证的时候也查出数据库中该用户的权限，然后封装在userDetails中，在userDetails中去setAuthorize</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/365513384" >https://zhuanlan.zhihu.com/p/365513384<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="谈谈OAuth"><a href="#谈谈OAuth" class="headerlink" title="谈谈OAuth"></a>谈谈OAuth</h3><p>Oauth就是一套在某个应用需要去访问其他应用上资源时的机制，</p>
<p>授权码机制：首先就是应用在第三方应用上创建应用，获取一个clientid,然后在用户登陆时，用户授权之后就有一个code,然后通过code和clientid去第三方授权服务器授权，授权成功，则得到一个token,就去资源服务器拿。</p>
<p>为什么安全：密码和账户是在第三方提供的，而且创建应用也保证了该网站的可靠性，</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://juejin.cn/post/7066716559808397343#heading-0" >https://juejin.cn/post/7066716559808397343#heading-0<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="day-23-3-5"><a href="#day-23-3-5" class="headerlink" title="day 23 3.5"></a>day 23 3.5</h2><h3 id="rpc的负载均衡算法"><a href="#rpc的负载均衡算法" class="headerlink" title="rpc的负载均衡算法"></a>rpc的负载均衡算法</h3><p>最开始是用的普通的hash算法，hash后取摸然后取hash桶，但是这样有个问题就是hash节点出错后会有问题（数据迁移量太大），所以这里就用的是dubbo的一致性hash,大概原理就是用hash环解决的，doSelect判断是否selector中的hash节点下线，如果下线就新new一个，放到selectors缓存中，然后调用selectors的select方法去发现返回哪一个，</p>
<p>一致性哈希的问题就在与新建或下线的节点导致了区域分布不均，节点较少，哈希环上每个节点实际占据的区间大小不一，最终导致业务对节点的访问<strong>冷热不均</strong>。引入<strong>虚拟节点映射</strong>解决了分布不均问题。</p>
<h3 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h3><h4 id="spi和api-的区别"><a href="#spi和api-的区别" class="headerlink" title="spi和api 的区别"></a>spi和api 的区别</h4><p>​    spi 动态扩展机制，api是服务提供者提供给服务调用者的功能列表，服务调用者可以直接调用对应具体的服务，spi是给服务定制的一套约束，可以有很多个服务提供者需要遵循这个规则给服务调用者提供服务，服务调用方根据某种机制去找到对应具体的提供的服</p>
<h4 id="java-中spi的实现"><a href="#java-中spi的实现" class="headerlink" title="java 中spi的实现"></a>java 中spi的实现</h4><p>首先定义一个接口，<br>然后在实现的服务提供者中实现该接口，然后METAINFO&#x2F;service中新建一个文件名为接口路径，内容为类路径的文件，然后服务调用方调用的时候就先serviceLoader去加载类的实现类，返回的是实现该接口的所有服务提供者的类，然后和自己需要的进行比较，调用自己所需的服务</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>好处，通过接口实现服务提供者和服务调用者的解耦，易于第三方扩展</p>
<p>缺点，就是加载该接口的时候把实现该接口的所有类都实现了，springboot和dubbo都对此进行了优化</p>
<h3 id="springboot-的自动装配"><a href="#springboot-的自动装配" class="headerlink" title="springboot 的自动装配"></a>springboot 的自动装配</h3><p>​    springboot的自动装配就是基于spi，自动装配就是通过简单的注解或者配置就可以实现第三方功能，SpringBoot 在启动时会扫描外部引用 jar 包中的META-INF&#x2F;spring.factories文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot，核心注解EnableAutoConfiguration</p>
<p>自动装配流程：</p>
<ul>
<li>判断自动装配开关是否打开</li>
<li>用于获取exclude的</li>
<li>获取需要自动装配的类，读取metainfo&#x2F;下的spring.factories。并不是里面所有的都会加载，而是需要满足ConditionalOnXXX</li>
</ul>
<h3 id="手写RPC中的SPI"><a href="#手写RPC中的SPI" class="headerlink" title="手写RPC中的SPI"></a>手写RPC中的SPI</h3><p>主要在于序列化机制，根据协议中的字段来确定序列化机制；服务注册和服务发现，我这里用的zookeeper，；以及负载均衡的实现，我这里有两种一种是普通的hash,一种是一致性hash</p>
<h3 id="rpc中服务注册以及服务调用是怎么实现的"><a href="#rpc中服务注册以及服务调用是怎么实现的" class="headerlink" title="rpc中服务注册以及服务调用是怎么实现的"></a>rpc中服务注册以及服务调用是怎么实现的</h3><p>因为这里没有用用springboot,所以这里我们需要将service自己去注册，所以这里实现了importbeandefininationregister,去对有对应注解的bean注册，注册这里scanner继承了ClassPathBeanDefinitionScanner，注册这里是为了后面的对象的创建。</p>
<p>注册服务就是在对应的标记为rpcservice的类上去将该服务注册到zookeeper中，我这里就是通过在对象的生命周期中的扩展点（aware，inititatlizing bean）的<em>初始化的时候实现**BeanPostProcessor</em>接口，重写beforeinitalizing和afterinitalizing方法，注册服务就是beforeinitalizing方法中判断是否标记了RPCservice，如果标记了，就将该service发布到zookeeper中，服务调用就是在afterinitalizing中去判断是否标记了RPCRefrence,如果是，通过反射就生成一个代理对象，然后将属性赋值给被代理对象，代理对象里面的invoke方法就包括了远程调用的实现</p>
<h3 id="协议中怎么写的数据的长度"><a href="#协议中怎么写的数据的长度" class="headerlink" title="协议中怎么写的数据的长度"></a>协议中怎么写的数据的长度</h3><p>先空4个字节，再写了数据之后再倒回去写数据长度，netty的byteBuf和java自带的butebuffer,java自带的bytebuf有几个缺点：（1）长度固定，所以再写的时候需要开发人员自己去调整，麻烦（2）读写共享一个指针，需要不断的flip,所以nettty基于这两个进行了优化，有一个自动扩容的机制，读写两个指针，互不影响</p>
<h3 id="谈谈虚拟内存"><a href="#谈谈虚拟内存" class="headerlink" title="谈谈虚拟内存"></a>谈谈虚拟内存</h3><p>​    物理内存出现的问题：内存不足、不安全（因为是直接操作的真实的物理地址，所以有可能操作到了其他线程的地址）</p>
<p>​    虚拟内存就是为了在多进程环境下，使得进程之间的内存地址空间不互相受影响，就不让进程直接操作真实的物理空间地址，而是给每个进程分配一套虚拟空间地址，操作自己的虚拟内存，通过MMU地址空间映射间接操作物理内存，每个进程都有虚拟地址空间，所以当有了大量的进程的时候，就必然后造成内存紧张的情况，所以就有内存交换，将不常使用内存换出到硬盘上，需要的时候再换入，在MMU映射真实物理内存的时候，就需要分段或者分页，分段的缺点在于内存碎片太多，经常使用内存交换开销大，所以分页就可以减少外部内存碎片过大，但是也有就就是页表的大小耗费太多空间，因为页表项太多，需要全部都有，所以就有了二级页表，因为局部性原理，所以不常使用的一级页表就不会创建二级页表</p>
<h2 id="day24-3-6"><a href="#day24-3-6" class="headerlink" title="day24 3.6"></a>day24 3.6</h2><h3 id="谈谈你对AOP的理解"><a href="#谈谈你对AOP的理解" class="headerlink" title="谈谈你对AOP的理解"></a>谈谈你对AOP的理解</h3><p>AOP 就是一种面向切面编程的一种编程思想，是通过预编译方式和运行时动态代理的方式在不修改源代码的情况下动态统一添加功能的技术，面向切面编程就是将程序抽象成各个切面，切面就是应用对象间的横切点，将影响多个类的公共行为封装到一个可重用的模块中，这就是切面，切面简单来说就是与业务无关，却为业务模块共同调用的逻辑，将其封装起来减少系统重复代码，降低耦合度，日志功能、统计功能 </p>
<h3 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h3><p>应用场景：应用日志记录、读取配置文件、工具类：日期处理</p>
<p>静态内部类的实现</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>

作者：猿兄
链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>juejin<span class="token punctuation">.</span>cn<span class="token operator">/</span>post<span class="token operator">/</span><span class="token number">6844904121837830151</span>
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="谈谈IO多路复用"><a href="#谈谈IO多路复用" class="headerlink" title="谈谈IO多路复用"></a>谈谈IO多路复用</h3><p>首先同步阻塞IO以及缺点,然后同步非阻塞IO怎么解决，IO多路复用：多路就是多个文件描述符，复用就是复用一个线程，就是用一个线程来监听多个文件描述符，然后该线程去不断轮询遍历文件描述符，哪个就绪就通知对应程序来处理，这样的好处就不用一个线程处理一个连接，大大节约了资源    </p>
<h3 id="如何用redis实现分布式锁"><a href="#如何用redis实现分布式锁" class="headerlink" title="如何用redis实现分布式锁"></a>如何用redis实现分布式锁</h3><p>直接使用操作redis的几个问题：如果拿锁的进程宕机了，就造成了死锁，所以这里需要设置过期时间；如果过期时间太短就会造成程序还没有运行结束，锁就释放了，所以这里有看门狗机制，自动延续锁的时间；所以为了原子操作，就用而是lua脚本</p>
<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射就是在运行状态，能够获取类的所有属性信息，能够通过类实例化对象，实现对象的调用，能够实现动态编译，<strong>提高代码的灵活性</strong>，应用场景：读取配置文件读取的只是字符串，需要实例化成类了(例如数据库的驱动)；以及aop动态代理在程序运行时创建目标对象的代理类,这必须由反射机制来实现</p>
<h3 id="redis实现数据一致性"><a href="#redis实现数据一致性" class="headerlink" title="redis实现数据一致性"></a>redis实现数据一致性</h3><p>四种策略：先更新缓存再更新数据库、先更新数据库再更新缓存、先删除缓存再更新数据库、先更新数据库再更新缓存</p>
<p>四种都会有事务的机制，前两种还有一种情况就是，每更新一次数据库就去更新缓存，如果缓存是数据库种的数据经过复杂运算得到的，那么频繁的读就会影响到服务器的性能，还有就是缓存利用率低,可能会导致频繁的更新缓存却没有业务来读取该数据。</p>
<p>所以就有了删除缓存的策略，先删除缓存再更新数据库，就会有</p>
<ol>
<li>线程 A 先删除缓存</li>
<li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X &#x3D; 1）</li>
<li>线程 A 将新值写入数据库（X &#x3D; 2）</li>
<li>线程 B 将旧值写入缓存（X &#x3D; 1）</li>
</ol>
<p>那么先更新数据库呢，</p>
<ol>
<li>线程 A 读取数据库，得到旧值（X &#x3D; 1）</li>
<li>线程 B 更新数据库（X &#x3D; 2)</li>
<li>线程 B 删除缓存</li>
<li>线程 A 将旧值写入缓存（X &#x3D; 1）</li>
</ol>
<p>这是理论上的，但是概率很低，写数据库，通常是要比读数据库的时间更长的</p>
<h2 id="day-25-3-7"><a href="#day-25-3-7" class="headerlink" title="day 25 3.7"></a>day 25 3.7</h2><h3 id="hashmap为什么链表长度阈值是8"><a href="#hashmap为什么链表长度阈值是8" class="headerlink" title="hashmap为什么链表长度阈值是8"></a>hashmap为什么链表长度阈值是8</h3><p>因为在hash函数良好的情况下，链表长度大于8的概率小于千万分之一，所以阈值为8就可以了</p>
<h3 id="beanfactory和factorybean"><a href="#beanfactory和factorybean" class="headerlink" title="beanfactory和factorybean"></a>beanfactory和factorybean</h3><p>beanfactory是生成和管理bean的一个工厂，他只是一个接口，实现有xmlbeanfactory以及applicationContext,</p>
<p>factorybean是因为在基于反射实例化bean的时候，某些情况下很复杂，所以spring就提供了接口，<strong>用户可以通过实现该接口定制实例化Bean的逻辑</strong></p>
<h2 id="day-26-3-9"><a href="#day-26-3-9" class="headerlink" title="day 26 3.9"></a>day 26 3.9</h2><h3 id="threadLocal"><a href="#threadLocal" class="headerlink" title="threadLocal"></a>threadLocal</h3><p>是什么、为什么、怎么实现的</p>
<p>（1）是什么：threadLocal是在多线程中为每个线程创建私有变量副本的类</p>
<p>（2）为什么需要呢：在一些公共的工具类，例如日期格式化类，以及私有变量，例如：线程session以及需要线程序列号的，以及一些避免多线程导致问题的：数据库连接，每个线程都去创建就会造成问题，所以直接拷贝一份。</p>
<p>（3）threadLoca通过一个threadLocalMap来实现，threadlocal作为key,value为对象，</p>
<p>（4）内存泄漏，key为弱引用，但是value是强引用，所以如果这个时候没有外部强引用而且gc后，key会被回收，那么value就会造成内存泄漏，主要是在线程池的时候会有这个问题，因为线程池的线程不销毁，所以就会一直造成内存泄漏</p>
<p>为什么key是弱引用呢？如果是强引用的话，如果 没有手动删除的话，gc都不会回收，就肯定会造成问题，变成弱引用后，key被回收之后，在threadLocal.set以及get以及remove都会首先清除key为null的对象，</p>
<p>所以还是建议每次调用完之后就删除。注意：需要用private static 修饰</p>
<h3 id="消息队列的可靠性、消息重复消费、顺序性、消息挤压"><a href="#消息队列的可靠性、消息重复消费、顺序性、消息挤压" class="headerlink" title="消息队列的可靠性、消息重复消费、顺序性、消息挤压"></a>消息队列的可靠性、消息重复消费、顺序性、消息挤压</h3><h2 id="day-27-3-10"><a href="#day-27-3-10" class="headerlink" title="day 27 3.10"></a>day 27 3.10</h2><h3 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h3><h3 id="http1-0-http1-1-http2-0-http3-0"><a href="#http1-0-http1-1-http2-0-http3-0" class="headerlink" title="http1.0 http1.1 http2.0 http3.0"></a>http1.0 http1.1 http2.0 http3.0</h3><p>1.0的问题：短链接、队头阻塞</p>
<p>1.1优化：长连接：connection,解决了请求的队头阻塞，</p>
<p>2.0优化：</p>
<ul>
<li>头部压缩：报文header字段优化，将重复的字段和value放在静态表中，传输的时候就可以减少重复字段的传输，<strong>静态表和 Huffman 编码</strong>，压缩体积，200 原来3个字节，现在1个字节</li>
<li>二进制帧</li>
<li>并发传输：多个stream共用一个tcp减少握手,管道传输，解决了多个文件的队头阻塞，但是没有解决一个stream的tcp层的队头阻塞</li>
<li>服务器主动推送资源</li>
</ul>
<p>3.0优化：</p>
<p>基于udp实现的quic协议，来保证消息可靠以及解决队头阻塞，以及解决了连接迁移</p>
<h3 id="sql-中limit"><a href="#sql-中limit" class="headerlink" title="sql 中limit"></a>sql 中limit</h3><p>limit1,2的意思是从第一行开始取 往后取2个 也就是第二 第三 第一个值代表从哪里开始取，第二个值表示往后取几个 </p>
<h3 id="java初始化顺序"><a href="#java初始化顺序" class="headerlink" title="java初始化顺序"></a>java初始化顺序</h3><p>先初始化类中的静态成员，所以静态优于非静态，父类先于子类，按照成员变量的顺序</p>
<h3 id="linux-命令"><a href="#linux-命令" class="headerlink" title="linux 命令"></a>linux 命令</h3><p>linux命令中cat、more、less、tail、head均可用来查看文件内容，主要区别有：</p>
<p> cat是一次性显示整个文件的内容，适用于文件内容少的情况；<br> more和less一般用于显示文件内容超过一屏的内容，并且提供翻页的功能。</p>
<p>  tail 和 head分别显示文件的后几行和前几行内容。常用于大文件的截取。</p>
<p>开启防火墙：查看防火墙是否打开：firewalld -cmd –state</p>
<p>开启防火墙服务：systemctl start firewalld.service</p>
<p>打开443端口：firewalld -cmd –zone&#x3D;public –add port&#x3D;443&#x2F;tcp –permanent</p>
<p>重启防火墙：systemctl restart firewalld.service</p>
<p>重新载入：firewalld –cmd –reload</p>
<p>查看打开的端口：firewalld –cmd –list-ports</p>
<p>关闭就是remove</p>
<p>修改配置文件后使配置文件生效：source</p>
<p>nginx -s reload</p>
<h2 id="day-28-3-12"><a href="#day-28-3-12" class="headerlink" title="day 28 3.12"></a>day 28 3.12</h2><h3 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h3><p>call：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Callthread</span> aCall<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Callthread</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> futureTask<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>aCall<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Thread</span> aThread<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        aThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>配合线程池使用</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
<span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>		
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>future<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>线程池使用：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
threadPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token string">" 被执行,线程名:"</span> <span class="token operator">+</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>常见的线程池：</p>
<p>FixedThreadPool：可重用固定线程数的线程池。使用无界队列</p>
<p><code>SingleThreadExecutor</code> 是只有一个线程的线程池。也是使用的无界队列</p>
<p>ScheduledThreadPoolExecutor：延迟队列，以及无界队列</p>
<p>建议还是ThreadPoolExecutor</p>
<h3 id="netty-为什么要用异步"><a href="#netty-为什么要用异步" class="headerlink" title="netty 为什么要用异步"></a>netty 为什么要用异步</h3><p>异步没有提高响应速度，提升的是吞吐量。解决主线程的阻塞</p>
<h3 id="BIO-NIO讲讲"><a href="#BIO-NIO讲讲" class="headerlink" title="BIO NIO讲讲"></a>BIO NIO讲讲</h3><p>首先讲讲IO，IO就是用户线程对数据的Input读和output写,但是写数据都是操作系统内核才能做的事，所以用户线程就需要发起系统调用，然后系统准备好数据之后，用户线程就可以读取，在这操作中，多个操作的执行过程不同就有了BIO和NIO以及AIO,BIO是同步阻塞IO,就是说用户线程发起io操作后，用户线程一直阻塞等待操作系统准备好数据，这个过程中就导致了一个IO请求就需要一个线程阻塞，如果连接不做任何事，就会导致该线程一直阻塞，而且在高并发下，一个线程对应一个IO,那么资源很快就会被耗尽，所以这个时候NIO就来了</p>
<p>NIO是同步非阻塞IO,也就是IO多路复用，就是多个连接共用一个线程，那么是怎么实现的呢，就是在用户线程发起io请求时，会将该请求注册到一个多路选择器selector上，然后选择器就会轮询每个连接的缓冲区的数据是否到达，如果还未到达完，那么这个时候用户线程就不用去阻塞，就可以干自己的事，等到数据到达之后，就会调用该线程去执行io</p>
<p>AIO就是不用用户线程选择器去轮询，而是内核自己数据到达后，通知对应的线程来处理</p>
<p>BIO是基于流的，而NIO是基于块的，面向缓冲区和channel的，            </p>
<h3 id="netty的线程模型：Reactor模型"><a href="#netty的线程模型：Reactor模型" class="headerlink" title="netty的线程模型：Reactor模型"></a>netty的线程模型：Reactor模型</h3><p>Reactor模型就是对NIO的实现和扩展，reactor分为三种：</p>
<p>单Reactor单线程，一个reactor处理连接之后，需要调用handler去处理请求，因为只有一个handler,所以后面的请求会阻塞。</p>
<p>单reactor多线程，一个reactor处理连接之后，有多个handler 调用，但是这个一旦并发量高，一个reactor还是会有性能瓶颈，</p>
<p>主从reactor多线程，一个主reactor只负责连接，例如netty中的bossworker,然后连接之后交给子reactor,去负责监听请求然后调用handler</p>
<h2 id="day-29-3-13"><a href="#day-29-3-13" class="headerlink" title="day 29 3.13"></a>day 29 3.13</h2><h3 id="cpu占用飙升怎么处理：空轮询、空循环"><a href="#cpu占用飙升怎么处理：空轮询、空循环" class="headerlink" title="cpu占用飙升怎么处理：空轮询、空循环"></a>cpu占用飙升怎么处理：空轮询、空循环</h3><ul>
<li>首先通过top指令查看当前占用CPU较高的pid,shfit+P按照占用率排序</li>
<li>然后查看该进程里消耗资源的线程PID,top -HP PID</li>
<li>然后通过print命令将其线程pid转为16进制，然后通过jstack 查看进程的快照。然后通过刚刚定位的线程号来定位日志</li>
<li>然后分析代码</li>
</ul>
<h3 id="full-gc-经常发生的原因和排查"><a href="#full-gc-经常发生的原因和排查" class="headerlink" title="full gc 经常发生的原因和排查"></a>full gc 经常发生的原因和排查</h3><h3 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/15/1704860a4de235aa~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h3 id="字符串常量池StringTable"><a href="#字符串常量池StringTable" class="headerlink" title="字符串常量池StringTable"></a>字符串常量池StringTable</h3><p>字符串的分配和其他对象一样，都需要在堆中分配对象，有较大的消耗，jvm就做了优化，每当创建字符串常量的时候，jvm会首先检查常量池中有没有，如果有，就直接返回该字符串的对象引用，如果没有，就分配一个空间存储该字符串，然后堆中对象指向该字符串</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token class-name">A</span> <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">String</span> s0<span class="token operator">=</span><span class="token string">"a"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token operator">+</span><span class="token string">"b"</span><span class="token punctuation">;</span><span class="token comment">//两个字符串常量拼接</span>
        <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token class-name">A</span><span class="token operator">+</span><span class="token string">"b"</span><span class="token punctuation">;</span><span class="token comment">//常量引用和字符串常量拼接</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true final修饰的字符串在编译期间会放入常量池</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2 <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
        <span class="token class-name">String</span> s3<span class="token operator">=</span> s0<span class="token operator">+</span><span class="token string">"b"</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s4 <span class="token operator">=</span> s3<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断s3字符串在字符串常量池中是否有，有的话就返回引用，没有就新建返回引用</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false,对象相加使用stringbuilder，返回时会return new string（）；</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s4 <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
        <span class="token class-name">String</span> s5<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false,有了new都是在堆中新建对象</span>
        
        
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>equals都是true；equals是指对象的值是否相同</p>
<h3 id="怎么保证线程安全"><a href="#怎么保证线程安全" class="headerlink" title="怎么保证线程安全"></a>怎么保证线程安全</h3><p>原子类、volatile、锁，以及无状态设计final、concurrent包下的并发类信号量、CountDownLatch、CylicBarrier。</p>
<p>原子类分为四种：原子更新基本类型、原子更新引用类型、原子更新属性、原子更新数组</p>
<p>基本方法：getAndSet，getAndincreament，原子类就是通过CAS、volatile以及native方法实现的，CAS就是通过拿期望的值和内存中的值作比较，如果相同就更新，不同就不能更新，然后自旋去尝试更改，native方法就是unsafe类来获取原来的值的内存地址，然后volatile就保证了jvm任何时刻任何线程可以获取到最新的值</p>
<p>volatile</p>
<p>锁：synchrnized和lock,</p>
<p>countDownLacth：一个或者多个线程等待其他线程完成操作：保安关门</p>
<p>CyclicBarrier：让一组线程到达一个屏障时被阻塞，直达最后一个线程到达屏障，然后打开屏障，线程继续运行，跑步，</p>
<h3 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h3><p>管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、socket，socket可以本机通信（不通过网卡）</p>
<p>共享内存：多个进程共享一块物理内存，共享内存是用户线程空间，所以直接在用户态之间写和读数据，比管道这种需要写入内核内存快很多</p>
<h3 id="进程如何分配空间"><a href="#进程如何分配空间" class="headerlink" title="进程如何分配空间"></a>进程如何分配空间</h3><p>text：代码段，程序代码在内存中的映射，存放函数体的二进制代码</p>
<p>data：数据段，已经初始化的全局变量以及内部的静态变量</p>
<p>bss段：BSS段包含了程序中未初始化的全局变量</p>
<p>栈：存放局部变量以及常量池</p>
<p>堆：动态分配的空间，</p>
<h3 id="每个进程所占用的最大内存"><a href="#每个进程所占用的最大内存" class="headerlink" title="每个进程所占用的最大内存"></a>每个进程所占用的最大内存</h3><p>就是虚拟内存，虚拟内存的大小取决于操作系统的位数，如果是32位的，那么就是2的32次方就是4G,除去linux操作系统需要的1G,剩下3G,如果是64位的话，按理来说就是2的64位，但是这个数字太大了，所以之用48位，就是256TB,除去操作系统用128TB,虚拟地址空间是128TB</p>
<h3 id="什么是零拷贝"><a href="#什么是零拷贝" class="headerlink" title="什么是零拷贝"></a>什么是零拷贝</h3><p>就是在我们读取磁盘数据然后将其通过网卡传输的时候，流程是首先用户线程发起系统调用，发生一次上下文切换，然后通过DMA拷贝带内核缓冲区，然后切换到用户态，通过CPU拷贝到用户缓冲区，然后同样的发生两次上下文切换，以及两个拷贝，</p>
<p>零拷贝就是不用拷贝到用户缓冲区中，一种是mmap（共享内存）加read，第一次DMA拷贝到内核缓冲区的时候就将该内存与用户线程共享，但是也少不了4次上下文切换，只是少了一次数据拷贝，通过sendfile,少两次上下文切换，然后直接拷贝到ssocket的缓冲区，</p>
<h2 id="day-30-3-14"><a href="#day-30-3-14" class="headerlink" title="day 30 3.14"></a>day 30 3.14</h2><h3 id="java-的spi"><a href="#java-的spi" class="headerlink" title="java 的spi"></a>java 的spi</h3><p>spi就是对服务实现的一种约束，是提供给服务提供者的，易于扩展，服务提供者想要实现该服务，就需要实现对应的接口，然后在meta-inf&#x2F;下的services里面新建一个文件名为接口，内容为实现类的全类名的文件，在java里面的spi,这样在加载接口类的时候，就会用serviceLoader去遍历然后加载，这样就有问题，一个问题就是每个接口都是一个文件，这样的话文件太多，springboot就解决了这个问题，还有一个问题就是去遍历加载，就会导致有些不用的实现类也加载了，所以dubbo就优化了这里。</p>
<p>springboot怎么优化的：所有都放在一个文件spring.factories,然后通过前缀类名来判断，实现类用逗号隔开。</p>
<p>dubbo的话，就是不用遍历加载，他也是每个接口都是一个文件，然后在实现类前面加上辨识字段，首先去比对该字段，符合则加载后面的实现类，ExtensionLoader.getExtensionLoader</p>
<h3 id="CAS-1"><a href="#CAS-1" class="headerlink" title="CAS"></a>CAS</h3><p>cas是java里面一个乐观锁的实现方式，他不同与悲观锁synchronized,直接将进程阻塞，而是通过unsafe类去判断内存中的值是否是期望的值这期间是否被修改过，如果没有那么就原子性更改，有的话就继续自旋，那么怎么原子性的呢，其实就是底层的一个汇编指令cmpxchg,jvm将他封装为unsafe类的方法，该指令在执行的时候会调用lock指令，就会锁住缓存锁，使其他处理器不能去操作这块内存，然后更新后通过缓存一致性协议比如mesi,去通知其他处理器的缓存失效。</p>
<p>CAS的问题：ABA问题（加版本号AtomicStampedRerence）以及长时间自旋空转导致cpu消耗大</p>
<p>CAS只能一个对象原子，多个对象的话就需要synchrinized,CAS只能保证原子性，不能保证可见性，</p>
<h3 id="synchronized-在一个类中多个成员函数"><a href="#synchronized-在一个类中多个成员函数" class="headerlink" title="synchronized 在一个类中多个成员函数"></a>synchronized 在一个类中多个成员函数</h3><p>synchronized 在一个类中多个成员函数加上，锁的是对象，所以同一个对象就不能同时调用这两个方法，不同对象就可以</p>
<h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><p>hashmap 默认初始化16,每次扩容数组是两倍，为什么是两倍，因为</p>
<p>arrayList采用懒加载，最开始是0,当添加一个元素的时候是10,然后以后每次到达size乘以负载因子就是阈值的时候就会去扩容为1.5倍，如果元素添加过多，扩容后也无法放的下的话，就有一个比较最大容量的</p>
<h3 id="hashmap1-7-和1-8"><a href="#hashmap1-7-和1-8" class="headerlink" title="hashmap1.7 和1.8"></a>hashmap1.7 和1.8</h3><p><a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36520235/article/details/82417949" >https://blog.csdn.net/qq_36520235/article/details/82417949<i class="fas fa-external-link-alt"></i></a></p>
<p>hashmap1.7和1.8的区别，</p>
<ul>
<li>第一个结构上，就是1.7是采用数组+链表，而1.8为了避免因为hash冲突导致的链表长度过长，就在链表长度大于8的时候，将其转化为红黑树，将复杂度从O（n）变为了O（logn），然后红黑树节点小于6的时候会转为链表，中间有一个7就是为了避免红黑树和链表频繁的切换。</li>
<li>第二个就是在插入数据的时候，1.7是头插入，1.8是尾插入，1.7的头插入就导致了在并发的时候如果有扩容会导致死循环，因为一个线程将其扩容之后，将整个链表倒序了，123就变成了321,那么另一个线程1的next还是2,但是扩容后就会导致2的next是1，所以就导致了死循环。</li>
<li>第三个是：扩容机制，1.7是先扩容在插入，而1.8是先插入在扩容，为什么呢，1.7先扩容再插入是因为头插入，可以直接将插入的元素放在位置上，不需要再次遍历；1.8是因为在避免树和链表的切换，比如现在有7的红黑树，如果先扩容，就有可能使该位置的元素变为6,然后就会回退为链表，如果有插入，又变成7,就又会变为红黑树</li>
<li>第四个是扩容后重新计算位置：1.7是和之前一样hash与上数组长度减1,为什么扩容2倍，就是因为数组减一保证位山个都是1,可以减少hash虫体，1.8是位置等于原数组位置或者原数组加上旧容量，其实就是减少了重新计算hash值，就是判断扩容的那一位是0还是1,（<a class="link"   target="_blank" rel="noopener" href="https://blog.csdn.net/u012501054/article/details/103710171%EF%BC%89" >https://blog.csdn.net/u012501054/article/details/103710171）<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<p>为什么链表的长度阈值是8。，因为在节点在容器中hash桶的分布遵循泊松分布，所以桶大于8的概率是很小的，大约是千万分之一。</p>
<h3 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h3><p>双亲委派机制：中父加载器和子加载器的关系是什么：组合，组合是通过现有的类进行拼装，然后产生新的、更复杂的功能，各个类之间是不知道内部结构的</p>
<p>双亲委派机制：就是在收到一个类加载的请求时，他不会先加载，而是将加载请求委托给父加载器加载，知道委托到顶层的启动类加载器，如果父加载器无法完成，就交给子加载器。</p>
<p>双亲委派机制是为了保证java核心库的类型安全，比如核心类object,如果没有双亲委派机制的话，每个java应用都自己加载的话，就会存在多个版本的object,保证了java核心库的安全，</p>
<p>为什么要破坏双亲委派机制：因为有些接口类是在启动类加载器加载的，比如jdbc的driveManager，当启动类加载器加载他的时候，会调用静态方法，去加载驱动程序，但是驱动程序是第三方实现的，所以不能由启动类加载器加载，所以这里就需要打破双亲委派机制,但是具体的实现有时要通过系统加载器加载，所以这就出现问题了，比如SPI的大多服务都是这样，所以需要线程上下文切换器来设置当前线程的类加载器，自定义类加载器需要继承classloader,然后重写findclass方法，</p>
<h2 id="day-31-3-15"><a href="#day-31-3-15" class="headerlink" title="day 31 3.15"></a>day 31 3.15</h2><h3 id="一个进程能打开的文件句柄socket最大是1024"><a href="#一个进程能打开的文件句柄socket最大是1024" class="headerlink" title="一个进程能打开的文件句柄socket最大是1024"></a>一个进程能打开的文件句柄socket最大是1024</h3><h3 id="mysql-的慢查"><a href="#mysql-的慢查" class="headerlink" title="mysql 的慢查"></a>mysql 的慢查</h3><p>什么是慢查：一条sql执行的时间太慢，大于了mysql设置的long_query_time,就会把该条sql执行的一些信息放在慢查日志中。</p>
<p>慢查有什么危害：一个进程能够打开的最大socket文件句柄是1024,大量的慢查占据连接，慢查连接积累到一定程度会使一些诶正常的sql得不到执行，也变成慢查sql,最终就有可能导致mysql的连接全部被耗光。</p>
<p>通过explain分析：</p>
<ul>
<li>是否设置了索引</li>
<li>索引是否生效，索引这时候不生效有可能就是优化器，查看explain的key字段，优化器选择的索引选择错误，</li>
<li>数据量太大，即使有索引也是慢sql</li>
</ul>
<h3 id="联合索引是否走索引"><a href="#联合索引是否走索引" class="headerlink" title="联合索引是否走索引"></a>联合索引是否走索引</h3><p><a class="link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1797382" >https://cloud.tencent.com/developer/article/1797382<i class="fas fa-external-link-alt"></i></a></p>
<p>是否符合最左匹配原则以及优化器的选择，如果使用索引查出来的区分度不高，就会不使用索引，比如unsigned，因为本身unsigned就大于0，如果是a》1,那么使用索引也会基本上所有数据回表</p>
<p>建好索引判断能否走：    优化器优化顺序后，判断是否遵循最左匹配原则</p>
<p>根据sql建立索引：优化器可以自动优化顺序</p>
<p>orderby 建立索引可以避免再次排序</p>
<h3 id="索引下堆"><a href="#索引下堆" class="headerlink" title="索引下堆"></a>索引下堆</h3><p>联合索引，当不符合最左匹配原则之后，会在索引中先匹配一次，然后再去回表</p>
<h3 id="数据库中date-datetime-timeStamp"><a href="#数据库中date-datetime-timeStamp" class="headerlink" title="数据库中date datetime timeStamp"></a>数据库中date datetime timeStamp</h3><p>数据库中date对应java中的date</p>
<p>dateTime以及timeStamp对应的是 java中的dateTime。</p>
<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p><a class="link"   target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1920081s" >https://cloud.tencent.com/developer/article/1920081s<i class="fas fa-external-link-alt"></i></a></p>
<p>发送端和接收端都有一个缓冲区，流量控制是为了避免发送方填满接收方的空闲区间，而拥塞控制就是为了避免发送方填满整个网络，没有拥塞控制的话，当网络极度拥塞的时候，这个时候发送方还继续发送数据，这些数据包就会因为网络拥塞而丢包，触发重传机制，进而继续拥塞。</p>
<p>怎么解决拥塞控制：慢启动、拥塞避免、拥塞发生、快速恢复</p>
<p>慢启动：就是最开始呈指数增长，收到一个ACK,就窗口就变为2,然后发两个，收到两个就变为4,然后发4个收到4个，窗口变为8</p>
<p>当拥塞窗口大小大于慢启动门限的时候，就使用拥塞避免算法，每收到一个就增加一个，</p>
<p>当发生超时重传拥塞的时候，窗口变为1,慢启动门限变为一半</p>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/HexoBlog/tags/%E5%87%86%E5%A4%87/">#准备</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/HexoBlog/2023/03/15/%E5%87%86%E5%A4%873/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">准备3</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/HexoBlog/2022/11/29/%E5%87%86%E5%A4%871/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">准备1</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">lj</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#day1"><span class="nav-number">1.</span> <span class="nav-text">day1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql"><span class="nav-number">1.1.</span> <span class="nav-text">mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">存储引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">1.存储引擎是什么，</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-mysql%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">2.mysql中常见的存储引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">数据库的事务隔离级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">mysql 索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E9%94%AE%E9%80%9A%E5%B8%B8%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9Eid"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">为什么主键通常建议使用自增id</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day2"><span class="nav-number">2.</span> <span class="nav-text">day2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MyISAM-%E5%92%8C-InnoDB-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">MyISAM 和 InnoDB 如何选择？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">MySQL 查询缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.0.0.3.1.</span> <span class="nav-text">MVCC 是什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">2.0.0.3.2.</span> <span class="nav-text">当前读和快照读</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A5%BD%E5%A4%84"><span class="nav-number">2.0.0.3.3.</span> <span class="nav-text">MVCC 解决的问题以及好处</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.0.0.3.4.</span> <span class="nav-text">MVCC和当前读、快照读的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E4%B8%AA%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">2.0.0.3.5.</span> <span class="nav-text">4个隐式字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#undo-log"><span class="nav-number">2.0.0.3.6.</span> <span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#read-view%EF%BC%88%E8%AF%BB%E8%A7%86%E5%9B%BE%EF%BC%89"><span class="nav-number">2.0.0.3.7.</span> <span class="nav-text">read view（读视图）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9ARR%E5%92%8CRC%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84read-view"><span class="nav-number">2.0.0.3.8.</span> <span class="nav-text">MVCC相关问题：RR和RC级别下的read view</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-3-12-5"><span class="nav-number">3.</span> <span class="nav-text">day 3 12.5</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E9%94%81"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">mysql 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="nav-number">3.0.0.1.1.</span> <span class="nav-text">表锁和行锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.0.0.1.2.</span> <span class="nav-text">行锁的使用的注意事项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">3.0.0.1.3.</span> <span class="nav-text">共享锁和排他锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">3.0.0.1.4.</span> <span class="nav-text">意向锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#innoDb-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A1%8C%E9%94%81"><span class="nav-number">3.0.0.1.5.</span> <span class="nav-text">innoDb 有哪些行锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">mysql 三大日志</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#redo-log"><span class="nav-number">3.0.0.2.1.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#redo-log%E5%B0%8F%E7%BB%93"><span class="nav-number">3.0.0.2.2.</span> <span class="nav-text">redo log小结</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bin-log"><span class="nav-number">3.0.0.2.3.</span> <span class="nav-text">bin log</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">两阶段提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">sql语句执行流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day4-12-12"><span class="nav-number">4.</span> <span class="nav-text">day4 12.12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">创建型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">建造器模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">原型模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">结构型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">适配器模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-5-12-13"><span class="nav-number">5.</span> <span class="nav-text">day 5 12.13</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.3.</span> <span class="nav-text">享元模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.4.</span> <span class="nav-text">装饰器模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E6%80%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.</span> <span class="nav-text">行为性设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">观察者模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-6-12-14"><span class="nav-number">6.</span> <span class="nav-text">day 6 12.14</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">模板方法模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.3.</span> <span class="nav-text">迭代器模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">设计模式总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-7-12-15"><span class="nav-number">7.</span> <span class="nav-text">day 7  12.15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%9F%BA%E7%A1%80"><span class="nav-number">7.1.</span> <span class="nav-text">java 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk%E3%80%81jre%E3%80%81jvm-jit%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81Aot"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">jdk、jre、jvm jit编译器、Aot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4java%E6%98%AF%E8%A7%A3%E9%87%8A%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%BB%93%E5%90%88"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">为什么说java是解释与编译型语言结合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java-%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">java 和C++的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">7.2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81"><span class="nav-number">7.2.2.</span> <span class="nav-text">静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">7.2.3.</span> <span class="nav-text">重载和重写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.1.</span> <span class="nav-text">包装类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6"><span class="nav-number">7.3.2.</span> <span class="nav-text">浮点数运算丢失精度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">7.4.</span> <span class="nav-text">面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93"><span class="nav-number">7.4.1.</span> <span class="nav-text">对象的引用和对象实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">7.4.2.</span> <span class="nav-text">深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">7.4.3.</span> <span class="nav-text">Object常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%B1%BB%EF%BC%9A"><span class="nav-number">7.4.4.</span> <span class="nav-text">String类：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-8-2-5"><span class="nav-number">8.</span> <span class="nav-text">day 8 2.5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">8.1.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception-%E5%92%8C-Error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.1.1.</span> <span class="nav-text">Exception 和 Error 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally%EF%BC%9F"><span class="nav-number">8.1.2.</span> <span class="nav-text">如何使用 try-with-resources 代替try-catch-finally？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-SPI"><span class="nav-number">8.3.</span> <span class="nav-text">java SPI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">8.4.</span> <span class="nav-text">java 序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">8.5.</span> <span class="nav-text">java内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="nav-number">8.5.1.</span> <span class="nav-text">运行时数据区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">8.5.2.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">8.5.3.</span> <span class="nav-text">虚拟机栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">8.5.4.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">8.5.5.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">8.5.6.</span> <span class="nav-text">字符串常量池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hotSpot%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.6.</span> <span class="nav-text">hotSpot的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">8.6.1.</span> <span class="nav-text">对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="nav-number">8.6.1.1.</span> <span class="nav-text">一:类加载检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%EF%BC%9A%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">8.6.1.2.</span> <span class="nav-text">二：分配空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="nav-number">8.6.1.3.</span> <span class="nav-text">三：初始化零值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">8.6.1.4.</span> <span class="nav-text">四：设置对象头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%EF%BC%9A%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95"><span class="nav-number">8.6.1.5.</span> <span class="nav-text">五：执行init方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">8.6.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">8.6.3.</span> <span class="nav-text">对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84"><span class="nav-number">8.6.3.1.</span> <span class="nav-text">句柄</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88"><span class="nav-number">8.6.3.2.</span> <span class="nav-text">直接指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-9-2-8"><span class="nav-number">8.7.</span> <span class="nav-text">day 9 2.8</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">8.7.1.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-list"><span class="nav-number">8.7.2.</span> <span class="nav-text">collection-list</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#arraylist%E6%BA%90%E7%A0%81%E6%89%A9%E5%AE%B9%E5%88%86%E6%9E%90"><span class="nav-number">8.7.2.1.</span> <span class="nav-text">arraylist源码扩容分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ensureCapacity"><span class="nav-number">8.7.2.2.</span> <span class="nav-text">ensureCapacity</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-set"><span class="nav-number">8.7.3.</span> <span class="nav-text">collection-set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-queue"><span class="nav-number">8.7.4.</span> <span class="nav-text">collection-queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-map"><span class="nav-number">8.7.5.</span> <span class="nav-text">collection-map</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hashmap%E5%92%8Chashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.7.5.1.</span> <span class="nav-text">Hashmap和hashtable的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashset%E5%92%8Chashmap"><span class="nav-number">8.7.5.2.</span> <span class="nav-text">hashset和hashmap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E5%92%8Ctreemap"><span class="nav-number">8.7.5.3.</span> <span class="nav-text">hashmap和treemap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#concurrentmap"><span class="nav-number">8.7.5.4.</span> <span class="nav-text">concurrentmap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO"><span class="nav-number">8.8.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO"><span class="nav-number">8.8.1.</span> <span class="nav-text">同步阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">8.8.2.</span> <span class="nav-text">同步非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">8.8.3.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AIO-%E5%BC%82%E6%AD%A5"><span class="nav-number">8.8.4.</span> <span class="nav-text">AIO 异步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%B9%B6%E5%8F%91"><span class="nav-number">8.9.</span> <span class="nav-text">java 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">8.9.1.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E5%92%8C%E7%A0%B4%E5%9D%8F%E6%AD%BB%E9%94%81"><span class="nav-number">8.9.1.1.</span> <span class="nav-text">预防和破坏死锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-%E5%92%8Csleep"><span class="nav-number">8.9.2.</span> <span class="nav-text">wait 和sleep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS"><span class="nav-number">8.9.3.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%EF%BC%88%E7%BB%93%E5%90%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E6%9D%A5%E8%AE%B0%E5%BF%86%EF%BC%89"><span class="nav-number">8.9.4.</span> <span class="nav-text">volatile（结合单例模式的线程安全的双重检查来记忆）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">8.9.5.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">8.9.6.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A"><span class="nav-number">8.9.7.</span> <span class="nav-text">轻量级锁：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">8.9.8.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%92%8Creentrantlock"><span class="nav-number">8.9.9.</span> <span class="nav-text">synchronized和reentrantlock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">8.9.10.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Atomic"><span class="nav-number">8.9.11.</span> <span class="nav-text">Atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Atomic%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB"><span class="nav-number">8.9.11.1.</span> <span class="nav-text">Atomic主要分为四类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM"><span class="nav-number">8.9.12.</span> <span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81JMM"><span class="nav-number">8.9.12.1.</span> <span class="nav-text">为什么需要JMM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%9C%A8%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">8.9.12.2.</span> <span class="nav-text">保证共享变量在主内存和线程本地内存的一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Happens-before"><span class="nav-number">8.9.12.3.</span> <span class="nav-text">Happens-before</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-9-2-9"><span class="nav-number">8.10.</span> <span class="nav-text">day 9 2.9</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-%E7%BA%BF%E7%A8%8B"><span class="nav-number">8.10.1.</span> <span class="nav-text">java 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">8.10.1.1.</span> <span class="nav-text">线程池的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BB%BA%E8%AE%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">8.10.1.2.</span> <span class="nav-text">建议使用ThreadPoolExecutor构造函数建议线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">8.10.1.3.</span> <span class="nav-text">ThreadPoolExecutor构造函数参数解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C"><span class="nav-number">8.10.1.4.</span> <span class="nav-text">线程池运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">8.10.1.5.</span> <span class="nav-text">任务的执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="nav-number">8.10.1.6.</span> <span class="nav-text">任务的提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">8.10.1.7.</span> <span class="nav-text">任务的关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">8.10.1.8.</span> <span class="nav-text">线程池的线程数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">8.10.1.9.</span> <span class="nav-text">使用线程池的注意事项：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS"><span class="nav-number">8.10.2.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="nav-number">8.10.2.1.</span> <span class="nav-text">AQS是什么：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="nav-number">8.10.2.2.</span> <span class="nav-text">AQS的核心思想：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-number">8.10.2.3.</span> <span class="nav-text">AQS对资源的共享方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E4%BA%86%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.10.2.4.</span> <span class="nav-text">AQS底层使用了模板模式的设计模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.10.2.5.</span> <span class="nav-text">AQS 数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E8%BF%87%E7%A8%8B"><span class="nav-number">8.10.2.6.</span> <span class="nav-text">AQS过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E6%80%BB%E7%BB%93"><span class="nav-number">8.10.2.7.</span> <span class="nav-text">AQS总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-10-2-10"><span class="nav-number">8.11.</span> <span class="nav-text">day 10 2.10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">8.12.</span> <span class="nav-text">JVM垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">8.12.0.1.</span> <span class="nav-text">堆空间的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">8.12.0.2.</span> <span class="nav-text">内存分配以及基本原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E8%80%8C%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="nav-number">8.12.0.3.</span> <span class="nav-text">死亡对象而判断方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.12.1.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B8%B8%E9%87%8F%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-number">8.12.2.</span> <span class="nav-text">如何判断常量是垃圾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="nav-number">8.12.3.</span> <span class="nav-text">如何判断类是无用的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">8.12.4.</span> <span class="nav-text">垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">8.12.5.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.1.</span> <span class="nav-text">serial 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scanvenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.3.</span> <span class="nav-text">Parallel Scanvenge收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.4.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.5.</span> <span class="nav-text">G1收集器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">8.13.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">8.13.0.0.1.</span> <span class="nav-text">类加载器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-number">8.13.0.1.</span> <span class="nav-text">双亲委派机制：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">8.14.</span> <span class="nav-text">Java 执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk%E8%87%AA%E5%B8%A6%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="nav-number">8.15.</span> <span class="nav-text">jdk自带的监控工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">8.16.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.16.1.</span> <span class="nav-text">TCP&#x2F;IP四层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">8.16.1.1.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">8.16.1.2.</span> <span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">8.16.1.3.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">8.16.1.4.</span> <span class="nav-text">网络接口层</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.16.2.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9-TCP-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89-UDP"><span class="nav-number">8.16.3.</span> <span class="nav-text">什么时候选择 TCP,什么时候选 UDP?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">8.16.4.</span> <span class="nav-text">TCP的三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">8.16.4.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">8.16.4.2.</span> <span class="nav-text">四次挥手</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-11-2-12"><span class="nav-number">9.</span> <span class="nav-text">day 11 2.12</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">9.0.1.</span> <span class="nav-text">TCP如何保证传输的可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARQ%E5%8D%8F%E8%AE%AE"><span class="nav-number">9.0.2.</span> <span class="nav-text">ARQ协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%88%B0%E5%BA%95%E5%B1%95%E7%A4%BA%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">9.0.3.</span> <span class="nav-text">从输入URL到页面到底展示了什么</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">9.0.4.</span> <span class="nav-text">http 状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS-%E5%92%8CHTTP"><span class="nav-number">9.0.5.</span> <span class="nav-text">HTTPS 和HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">9.0.5.1.</span> <span class="nav-text">非对称加密</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">9.0.5.2.</span> <span class="nav-text">对称加密</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AC%E9%92%A5%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BF%A1%E8%B5%96%E6%80%A7"><span class="nav-number">9.0.5.3.</span> <span class="nav-text">公钥传输的信赖性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="nav-number">9.0.6.</span> <span class="nav-text">MAC地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARP%EF%BC%9A"><span class="nav-number">9.0.7.</span> <span class="nav-text">ARP：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">9.1.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.1.1.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="nav-number">9.1.2.</span> <span class="nav-text">进程的五个状态：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="nav-number">9.1.3.</span> <span class="nav-text">进程间的通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.1.4.</span> <span class="nav-text">进程之间同步的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">9.1.5.</span> <span class="nav-text">进程的调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%844%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">9.1.6.</span> <span class="nav-text">死锁的4个必要条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81"><span class="nav-number">9.1.7.</span> <span class="nav-text">解决死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">9.1.8.</span> <span class="nav-text">（二）内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">9.1.9.</span> <span class="nav-text">常见的内存管理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8%E5%92%8C%E5%A4%9A%E6%9E%81%E9%A1%B5%E8%A1%A8"><span class="nav-number">9.1.10.</span> <span class="nav-text">快表和多极页表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BF%AB%E8%A1%A8"><span class="nav-number">9.1.10.1.</span> <span class="nav-text">快表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">9.1.10.2.</span> <span class="nav-text">多级页表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B1%E5%90%8C%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB"><span class="nav-number">9.1.11.</span> <span class="nav-text">分页机制和分段机制的共同以及区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">9.2.</span> <span class="nav-text">（三）虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">9.2.1.</span> <span class="nav-text">什么是虚拟内存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">9.2.2.</span> <span class="nav-text">为什么要有虚拟地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="nav-number">9.2.3.</span> <span class="nav-text">局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%8A%80%E6%9C%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">9.2.4.</span> <span class="nav-text">虚拟内存技术的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">9.2.5.</span> <span class="nav-text">页面置换算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-12-2-14"><span class="nav-number">10.</span> <span class="nav-text">day 12 2.14</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#netty"><span class="nav-number">10.1.</span> <span class="nav-text">netty</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#BIO"><span class="nav-number">10.1.1.</span> <span class="nav-text">BIO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO-1"><span class="nav-number">10.1.2.</span> <span class="nav-text">同步非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-1"><span class="nav-number">10.1.3.</span> <span class="nav-text">IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#select"><span class="nav-number">10.1.3.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#poll"><span class="nav-number">10.1.3.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll"><span class="nav-number">10.1.3.3.</span> <span class="nav-text">epoll</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select%E3%80%81poll%E3%80%81epoll%E5%8C%BA%E5%88%AB"><span class="nav-number">10.1.4.</span> <span class="nav-text">select、poll、epoll区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8BReactor"><span class="nav-number">10.1.5.</span> <span class="nav-text">netty的线程模型Reactor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#netty%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6%E6%AF%94JDK%E8%87%AA%E5%B8%A6NIO%E7%BC%96%E7%A8%8B%E4%BE%BF%E5%88%A9%EF%BC%9A"><span class="nav-number">10.1.6.</span> <span class="nav-text">netty网络框架比JDK自带NIO编程便利：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#netty%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.1.7.</span> <span class="nav-text">netty的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%B2%98%E5%8C%85-x2F-%E6%8B%86%E5%8C%85"><span class="nav-number">10.1.8.</span> <span class="nav-text">TCP粘包&#x2F;拆包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6"><span class="nav-number">10.1.9.</span> <span class="nav-text">心跳机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">10.1.10.</span> <span class="nav-text">netty的零拷贝</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis"><span class="nav-number">10.2.</span> <span class="nav-text">redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">10.2.1.</span> <span class="nav-text">redis的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#String"><span class="nav-number">10.2.1.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#List"><span class="nav-number">10.2.1.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hash"><span class="nav-number">10.2.1.3.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Set"><span class="nav-number">10.2.1.4.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Sored-Set"><span class="nav-number">10.2.1.5.</span> <span class="nav-text">Sored Set</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Bit-map"><span class="nav-number">10.2.1.6.</span> <span class="nav-text">Bit map</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">10.2.1.7.</span> <span class="nav-text">HyperLogLog</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Geospatial-index"><span class="nav-number">10.2.1.8.</span> <span class="nav-text">Geospatial index</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1String%E5%92%8Chash%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">10.2.1.9.</span> <span class="nav-text">存储对象String和hash的区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">10.2.2.</span> <span class="nav-text">redis 的线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">10.2.3.</span> <span class="nav-text">redis的内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%99key%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="nav-number">10.2.3.1.</span> <span class="nav-text">给key设置过期时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E5%91%A2"><span class="nav-number">10.2.3.2.</span> <span class="nav-text">redis 是如何判断数据过期呢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#redis-%E7%9A%84%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="nav-number">10.2.3.3.</span> <span class="nav-text">redis 的内存淘汰机制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">10.2.4.</span> <span class="nav-text">redis的持久化机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRDB%E5%BF%AB%E7%85%A7"><span class="nav-number">10.2.4.1.</span> <span class="nav-text">什么是RDB快照</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOF"><span class="nav-number">10.2.4.2.</span> <span class="nav-text">什么是AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#AOF%E9%87%8D%E5%86%99"><span class="nav-number">10.2.4.2.1.</span> <span class="nav-text">AOF重写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB%E5%92%8CAOF%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">10.2.5.</span> <span class="nav-text">RDB和AOF的选择</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="nav-number">10.2.6.</span> <span class="nav-text">redis的事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%81%BF%E5%85%8D%E5%86%99%E5%85%A5bigkey"><span class="nav-number">10.2.7.</span> <span class="nav-text">避免写入bigkey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F"><span class="nav-number">10.2.8.</span> <span class="nav-text">大量key集中过期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98"><span class="nav-number">10.2.9.</span> <span class="nav-text">redis 生产问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">10.2.9.1.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9A"><span class="nav-number">10.2.9.2.</span> <span class="nav-text">缓存击穿：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9A"><span class="nav-number">10.2.9.3.</span> <span class="nav-text">缓存雪崩：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%81%EF%BC%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A72-19"><span class="nav-number">10.2.10.</span> <span class="nav-text">！！数据库和缓存双写一致性2.19</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="nav-number">10.2.10.1.</span> <span class="nav-text">删除缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-13-2-16"><span class="nav-number">10.3.</span> <span class="nav-text">day 13 2.16</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql-%E7%9A%84%E5%A4%8D%E4%B9%A0"><span class="nav-number">10.3.1.</span> <span class="nav-text">mysql 的复习</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql%E4%B8%ADMVCC"><span class="nav-number">10.3.1.1.</span> <span class="nav-text">mysql中MVCC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="nav-number">10.3.1.2.</span> <span class="nav-text">三大日志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-14-2-19"><span class="nav-number">10.4.</span> <span class="nav-text">day 14 2.19</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">10.4.0.1.</span> <span class="nav-text">一条sql语句执行的过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9C%BA%E6%99%AF"><span class="nav-number">10.4.0.2.</span> <span class="nav-text">索引失效的几种场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring"><span class="nav-number">10.5.</span> <span class="nav-text">Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Autowired-%E5%92%8C-Resource"><span class="nav-number">10.5.1.</span> <span class="nav-text">@Autowired 和@Resource</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-%E4%B8%AD%E7%9A%84bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="nav-number">10.5.2.</span> <span class="nav-text">Spring 中的bean是线程安全的吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOP"><span class="nav-number">10.5.3.</span> <span class="nav-text">AOP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">10.5.4.</span> <span class="nav-text">Spring 中涉及的设计模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spring%E4%BA%8B%E5%8A%A1"><span class="nav-number">10.5.5.</span> <span class="nav-text">spring事务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="nav-number">10.5.5.1.</span> <span class="nav-text">事务原理：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">10.6.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="nav-number">10.6.1.</span> <span class="nav-text">消息队列有什么用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%B8%A6%E6%9D%A5%E7%9A%84%E7%BB%B4%E6%8A%A4"><span class="nav-number">10.6.2.</span> <span class="nav-text">消息队列带来的维护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMS%E5%92%8CAMQP"><span class="nav-number">10.6.3.</span> <span class="nav-text">JMS和AMQP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-15-2-20"><span class="nav-number">10.7.</span> <span class="nav-text">day 15 2.20</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rabbitmq"><span class="nav-number">10.8.</span> <span class="nav-text">Rabbitmq</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">10.8.1.</span> <span class="nav-text">死信队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbit-%E6%B6%88%E6%81%AF%E6%80%8E%E4%B9%88%E4%BC%A0%E8%BE%93"><span class="nav-number">10.8.2.</span> <span class="nav-text">rabbit 消息怎么传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbitmq%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="nav-number">10.8.3.</span> <span class="nav-text">rabbitmq的工作模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbitmq%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="nav-number">10.8.4.</span> <span class="nav-text">rabbitmq消息可靠性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbit-%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-number">10.8.5.</span> <span class="nav-text">rabbit 的高可用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rabbit-mq-%E7%9A%84%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B%E9%97%AE%E9%A2%98"><span class="nav-number">10.8.6.</span> <span class="nav-text">rabbit mq 的消息挤压问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-16-2-21"><span class="nav-number">10.9.</span> <span class="nav-text">day 16 2.21</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AARPC%EF%BC%88javaGuide%EF%BC%89%E8%A7%A3%E6%9E%90"><span class="nav-number">10.10.</span> <span class="nav-text">手写一个RPC（javaGuide）解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%91zookeeper%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1"><span class="nav-number">10.10.1.</span> <span class="nav-text">服务端向zookeeper注册服务</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">10.10.1.1.</span> <span class="nav-text">自定义注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%AC%E5%9C%B0%E5%8F%91%E8%B5%B7%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="nav-number">10.10.2.</span> <span class="nav-text">客户端本地发起远程调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%B6%E5%88%B0%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8F%91%E8%B5%B7%E8%B0%83%E7%94%A8%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%BB%99"><span class="nav-number">10.10.3.</span> <span class="nav-text">服务端收到远程调用发起调用并返回结果给</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-17-2-22"><span class="nav-number">10.11.</span> <span class="nav-text">day 17 2.22</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="nav-number">10.11.1.</span> <span class="nav-text">bean 的生命周期：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-18-2-23"><span class="nav-number">10.12.</span> <span class="nav-text">day 18 2.23</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">10.12.1.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">10.12.2.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-19-2-24"><span class="nav-number">10.13.</span> <span class="nav-text">day 19 2.24</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%9A"><span class="nav-number">10.13.1.</span> <span class="nav-text">索引优化：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9A"><span class="nav-number">10.13.2.</span> <span class="nav-text">索引失效：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-20-2-26"><span class="nav-number">11.</span> <span class="nav-text">day 20 2.26</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-%E4%B8%AD%E7%9A%84list%E9%93%BE%E8%A1%A8"><span class="nav-number">11.0.1.</span> <span class="nav-text">redis 中的list链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">11.0.2.</span> <span class="nav-text">压缩列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">11.0.3.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="nav-number">11.0.4.</span> <span class="nav-text">整数集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">11.0.5.</span> <span class="nav-text">跳表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8%E4%B8%8Ehash%E4%B8%8E%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="nav-number">11.0.6.</span> <span class="nav-text">跳表与hash与平衡树比较：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E4%BD%BF%E7%94%A8B-%E6%A0%91%E3%80%81redis%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8"><span class="nav-number">11.0.7.</span> <span class="nav-text">为什么mysql使用B+树、redis使用跳表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#quicklist"><span class="nav-number">11.0.8.</span> <span class="nav-text">quicklist</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#listpack"><span class="nav-number">11.0.9.</span> <span class="nav-text">listpack</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-21-3-1"><span class="nav-number">12.</span> <span class="nav-text">day 21 3.1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">12.0.1.</span> <span class="nav-text">读写锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-22-3-2"><span class="nav-number">13.</span> <span class="nav-text">day 22 3.2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88Spring-IOC%E5%92%8CAOP"><span class="nav-number">13.1.</span> <span class="nav-text">谈谈Spring IOC和AOP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88redis-%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84RDB%E5%92%8CAOF"><span class="nav-number">13.2.</span> <span class="nav-text">谈谈redis 持久化的RDB和AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9A%E8%BF%87%E7%9A%84sql%E4%BC%98%E5%8C%96"><span class="nav-number">13.3.</span> <span class="nav-text">做过的sql优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E3%80%81%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B"><span class="nav-number">13.4.</span> <span class="nav-text">消息重复消费、消息确认、消息挤压</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NIO-reactor"><span class="nav-number">13.5.</span> <span class="nav-text">NIO reactor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E7%86%9F%E6%82%89%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">13.6.</span> <span class="nav-text">谈谈你熟悉的设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88spring-security%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">13.7.</span> <span class="nav-text">谈谈spring security的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88OAuth"><span class="nav-number">13.8.</span> <span class="nav-text">谈谈OAuth</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-23-3-5"><span class="nav-number">14.</span> <span class="nav-text">day 23 3.5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rpc%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95"><span class="nav-number">14.1.</span> <span class="nav-text">rpc的负载均衡算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPI%E6%9C%BA%E5%88%B6"><span class="nav-number">14.2.</span> <span class="nav-text">SPI机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#spi%E5%92%8Capi-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.2.1.</span> <span class="nav-text">spi和api 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java-%E4%B8%ADspi%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.2.2.</span> <span class="nav-text">java 中spi的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">14.2.3.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#springboot-%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">14.3.</span> <span class="nav-text">springboot 的自动装配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%86%99RPC%E4%B8%AD%E7%9A%84SPI"><span class="nav-number">14.4.</span> <span class="nav-text">手写RPC中的SPI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rpc%E4%B8%AD%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%BB%A5%E5%8F%8A%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">14.5.</span> <span class="nav-text">rpc中服务注册以及服务调用是怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%8F%E8%AE%AE%E4%B8%AD%E6%80%8E%E4%B9%88%E5%86%99%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">14.6.</span> <span class="nav-text">协议中怎么写的数据的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">14.7.</span> <span class="nav-text">谈谈虚拟内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day24-3-6"><span class="nav-number">15.</span> <span class="nav-text">day24 3.6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9AOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">15.1.</span> <span class="nav-text">谈谈你对AOP的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1"><span class="nav-number">15.2.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">15.3.</span> <span class="nav-text">谈谈IO多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">15.4.</span> <span class="nav-text">如何用redis实现分布式锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">15.5.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">15.6.</span> <span class="nav-text">redis实现数据一致性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-25-3-7"><span class="nav-number">16.</span> <span class="nav-text">day 25 3.7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hashmap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6%E9%98%88%E5%80%BC%E6%98%AF8"><span class="nav-number">16.1.</span> <span class="nav-text">hashmap为什么链表长度阈值是8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#beanfactory%E5%92%8Cfactorybean"><span class="nav-number">16.2.</span> <span class="nav-text">beanfactory和factorybean</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-26-3-9"><span class="nav-number">17.</span> <span class="nav-text">day 26 3.9</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#threadLocal"><span class="nav-number">17.1.</span> <span class="nav-text">threadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E6%B6%88%E6%81%AF%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E3%80%81%E9%A1%BA%E5%BA%8F%E6%80%A7%E3%80%81%E6%B6%88%E6%81%AF%E6%8C%A4%E5%8E%8B"><span class="nav-number">17.2.</span> <span class="nav-text">消息队列的可靠性、消息重复消费、顺序性、消息挤压</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-27-3-10"><span class="nav-number">18.</span> <span class="nav-text">day 27 3.10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#http%E5%92%8Chttps"><span class="nav-number">18.1.</span> <span class="nav-text">http和https</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#http1-0-http1-1-http2-0-http3-0"><span class="nav-number">18.2.</span> <span class="nav-text">http1.0 http1.1 http2.0 http3.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sql-%E4%B8%ADlimit"><span class="nav-number">18.3.</span> <span class="nav-text">sql 中limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="nav-number">18.4.</span> <span class="nav-text">java初始化顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-%E5%91%BD%E4%BB%A4"><span class="nav-number">18.5.</span> <span class="nav-text">linux 命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-28-3-12"><span class="nav-number">19.</span> <span class="nav-text">day 28 3.12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">19.1.</span> <span class="nav-text">多线程的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netty-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%82%E6%AD%A5"><span class="nav-number">19.2.</span> <span class="nav-text">netty 为什么要用异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO-NIO%E8%AE%B2%E8%AE%B2"><span class="nav-number">19.3.</span> <span class="nav-text">BIO NIO讲讲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#netty%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%EF%BC%9AReactor%E6%A8%A1%E5%9E%8B"><span class="nav-number">19.4.</span> <span class="nav-text">netty的线程模型：Reactor模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-29-3-13"><span class="nav-number">20.</span> <span class="nav-text">day 29 3.13</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cpu%E5%8D%A0%E7%94%A8%E9%A3%99%E5%8D%87%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9A%E7%A9%BA%E8%BD%AE%E8%AF%A2%E3%80%81%E7%A9%BA%E5%BE%AA%E7%8E%AF"><span class="nav-number">20.1.</span> <span class="nav-text">cpu占用飙升怎么处理：空轮询、空循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#full-gc-%E7%BB%8F%E5%B8%B8%E5%8F%91%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E6%8E%92%E6%9F%A5"><span class="nav-number">20.2.</span> <span class="nav-text">full gc 经常发生的原因和排查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">20.3.</span> <span class="nav-text">bean的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0StringTable"><span class="nav-number">20.4.</span> <span class="nav-text">字符串常量池StringTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">20.5.</span> <span class="nav-text">怎么保证线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">20.6.</span> <span class="nav-text">进程间通信的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">20.7.</span> <span class="nav-text">进程如何分配空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%8F%E4%B8%AA%E8%BF%9B%E7%A8%8B%E6%89%80%E5%8D%A0%E7%94%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%86%85%E5%AD%98"><span class="nav-number">20.8.</span> <span class="nav-text">每个进程所占用的最大内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="nav-number">20.9.</span> <span class="nav-text">什么是零拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-30-3-14"><span class="nav-number">21.</span> <span class="nav-text">day 30 3.14</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E7%9A%84spi"><span class="nav-number">21.1.</span> <span class="nav-text">java 的spi</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-1"><span class="nav-number">21.2.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E4%B8%AD%E5%A4%9A%E4%B8%AA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">21.3.</span> <span class="nav-text">synchronized 在一个类中多个成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88-1"><span class="nav-number">21.4.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashmap1-7-%E5%92%8C1-8"><span class="nav-number">21.5.</span> <span class="nav-text">hashmap1.7 和1.8</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-1"><span class="nav-number">21.6.</span> <span class="nav-text">类加载器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-31-3-15"><span class="nav-number">22.</span> <span class="nav-text">day 31 3.15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E8%83%BD%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84socket%E6%9C%80%E5%A4%A7%E6%98%AF1024"><span class="nav-number">22.1.</span> <span class="nav-text">一个进程能打开的文件句柄socket最大是1024</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql-%E7%9A%84%E6%85%A2%E6%9F%A5"><span class="nav-number">22.2.</span> <span class="nav-text">mysql 的慢查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%98%AF%E5%90%A6%E8%B5%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">22.3.</span> <span class="nav-text">联合索引是否走索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E5%A0%86"><span class="nav-number">22.4.</span> <span class="nav-text">索引下堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADdate-datetime-timeStamp"><span class="nav-number">22.5.</span> <span class="nav-text">数据库中date datetime timeStamp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">22.6.</span> <span class="nav-text">拥塞控制</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/HexoBlog/js/utils.js"></script>

<script src="/HexoBlog/js/main.js"></script>

<script src="/HexoBlog/js/header-shrink.js"></script>

<script src="/HexoBlog/js/back2top.js"></script>

<script src="/HexoBlog/js/dark-light-toggle.js"></script>





    
<script src="/HexoBlog/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/HexoBlog/js/left-side-toggle.js"></script>

<script src="/HexoBlog/js/libs/anime.min.js"></script>

<script src="/HexoBlog/js/toc.js"></script>

    
</div>



</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="lj">
    
    <title>
        
            准备2 |
        
        LjBlog
    </title>
    
<link rel="stylesheet" href="/HexoBlog/css/style.css">

    <link rel="shortcut icon" href="/HexoBlog/images/logo.svg">
    
<link rel="stylesheet" href="/HexoBlog/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"ljkk23.github.io","root":"/HexoBlog/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/HexoBlog/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                LjBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">准备2</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/HexoBlog/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">lj</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-11-30 17:06:49</span>
        <span class="mobile">2022-11-30 17:06</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/categories/%E5%87%86%E5%A4%87/">准备</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/tags/%E5%87%86%E5%A4%87/">准备</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><h5 id="1-存储引擎是什么，"><a href="#1-存储引擎是什么，" class="headerlink" title="1.存储引擎是什么，"></a>1.存储引擎是什么，</h5><p>​    在百度百科上是这样说的：</p>
<pre class="line-numbers language-none"><code class="language-none"> MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。

 例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持[事务处理]的数据库(以确保事务处理不成功时数据的回退能力)。

这些不同的技术以及配套的相关功能在MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>总结：</p>
<p>​    1.mysql根据不同的使用者的不同需求，在存储机制、索引技巧以及锁等方面有不同的实现，这些不同的技术配套组合起来就称为存储引擎。</p>
<p>​    2.存储引擎是基于插件式架构，支持多重存储引擎，因为存储引擎是基于表的，所以我们甚至可以为不同的数据库设置不同的存储引擎，自己也可以根据mysql的标准存储引擎实现接口编写一个自己的存储引擎</p>
<h5 id="2-mysql中常见的存储引擎"><a href="#2-mysql中常见的存储引擎" class="headerlink" title="2.mysql中常见的存储引擎"></a>2.mysql中常见的存储引擎</h5><p>​     mysql 5.5之前的默认存储引擎是 MyISAM,MyISAM的性能也不错，在全文索引、压缩、空间函数等都体现不错，但是因为不支持事务和行级锁，而且崩溃后无法安全恢复数据，所以就在mysql5.5之后，取而代之的是InnoDB，对比一下两个常见的存储引擎：</p>
<p>1.是否支持行级锁：</p>
<p>  MyISAM只支持表级锁，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。所以在并发的时候就知道InnoDB的优势了</p>
<p>2.是否支持事务</p>
<p>MyISAM不提供支持事务</p>
<p>​    innoDB支持事务，实现了sql标准的四个隔离级别，默认使用的是可重复读，可以解决幻读。具体事务级别看后面</p>
<p>3.是否支持外键</p>
<p>​    myISAM不支持外键，innoDB支持外键。</p>
<p>​    外键的好处能对数据库的维护数据一致性有很好的帮助，但是在阿里的开发手册中明确提出禁止用外键，所以我们通常在开发项目的时候不再数据库层面使用外键，而将其在应用层实现，不过，到底用不用还是得看实际的项目</p>
<p>4.是否支持数据库崩溃之后数据的安全恢复</p>
<p>​    myISAM不支持。而mysql支持，mysql这个恢复i的过程基于redo log</p>
<p>5.索引的实现不一样</p>
<p>​    虽然都是用的B+树作索引，myISAM是索引文件而数据文件分离，innoDB数据文件就是索引文件，具体看后面</p>
<h5 id="数据库的事务隔离级别"><a href="#数据库的事务隔离级别" class="headerlink" title="数据库的事务隔离级别"></a>数据库的事务隔离级别</h5><p>（1）读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>问题：</p>
<p>​    在一个事务a开启之后数据为2，如果另一个事务b修改了这数据3，a再读取这数据就为3，但是b事务回滚了，数据又变成了2,这里就出现了脏读</p>
<p>（2）读已提交：可以解决脏读，在一个事务开启时，另一个事务修改的数据必须提交之后才能被其他事务读到</p>
<p>（3）可重复读：： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
<p>解决不可重复读：</p>
<p>​        当b事务提交之后，a再次读这个数据就为3了，但是之前b事务还没有提交的时候，a就读取了这个数据为2,这样就造成了前后读的数据不一致，这就是不可重复读，所以如果是这个级别，之后再读取这个数据就还会是2。</p>
<p>问题：</p>
<p>​    但是会出现幻读，和可重复读差不多，只不过这次b事务不是去修改a读过的数据，而是增加或修改了其他数据，导致a事务再次去读的时候，就出现了两条数据（如果之前是一条数据），</p>
<p>解决幻读：</p>
<ol>
<li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li>
</ol>
<p>（4）可串行化：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<p>总结：</p>
<p>1.因为隔离级别越低，事务请求的锁越少，所以可串行化对并发量不太友好，所以mysql中innoDB默认隔离级别是不可重复读且解决了幻读的问题，虽然一般的数据库是读已提交，但是innoDB的可重复读不会有任何性能损失。</p>
<p>2.innoDB解决幻读：通过MVCC机制快照读、使用Next-key Lock（Record Lock+Gap Lock）实现当前读</p>
<h5 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql 索引"></a>mysql 索引</h5><p>1.索引是什么：</p>
<p>索引是一种快速查找数据和检索数据的数据结构</p>
<p>2.索引的优缺点：</p>
<p>优点：</p>
<ul>
<li>大大加快了检索数据的速度</li>
<li>如果建立唯一性索引，还可以保证数据的唯一性</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引需要空间，耗费空间</li>
<li>创建和维护索引也需要一定的耗费时间，在对表进行增删查改的时候，有索引就需要维护索引，降低sql的执行效率</li>
</ul>
<p>3.索引底层数据结构</p>
<p>（1）hash表，虽然hash表查询速度很快，但是因为hash不支持顺序和范围查询，而且每次IO只能取一个数据</p>
<p>（2）b树和B+树：</p>
<p>​    b树的所有节点都存放数据和key,这就导致了枝干节点的能够存放key的存储空间就比完全存放key的存储空间小，所以就导致整个树存储的数据比B+树少。</p>
<p>​    b+树叶子节点有一条链表，在范围查询的时候比b树少一次IO</p>
<p>​    B+树检索效率稳定，因为数据都在叶子节点</p>
<p>4.myISAM和innoDB都是用的B+树</p>
<p>但是不同点：</p>
<p>​    myISAM用的是非聚簇索引，即叶子节点存放的是data的指针，找到叶子节点之后，需要多一次IO去读取真正的数据</p>
<pre><code> innoDb用的是聚簇索引，叶子节点直接存放的是data。
</code></pre>
<p>5.索引的类型</p>
<p>主键索引：拿主键作为索引，通过主键索引找到叶子节点存放的就是data</p>
<p>二级索引：通过二级索引找到叶子节点，存放的就是主键的信息，然后再通过主键去找到data</p>
<p>聚簇索引优缺点：</p>
<p>优点：</p>
<p>​    （1）查询data时速度更快，比较与非聚簇少一个IO操作</p>
<p>​    （2）<strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</p>
<p>缺点：</p>
<p>​    数据更改，索引就要更改，代价较大，非聚簇索引的数据改时，索引不用改，</p>
<p>非聚簇：</p>
<p>优点：</p>
<p>​    数据更改，索引的树不用更改</p>
<p>缺点：</p>
<p>​     可能会二次查询。</p>
<p>演示innoDB聚簇索引的主键索引和二级索引，和myIsam的非聚簇索引的主键索引和二级索引</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/suoying.png"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用”where id &#x3D; 14”这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</li>
<li>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</li>
</ol>
<p>MyISM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
<p><strong>选择合适的字段创建索引</strong></p>
<ul>
<li>经常查询的字段</li>
<li>不为空对象的字段</li>
<li>作为条件的字段</li>
<li>频繁作为连接的字段</li>
<li>频繁更新的不适合作为索引</li>
</ul>
<p>​    innoDB选择默认是主键作为索引，如果没有主键就找一个唯一且不为null的字段，如果都没有，就自己生成一个6字节的索引，所以主键一般不为uuid或字符串这种难排序的，最好是自增的，因为这样方便插入和排序。</p>
<h5 id="为什么主键通常建议使用自增id"><a href="#为什么主键通常建议使用自增id" class="headerlink" title="为什么主键通常建议使用自增id"></a><strong>为什么主键通常建议使用自增id</strong></h5><p>​    因为使用自增 id 可以避免页分裂，因为聚簇索引的物理存放顺序和索引顺序是一致的，只要索引相邻，对应的数据也相邻，如果主键不是自增id,那么就会不断的调整数据的物理分页。为什么呢？一下是解释</p>
<p>​    mysql 在底层又是以数据页为单位来存储数据的，一个数据页大小默认为 16k，当然你也可以自定义大小，也就是说如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。</p>
<p>​    如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。</p>
<p>​    如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。</p>
<p>​    当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上。</p>
<p>对主键 id 还有一个小小的要求，在满足业务需求的情况下，尽量使用占空间更小的主键 id，因为普通索引的叶子节点上保存的是主键 id 的值，如果主键 id 占空间较大的话，那将会成倍增加 mysql 空间占用大小</p>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h5 id="MyISAM-和-InnoDB-如何选择？"><a href="#MyISAM-和-InnoDB-如何选择？" class="headerlink" title="MyISAM 和 InnoDB 如何选择？"></a>MyISAM 和 InnoDB 如何选择？</h5><p>​    一般来说我们都选择innoDB,因为innoDB支持事务、行锁、崩溃后数据能够安全恢复，这几个myISAM都不能做到，但是这几个又是我们日常业务的必须，其实innoDB的速度并不一定比myISAM慢，比如聚簇索引就比非聚簇索引少一层IO操作</p>
<h5 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="MySQL 查询缓存"></a>MySQL 查询缓存</h5><p>​    在mysql8之前有，查询数据之前，会先查询缓存，但是在mysql8之后就移除了这个功能，原因是虽然缓存能够提高查询速度，但是维护和更新缓存无疑会增加带来额外开销，每一次操作之后都会做一次缓存操作，而且更新缓存和缓存不击中的情况比较多：（1）查询条件不同（2）缓存的数据的所在表更改（3）查询条件中函数以及临时表都不会缓存。</p>
<h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h5><p>参考：<a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html#%E4%BB%80%E4%B9%88%E6%98%AFmvcc" >https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html#%E4%BB%80%E4%B9%88%E6%98%AFmvcc<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="MVCC-是什么"><a href="#MVCC-是什么" class="headerlink" title="MVCC 是什么"></a>MVCC 是什么</h6><p>​    MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。是一种控制并发的方法，是一种理念，在数据库管理系统中，实现对数据库的并发，在编程语言中实现事务。</p>
<h6 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h6><p>​    在了解MVCC之前，先知道什么是当前读和快照读</p>
<p>​    当前读：读取的是数据的最新版本，读取时会对数据进行加锁，例如：像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读</p>
<p>​    快照读：不加锁的读就是快照读，之所以会出现快照读，是因为提高并发，所以快照读基于多版本并发，他避免了加锁，因为是多版本，所以难免会读到数据的旧版本。</p>
<p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<h6 id="MVCC-解决的问题以及好处"><a href="#MVCC-解决的问题以及好处" class="headerlink" title="MVCC 解决的问题以及好处"></a>MVCC 解决的问题以及好处</h6><p>数据库并发场景?</p>
<p>有三种, 分别为：</p>
<ul>
<li><strong>读-读</strong>：不存在任何问题，也不需要并发控制</li>
<li><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><strong>写-写</strong>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p>MVCC带来的好处是？</p>
<p>MVCC多版本并发控制是一种解决读写冲突的无锁非阻塞，他为每一个事务分配一个单向增长的时间戳，版本与该时间戳关联，读操作（快照读）只读取该事务开始的版本</p>
<p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p>
<h6 id="MVCC和当前读、快照读的关系"><a href="#MVCC和当前读、快照读的关系" class="headerlink" title="MVCC和当前读、快照读的关系"></a>MVCC和当前读、快照读的关系</h6><p>​    准确的说，MVCC只是一个理念，所以我们需要在数据库中实现，为了在数据库中实现这么一个理念，快照读就出来了，他解决了在读写问题中的阻塞问题。但其实MVCC整套理念的实现不仅只有一个快照读，MVCC模型的实现是靠4个隐式字段和undo log和readView实现的。</p>
<h6 id="4个隐式字段"><a href="#4个隐式字段" class="headerlink" title="4个隐式字段"></a>4个隐式字段</h6><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<ul>
<li><strong>DB_ROW_ID</strong> 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li><strong>DB_TRX_ID</strong> 6byte, 最近修改(修改&#x2F;插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong> 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
<li><strong>DELETED_BIT</strong> 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p>这里注意最后一个字段，</p>
<h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><p>不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p>
<h6 id="read-view（读视图）"><a href="#read-view（读视图）" class="headerlink" title="read view（读视图）"></a>read view（读视图）</h6><p>就是在事务快照读的时候，能够读到的数据是事务的哪些版本。</p>
<p>read view 有三个全局属性，这三个属性都是全局的</p>
<p><strong>trx_list</strong> 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID</p>
<p><strong>up_limit_id</strong> 记录trx_list列表中事务ID最小的ID</p>
<p><strong>low_limit_id</strong> ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</p>
<p>生成read view流程：</p>
<ul>
<li>1.在某一个事务中快照读取某个数据时，首先看该数据的事务的隐式字段事务id是否小于<strong>up_limit_id</strong> （记录trx_list列表中事务ID最小的ID），如果是，就说明这个是已经提交的数据，可以读</li>
<li>如果不小于当前活跃事务的最小id,就判断是否大于<strong>low_limit_id</strong>，如果是，说明该事务不符合可见性</li>
<li>如果不大于low_limit_id，说明该事务处于活跃中，则去该事务的undo log中找事务id,再次通过流程判断，直到符合可见性</li>
</ul>
<h6 id="MVCC相关问题：RR和RC级别下的read-view"><a href="#MVCC相关问题：RR和RC级别下的read-view" class="headerlink" title="MVCC相关问题：RR和RC级别下的read view"></a>MVCC相关问题：RR和RC级别下的read view</h6><p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View</strong>。</p>
<p>所以RC会出现不可重复读，RR会解决这个问题</p>
<h2 id="day-3-12-5"><a href="#day-3-12-5" class="headerlink" title="day 3 12.5"></a>day 3 12.5</h2><h5 id="mysql-锁"><a href="#mysql-锁" class="headerlink" title="mysql 锁"></a>mysql 锁</h5><h6 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h6><p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h6 id="行锁的使用的注意事项"><a href="#行锁的使用的注意事项" class="headerlink" title="行锁的使用的注意事项"></a>行锁的使用的注意事项</h6><p>​    innoDB的行锁的是针对索引字段，表极锁是针对非索引字段，所以当我们执行update delete语句时，如果where未命中索引或者索引失效的话，就会全表的所有行记录进行加锁，所以这里要注意。</p>
<p>​    这里需要注意的是，虽然我们用了索引，但是有些时候还会走全局扫描，所以这就是后面mysql优化器</p>
<h6 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h6><p>​    不论是表锁还是行锁，都有共享锁和排他锁，由于MVCC的存在，所以一般的select语句是不会加任何锁的，可以显式的加锁查询</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//共享锁</span>
select <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lock in share mode
 <span class="token comment">//排他锁</span>
    select <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> update   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>意向锁就是，在加表锁的时候，肯定需要去判断该表是否加了行锁，那怎么判断呢，如果一行一行的去遍历，性能太差，优秀的程序员怎么能容忍这种事情发生呢，所以就有了一个意向锁，在加共享锁或者排他锁之前，需要首先获得意向锁，比如加共享锁时，需要首先获得该记录的意向共享锁</p>
<h6 id="innoDb-有哪些行锁"><a href="#innoDb-有哪些行锁" class="headerlink" title="innoDb 有哪些行锁"></a>innoDb 有哪些行锁</h6><p>mysql 支持三种行锁</p>
<ul>
<li>记录锁（record lock），属于单个行的锁</li>
<li>间隙锁（Gap lock）：锁定一个范围，不包括记录本身</li>
<li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>mysql innoDB的RR是可以解决幻读的，本来一般的事务隔离级别为RR都不会解决幻读的，mysql innodb能解决是以下两种情况：</p>
<ul>
<li>快照读：通过mvcc机制保证不出现幻读，核心就是生成read view</li>
<li>当前读：使用next-key lock 来加锁解决幻读</li>
</ul>
<h5 id="mysql-三大日志"><a href="#mysql-三大日志" class="headerlink" title="mysql 三大日志"></a>mysql 三大日志</h5><h6 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h6><p>​    redo log （重做日志）是innodb独有的，这也是前面说过的innoDB相比于myISAM的优势：能够在宕机后安全的恢复数据，就是基于这个实现的</p>
<p>​    因为mysql 中的数据是以页为单位的，所以当你查询一条记录的时候，会把记所在的一页数据都加载到出来，放入到    BUffer pool，然后后续查找先去Buffer pool 中查找，包括更新数据也是先更新Buffer pool中的数据，然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/03.png"></p>
<p><strong>redo log的刷盘时机</strong></p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略</p>
<p><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</p>
<p><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</p>
<p><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p>redo log 是由一组日志文件组</p>
<h6 id="redo-log小结"><a href="#redo-log小结" class="headerlink" title="redo log小结"></a>redo log小结</h6><p>​    上面讲了redo log 的作用机制、刷盘时机以及存储形式。现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p> 这里就有几个不同：</p>
<ul>
<li>一是：每次修改数据页可能就修改了几byte，这样就刷盘的话，会浪费资源</li>
<li>二是：而且数据页的刷盘是随机读写，因为如果主键索没有用自增id,就有可能就造成数据页的刷盘的随机读写，性能很低，而日志文件都是一行记录占用byte少，而且日志文件是顺序读写，大大增强了性能，</li>
</ul>
<h6 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h6><p>​    redo log 是属于物理日志，记录的是在“某个数据页上做了什么修改”，属于innoDB存储引擎的;</p>
<p>​    而bin log 属于归档日志，记录的是sql语句或者说记录的是sql语句的逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于mysql server层的，不管用什么存储引擎，只要表数更改了，就会产生bin log</p>
<p>​    bin log 到底是干嘛的，有什么作用： binlog 主要用与数据库的备份、主从复制等，依靠bin log 来同步数据库，保持数据一致性。</p>
<p><strong>记录格式</strong></p>
<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><p><strong>statement</strong>：记录的是sql的原语句：</p>
</li>
<li><p><strong>row</strong>：记录的增强版的sql,来保持数据一致性，比如要主从之间复制当地时间，所以就需要在主机时，就将sql中的值修改为主机的获取当地时间。</p>
</li>
<li><p><strong>mixed</strong>：row这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>​    <code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p>​        <code>    binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>​    虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>​    首先我们先整体知道一下执行语句更新的时候，整体流程：在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/01-20220305234816065.png"></p>
<p> 所以想象这样一个场景，当redo log 写完之后，当写入bin log 时，数据库宕机了，这样就会导致bin log 并没有成功写完，所以就导致了从机通过bin log 同步数据的时候，和主机数据不一致（因为主机通过redo log 已经更改了数据）。</p>
<p>​    所以怎么解决这样一个问题呢，这明显是一个事务问题，所以我们这里就用了两阶段提交的方法，在更新数据之后，先将写redo log事务标记为prepare阶段，然后在写入bin log 之后，将redo log 事务标记为commit,然后就更新主机数据。这里就保证了数据的一致性。</p>
<p>那么对于这个流程，通过以下问题进一步深刻了解：</p>
<p>（1）有了bin log 为什么还需要redo log</p>
<ul>
<li>bin log 不知道数据库从哪一时刻丢了数据，所以只能从备份点开始对bin log 记录恢复数据，比较耗时，而redo log有一个check point</li>
<li>bin log 需要手动恢复数据，redo log是自动恢复</li>
<li>redo log 的wal+写缓存+异步刷盘提高IO利用</li>
</ul>
<p>（2）有了redo log 为什么还需要bin log</p>
<ul>
<li>bin log 是server 层的，redo log 是存储引擎innoDB的，其他存储引擎无法通过redo log 恢复</li>
<li>主从机之间是通过bin log复制。</li>
</ul>
<p>（3）保证数据一致性的流程</p>
<ul>
<li>如果在prepare阶段写完之后，在写bin log时宕机从机不会更改，此时重启mysql,通过redo log 恢复数据，看到redo log 事务的处于prepare阶段然后去判断bin log 是否有对应记录，因为还没有写完整，所以不会更改该redo log,这样主从就一致</li>
<li>如果在写bin log 之后，在提交的之前宕机，此时重启mysql,如果redo log是prepare,去判断bin log ，发现是完整的，然后就会更改主库</li>
<li>至于有了第二种情况，为什么还需要有commit,这是为了性能，因为每次都去判断bin log 难免效率太低下，所以一旦是commit,就直接提交</li>
</ul>
<h5 id="sql语句执行流程"><a href="#sql语句执行流程" class="headerlink" title="sql语句执行流程"></a>sql语句执行流程</h5><p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/13526879-3037b144ed09eb88.png"></p>
<p>以下面这条简单的 SQL 语句为例，我们来解释下执行器和 InnoDB 存储引擎在更新时做了哪些事情：</p>
<pre class="line-numbers language-none"><code class="language-none">updatetablesetage&#x3D;age+1whereid&#x3D;1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol>
<li>执行器：找<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D" >存储引擎<i class="fas fa-external-link-alt"></i></a>取到 id &#x3D; 1 这一行记录</li>
<li>存储引擎：根据主键索引树找到这一行，如果 id &#x3D; 1 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%B1%A0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D" >内存池<i class="fas fa-external-link-alt"></i></a>，然后再返回</li>
<li>执行器：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</li>
<li>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务<br>注意不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，[commit 命令](<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=commit" >https://www.zhihu.com/search?q=commit<i class="fas fa-external-link-alt"></i></a> 命令&amp;search_source&#x3D;Entity&amp;hybrid_search_source&#x3D;Entity&amp;hybrid_search_extra&#x3D;{“sourceType”%3A”answer”%2C”sourceId”%3A2280710259})就执行成功了。</li>
<li>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</li>
<li>执行器：调用存储引擎的提交事务接口</li>
<li>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</li>
</ol>
<h2 id="day4-12-12"><a href="#day4-12-12" class="headerlink" title="day4 12.12"></a>day4 12.12</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>​    确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<p>​    有六种实现方式：饿汉式、枚举式、懒汉式、同步锁、双重校验锁、静态内部类</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/2_singleton_1.png"></p>
<p>​    前面两种是初始化就加载对象，这种就需要满足初始化速度快而且占用内存小，不然会造成应用启动太慢。所以如果初始化速度慢或者占用内存大，就需要延迟加载，在初始化的时候不加载，而是使用的时候再加载，这样就节约了资源。</p>
<p>​    哪些时候需要初始化就加载，比如电商中的一些热点数据访问较多的，所以就可以提前加载，免得第一次访问还要去加载，而当有些数据可能很久都不会用到，这些就可以用到的时候再加载，避免了没用到时的资源浪费</p>
<p>（1）饿汉式：因为有new，所以就会直接加载类，后面会有类加载的时机，因为在初始化时就加载，所以不会存在线程安全问题。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（2）枚举：枚举的静态代码块本身就根据jvm的类加载机制加载，所以只有一次加载，因为是静态变量，所以存在于类中，不会因对象而改变，所以这里也是线程安全的</p>
<p>（3）懒汉式（线程不安全的版本）：因为多线程，所以if (uniqueInstance &#x3D;&#x3D; null) {这一段代码会有很多个线程进入，就造成了线程不安全</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（4）懒汉式同步锁：因为加了synchronized,所以性能消耗大</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（5）双重校验锁（DCL）：</p>
<p>这是在懒汉式同步锁上因为加了synchronized关键字导致性能下降的优化，加锁操作只需要对实例化那部分的代码进行，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：（1）这里为什么要双重校验的，因为是多线程，所以进入第一个if的有很多线程，如果不要synchronized里面的if判断，那么线程都会最终执行uniqueInstance &#x3D; new Singleton();只是拿到锁的先执行，后来的就后执行，所以这里就不是单例模式了。</p>
<p>​            （2）这里的实例必须用volatile修饰，因为uniqueInstance &#x3D; new Singleton();这一句是分为三个步骤执行的</p>
<ul>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向分配的内存空间</li>
</ul>
<p>但是在jvm的优化下，有可能会产生指令重排，就会出现1-》3-》2的顺序，所以这时如果在执行了3还未执行2的时候，来了新的线程判断对象不为空，就会直接返回给调用方，但是因为此时还未执行2初始化对象，所以这个时候返回给调用方的对象是不正确的，就会导致出错，所以这里必须使用volatile来禁止指令重排</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/20200425180018774.png"></p>
<p>（6）静态内部类：因为初始化在加载外部类的时候，是不会加载内部类的（静态内部类就属于被动引用的行列），所以就实现了延迟加载，又因为这里getInstantce时并没有去new,而是去获得内部的变量，这时就加载该内部类，有因为是静态内部类，所以在jvm加载时自动就保证了线程安全。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>使用单例模式的好处</strong> :</p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>​    工厂模式分为三种：简单工厂、工厂方法、抽象工厂。</p>
<p>（1）简单工厂：就是将实例化的操作放在一个类来实现，调用方不用在意实例化的类的内部具体实现，只需要按照规则使用new对象即可。</p>
<p>工厂类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>dev<span class="token operator">-</span>spec<span class="token operator">/</span>pattern<span class="token operator">/</span><span class="token number">3_</span>simple_factory<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用方：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">SimpleFactory</span> simpleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Product</span> product <span class="token operator">=</span> simpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// do something with the product</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>dev<span class="token operator">-</span>spec<span class="token operator">/</span>pattern<span class="token operator">/</span><span class="token number">3_</span>simple_factory<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（2）工厂方法：生成一个接口，由子类去选择实例化哪个对象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 定义一个抽象的咖啡工厂
 * @author Lsj
 */</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>
    
    <span class="token comment">/**
     * 生产可制造的咖啡
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 中国咖啡工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChinaCoffeeFactory</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Cappuccino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 美国咖啡工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericaCoffeeFactory</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Americano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 工厂方法测试
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryMethodTest</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Coffee</span> coffee <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coffee<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">CoffeeFactory</span> chinaCoffeeFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChinaCoffeeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chinaCoffees <span class="token operator">=</span> chinaCoffeeFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中国咖啡工厂可以生产的咖啡有："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>chinaCoffees<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CoffeeFactory</span> americaCoffeeFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericaCoffeeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> americaCoffees <span class="token operator">=</span> americaCoffeeFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"美国咖啡工厂可以生产的咖啡有："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>americaCoffees<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（3）抽象工厂：定义一系列有关的接口：也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 抽象的饮料产品家族制造工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">/**
     * 制造咖啡
     * @return
     */</span>
    <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * 制造茶
     * @return
     */</span>
    <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * 制造碳酸饮料
     * @return
     */</span>
    <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 中国饮品工厂
 * 制造咖啡与茶
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChinaDrinksFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MilkTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 美国饮品制造工厂
 * 制造咖啡和碳酸饮料
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericaDrinksFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CocaCola</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 抽象工厂测试类
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactoryTest</span> <span class="token punctuation">&#123;</span>
    
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Drink</span> drink<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>drink <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品：--"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品："</span> <span class="token operator">+</span> drink<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">AbstractDrinksFactory</span> chinaDrinksFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChinaDrinksFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span> coffee <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Tea</span> tea <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Sodas</span> sodas <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中国饮品工厂有如下产品："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>tea<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>sodas<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">AbstractDrinksFactory</span> americaDrinksFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericaDrinksFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        coffee <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tea <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sodas <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"美国饮品工厂有如下产品："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>tea<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>sodas<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="建造器模式"><a href="#建造器模式" class="headerlink" title="建造器模式"></a>建造器模式</h5><p>​    当我们需要实例化一个比较复杂类，而且还要根据要求实例化不同结构和不同内部状态的对象时，我们可以用类将其不同的实例化逻辑封装，这些类就叫建造者。</p>
<p>建造者分为四种角色：</p>
<ul>
<li>Product(产品类) :我们具体需要生成的类对象</li>
<li>Builder(抽象建造者类)：为我们需要生成的类对象，构建不同的模块属性，即：公开构建产品类的属性，隐藏产品类的其他功能</li>
<li>ConcreteBuilder(具体建造者类)：实现我们要生成的类对象</li>
<li>Director(导演类)：确定构建我们的类对象具体有哪些模块属性，在实际应用中可以不需要这个角色，直接通过client处理</li>
</ul>
<p>在电商中有多种不同类型的商品 <strong>普通实物商品</strong>，<strong>电子卡券商品</strong>，<strong>虚拟视频学习商品</strong> 等多种不同的商品，他们都是商品但是他们的属性却不一样，电子卡券：独有券码，学习视频：独有视频链接等。</p>
<p>具体:<a class="link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h7iEyxgN34FPn191S8qUpA" >https://mp.weixin.qq.com/s/h7iEyxgN34FPn191S8qUpA<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>​    原型模式出现的原因：场景：当我们实例化对象时需要耗费很多资源以及硬件密集型操作而且已有实例对象与新对象的各方面结构或者状态一致的话，我们可以通过克隆来产生新对象。</p>
<p>​    假设现在我们有这么一种场景，公司搞一场活动有五万个商品参加此次活动，我们需要从后台能定时同步每个商品的销量，方便我们为后面的活动做商品分析，我们要怎么处理这个销量同步问题？</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/clone.png"></p>
<p>​    这里设计浅拷贝和深拷贝。其实在其他的地方我们可以用到原型模式，比如我们在发松活动的PUSH通知，针对平台百万、千万、甚至上亿的用户发送通知的时候通知的内容基本都是一样的只是推送用户不一样或者有些特别字段值的小改动，那我们这里就可以用原型模式来做，同时开启多线程来做push，需要注意的是这里的线程安全问题，所以在每个线程内部去做copy对象。在一般情况下是不建议用这种模式的除非创建的对象成本特别大，或者在一些特殊场景使用</p>
<h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><p>​    这个模式充分体现了设计原则中的最少知道原则，也就是说客户对象所需要交互的对象应当尽可能少。</p>
<p>​    外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。</p>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。</p>
<p>​    例如spring mvc中的DispatcherServlet根据请求信息调用handlermappering,然后由handlerAadpter对目标类适配，就解决了不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。</p>
<h2 id="day-5-12-13"><a href="#day-5-12-13" class="headerlink" title="day 5 12.13"></a>day 5 12.13</h2><h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>​    就是将抽象和实现分开，某些类型由于自身的逻辑，它具有两个或多个维度的变化，</p>
<ul>
<li>比如在电脑商城中有分类</li>
</ul>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/qiaojie.png"></p>
<p>我们用代码实现就需要台式电脑和笔记本继承电脑，然后华硕、小米继承台式以及继承笔记本，那这时增加了平板电脑（在电脑类型维度上变化），此时就需要增加华硕、小米继承平板电脑，这就导致了不是一个维度变化。还有这是增加了索尼品牌，也需要增加。所以我们这里如果根据桥接模式，就分为品牌和电脑类型，那么增加了电脑类型就只修改电脑类型，不会影响品牌。</p>
<ul>
<li>比如在driver驱动程序，有mysql的driver和OracleDriver，那么根据桥接模式实现，实现和抽象分开，driver和drivermanager分开，就能实现这种在driver和drivermanager维度变化互不影响</li>
</ul>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h5><p>​    什么时候需要用到组合模式，当你想要将对象组合成树形结构，使单个对象和组合对象具有一致性的时候，这个时候就需要用到组合模式。</p>
<p>​    组合模式有三个角色：</p>
<ul>
<li>一个是统一的对象声明接口：对象都需要实现该接口。</li>
<li>一个是定义有枝节点行为，用来存储子部件。</li>
<li>一个是叶子节点，就是没有子节点</li>
</ul>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><p>​    享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。比如我们的jdbc连接池，作为共享的对象，其中一个特点就是，该对象的某些属性值是相同的，那么就可以用享元模式，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><p>就是在装饰一个功能时，给被装饰者的功能加上对应的处理</p>
<h4 id="行为性设计模式"><a href="#行为性设计模式" class="headerlink" title="行为性设计模式"></a>行为性设计模式</h4><h5 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h5><p>将请求和接收方解耦，让多个接收对象都能够处理该请求，将这些对象串成一条链，并沿着该请求传递请求，直到链上某个对象处理该请求为止。</p>
<p>​    优点：</p>
<ul>
<li>增加新的请求处理类很方便。</li>
<li>降低耦合度。它将请求的发送者和接收者解耦。</li>
</ul>
<p>使用场景：SpringMVC中的 <strong>ServletFilter</strong>以及<strong>SpringInterceptor</strong>，</p>
<p>自己实现一个责任链设计模式来实现日志打印，不同的信息调用同一个接口，来实现日志打印的不同效果。</p>
<p>INFO打印在console,DEBUG打印在file中等等</p>
<p><a class="link"   target="_blank" rel="noopener" href="http://www.bjpowernode.com/shejimoshi/1599.html" >http://www.bjpowernode.com/shejimoshi/1599.html<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>​    当一个对象发现变化时，同时能够通知到与他相关的对象，当一个对象的状态发生改变时，已经登记的其他对象能够观察到这一改变从而作出自己相对应的改变。通过这种方式来达到减少依赖关系，解耦合的作用。</p>
<ul>
<li>Subject（主题）: 主要由类实现的可观察的接口，通知观察者使用attach方法，以及取消观察的detach方法。</li>
<li>ConcreteSubject（具体主题）: 是一个实现主题接口的类，处理观察者的变化</li>
<li>Observe（观察者）: 观察者是一个由对象水岸的接口，根据主题中的更改而进行更新。</li>
</ul>
<p>类似与消息队列的原理</p>
<p>​    熟悉JDK的人应该知道 在java.util 包下 除了常用的 集合 和map之外还有一个<strong>Observable</strong>类，他的实现方式其实就是观察者模式。里面也有<strong>添加、删除、通知</strong>等方法。</p>
<p>这里需要注意是的 他是用Vector 作为订阅关系的容器，同时在他的定义方法中都添加synchronized关键字修饰类，以达到线程安全的目的。</p>
<p>应用场景：当前现在有更加好的中间件<strong>MQ消息队列</strong>来处理这个业务问题，使得我们更加从容的面对这类场景问题，但是一些资源不足，不想引入新的系统。还是可以用这种方式来处理问题的。</p>
<h2 id="day-6-12-14"><a href="#day-6-12-14" class="headerlink" title="day 6 12.14"></a>day 6 12.14</h2><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>​    定义一系列算法，封装每个算法，不同的策略可以调用不同的算法。</p>
<p>​    用大白话来讲，就是调用方根据不同的参数传入进去之后，会根据这个参数有不同的算法逻辑处理。</p>
<ul>
<li>Strategy（抽象策略）：抽象策略类，并且定义策略执行入口</li>
<li>ConcreteStrategy（具体策略）：实现抽象策略，实现algorithm方法</li>
<li>Context（环境）：运行特定的策略类。</li>
</ul>
<p>一个抽象策略接口Strategy，然后各种具体的策略实现该接口ConcreteStrategy，然后实现context来运行策略接口方法，</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/celue.png"></p>
<p>context对象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">private</span> <span class="token class-name">Strategy</span> strategy<span class="token punctuation">;</span>
 
   <span class="token keyword">public</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token class-name">Strategy</span> strategy<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 
   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">doOperation</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyPatternDemo</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token class-name">Context</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 + 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationSubtract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 - 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationMultiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 * 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>框架的应用：</p>
<p><strong>ThreadPoolExecutor</strong>中的里面实现线程池的异常策略,传入什么参数，就是什么策略</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/xianchengchi.png"></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AFbt7VJMASenD2S8KbPKJQ" >https://mp.weixin.qq.com/s/AFbt7VJMASenD2S8KbPKJQ<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>​    定义一个模板，模板里面有子类必须实现的接口（abstract），也有可以选择重写的接口，也有直接写好了的方法（final）</p>
<p>框架应用：HttpServlet 继承GenericServlet中也还是模版方法的体现，可以自己实现doget等</p>
<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>​    我们可以用相同的方式处理集合，无论它是列表还是数组，它都提供了一种迭代其元素而不用暴露其内部结构的机制，更重要的是，不同的类型的集合都可以使用相同的统一机制</p>
<p> 这里需要注意在java 集合遍历的时候，是不允许增删数据的，因为会导致指针位置变化，导致遍历的时候，数据漏掉或重复。</p>
<h3 id="设计模式总结："><a href="#设计模式总结：" class="headerlink" title="设计模式总结："></a>设计模式总结：</h3><p><a class="link"   target="_blank" rel="noopener" href="http://www.bjpowernode.com/shejimoshi/1595.html" >http://www.bjpowernode.com/shejimoshi/1595.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/dev-spec/pattern/1_overview.html" >https://pdai.tech/md/dev-spec/pattern/1_overview.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/AobingJava/JavaFamily" >https://github.com/AobingJava/JavaFamily<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="day-7-12-15"><a href="#day-7-12-15" class="headerlink" title="day 7  12.15"></a>day 7  12.15</h2><h3 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="jdk、jre、jvm-jit编译器、Aot"><a href="#jdk、jre、jvm-jit编译器、Aot" class="headerlink" title="jdk、jre、jvm jit编译器、Aot"></a>jdk、jre、jvm jit编译器、Aot</h5><h5 id="为什么说java是解释与编译型语言结合"><a href="#为什么说java是解释与编译型语言结合" class="headerlink" title="为什么说java是解释与编译型语言结合"></a>为什么说java是解释与编译型语言结合</h5><p>​    编译型语言：直接编译为机器可以执行的代码，执行速度快，但是开发效率低，比如C++、GO等</p>
<p>​    解释型语言：<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80" >解释型语言open in new window<i class="fas fa-external-link-alt"></i></a>会通过<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8" >解释器open in new window<i class="fas fa-external-link-alt"></i></a>一句一句的将代码解释（interpret）为机器代码后再执行。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/compiled-and-interpreted-languages.png"></p>
<p>java 是先编译在解释：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/java-code-to-machine-code.png"></p>
<h5 id="java-和C-的区别"><a href="#java-和C-的区别" class="headerlink" title="java 和C++的区别"></a>java 和C++的区别</h5><ul>
<li>java 没有指针，不能直接操作内存，程序更加安全，但其实是有unsafe类可以操作内存的，在cas中就是通过unsafe获取对应内存的值来比较，unsafe操作的是堆外内存</li>
<li>java 单继承</li>
<li>java 有自动垃圾回收机制（GC），C++没有，需要程序员自己手动释放</li>
<li>java 不支持运算符重载</li>
</ul>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>对象存在于堆内存，局部变量则存在于栈内存</li>
<li>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量会被 <code>final</code> 关键字修饰成为常量</li>
</ul>
<h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>​    静态变量和静态方法是属于类的，静态方法不能调用非静态成员或者非静态方法，因为静态是属于类的，在类的加载时就分配内存了，非静态方法属于对象的，类加载的时候，这时候没有对象，自然就不能调用非静态方法或者变量。</p>
<p>​    静态方法是通过类调用的</p>
<h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p>​    重载是对同一个类的，重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，下面就是对构造方法重载</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StringBuilder</span> sb2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>重写就是子类在继承的时候，可以选择性的重写方法，要求方法名和参数都一致，返回值应该比夫类的返回值类型更小或相等，一般都是相等。但是，父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法。protected只能儿子继承。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>八种基本数据类型：</p>
<p>  6种数字类型：byte short int long float double；1种字符类型：char，1种boolean</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/data.png"></p>
<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p> 1.包装类型和基本数据类型的区别：</p>
<ul>
<li>包装类型是对象，所以不赋值，默认就是null,而基本数据类型一般有默认值的</li>
<li>包装类型因为是对象，所以存在堆中，而基本数据类型的局部变量存在栈中</li>
</ul>
<p>2.包装类型的缓存机制</p>
<p><code>    Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210422164544846.png">    3.包装类型的自动拆装箱：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h4 id="浮点数运算丢失精度"><a href="#浮点数运算丢失精度" class="headerlink" title="浮点数运算丢失精度"></a>浮点数运算丢失精度</h4><p>​    这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>​    用BigDecimal来实现浮点数计算，该包装类比较应该用compareto，对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对低。</p>
<h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><h4 id="对象的引用和对象实体"><a href="#对象的引用和对象实体" class="headerlink" title="对象的引用和对象实体"></a>对象的引用和对象实体</h4><ul>
<li>对象实体实在堆内存中，对象引用是在栈内存中。</li>
<li>对象的相等一般比较的是内存中存放的内容是否相等，引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>浅拷贝在拷贝的时候，如果拷贝的有引用类型，直接指向该引用类型，而深拷贝是拷贝引用类型时，新建一个该引用类型的对象，然后赋值引用。这里主要体现在链表的操作：分割链表。</p>
<h4 id="Object常用方法"><a href="#Object常用方法" class="headerlink" title="Object常用方法"></a>Object常用方法</h4><p>​    equal方法，引用比较的是对象的内存地址，因为本身就是存储的对象的值。不重写默认就是&#x3D;&#x3D;</p>
<p>​    hashcode，<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回，那么为什么需要hashcode呢，因为在hashmap、hashset中是根据hashcode来快速确定对象的位置，提高效率，不用一个一个去比较。</p>
<ul>
<li><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p>
</li>
</ul>
<p>重写equal时也必须重写hashcode,因为重写了equal导致有可能导致对象equal返回true,但是hashcode不一样。</p>
<h4 id="String类："><a href="#String类：" class="headerlink" title="String类："></a>String类：</h4><p>1.String、Stringbuilder、StringBuffer</p>
<ul>
<li>String：不可变，因为由final和private修饰的value（且没有暴露操作value的方法）,操作string对象，然后将指针指向新的 <code>String</code> 对象。。线程安全</li>
<li>StringBuilder：可变，并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>StringBuffer：<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li>
</ul>
<p>2.<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<h2 id="day-8-2-5"><a href="#day-8-2-5" class="headerlink" title="day 8 2.5"></a>day 8 2.5</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p><strong>java 异常类层次结构图概览</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/types-of-exceptions-in-java.png" alt="Java 异常类层次结构图"></p>
<h4 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h4><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li>
</ul>
<p><strong>注意：不要在 finally 语句块中使用 return!</strong> 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<h4 id="如何使用-try-with-resources-代替try-catch-finally？"><a href="#如何使用-try-with-resources-代替try-catch-finally？" class="headerlink" title="如何使用 try-with-resources 代替try-catch-finally？"></a>如何使用 <code>try-with-resources</code> 代替<code>try-catch-finally</code>？</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> fnfe<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fnfe<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>basis<span class="token operator">/</span>java<span class="token operator">-</span>basic<span class="token operator">-</span>questions<span class="token operator">-</span><span class="token number">03.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>泛型类、泛型接口、泛型接口</p>
<h3 id="java-SPI"><a href="#java-SPI" class="headerlink" title="java SPI"></a>java SPI</h3><p>SPI 即 Service Provider Interface ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p>
<p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p>
<p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动、日志接口、以及 Dubbo 的扩展实现等等。</p>
<p>SPI是基于serviceLoader来实现的</p>
<h3 id="java-序列化"><a href="#java-序列化" class="headerlink" title="java 序列化"></a>java 序列化</h3><p>如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。</p>
<p>简单来说：</p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<p>对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。</p>
<p>下面是序列化和反序列化常见应用场景：</p>
<ul>
<li>对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li>
<li>将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li>
<li>将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li>
<li>将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li>
</ul>
<p>不想被序列化：transient，反序列化之后就是默认值</p>
<h3 id="java内存结构"><a href="#java内存结构" class="headerlink" title="java内存结构"></a>java内存结构</h3><p><a class="link"   target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/memory-area.html#%E5%89%8D%E8%A8%80" >https://javaguide.cn/java/jvm/memory-area.html#%E5%89%8D%E8%A8%80<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><p><strong>JDK 1.8 之前</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.7.png" alt="Java 运行时数据区域（JDK1.8 之前）"></p>
<p><strong>JDK 1.8 之后</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存</li>
</ul>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>​    是进程私有的，里面记录着程序目前运行着的字节码行 数，字节码解释器通过程序计数器来控制整个程序的流程控制，包括：循环、跳转以及多线程的线程恢复。</p>
<p>​    注意：不会出现outofMerroyError,因为记录的是内存地址</p>
<h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>​    每个进程都有一个虚拟机栈，栈存储的每个单位为栈帧。</p>
<p>​    栈帧中存储着：局部变量表、操作数栈、动态链接、方法返回值</p>
<ul>
<li>局部 变量表：存放的就是在编译时期已知的基础变量以及对象引用（有可能是指针也有可能是句柄）。</li>
<li>操作数栈：就是在计算中暂时存放结果的地方</li>
<li>动态链接：就是在调用另外一个方法时在使用符号引用时，将符号引用转换为内存的直接引用。（在 Java 源文件被编译成字节码文件时，所有的变量和方法引用都作为符号引用（Symbilic Reference）保存在 Class 文件的常量池里）</li>
<li>方法返回值：就是方法的结果返回地址</li>
</ul>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>当虚拟机使用一个类时，他需要读取并且解析class文件，然后将类的有关信息存入到方法区中。方法区会存储类信息、字段信息、静态常量等。</p>
<p><strong>方法区和永久代以及元空间是什么关系呢？</strong> 方法区和永久代以及元空间的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，也就是说永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/method-area-implementation.png" alt="HotSpot 虚拟机方法区的两种实现"></p>
<p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p>
<p>下图来自《深入理解 Java 虚拟机》第 3 版 2.2.5</p>
<p><img src="https://img-blog.csdnimg.cn/20210425134508117.png" alt="img"></p>
<p>1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
<p>2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
<p>3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​    运行时常量池实在方法区中的，存储着各种编译时的字面量、符号引用、以及常量池表。</p>
<p>​    字面量包括整数、浮点数和字符串字面量，符号引用包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。</p>
<h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在堆中创建字符串对象”ab“</span>
<span class="token comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span>
<span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
<span class="token comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span>
<span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>HotSpot 虚拟机中字符串常量池的实现是 <code>src/hotspot/share/classfile/stringTable.cpp</code> ,<code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> ,容量为 <code>StringTableSize</code>（可以通过 <code>-XX:StringTableSize</code> 参数来设置）。</p>
<p><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></p>
<p>JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/method-area-jdk1.6.png" alt="method-area-jdk1.6"></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/method-area-jdk1.7.png" alt="method-area-jdk1.7"></p>
<p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中？</strong></p>
<p>主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p>
<p>相关问题：<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/question/57109429/answer/151717241" >JVM 常量池中存储的是对象还是引用呢？ - RednaxelaFX - 知乎open in new window<i class="fas fa-external-link-alt"></i></a></p>
<p>最后再来分享一段周志明老师在<a class="link"   target="_blank" rel="noopener" href="https://github.com/fenixsoft/jvm_book" >《深入理解 Java 虚拟机（第 3 版）》样例代码&amp;勘误open in new window<i class="fas fa-external-link-alt"></i></a> Github 仓库的 <a class="link"   target="_blank" rel="noopener" href="https://github.com/fenixsoft/jvm_book/issues/112" >issue#112open in new window<i class="fas fa-external-link-alt"></i></a> 中说过的话：</p>
<blockquote>
<p><strong>运行时常量池、方法区、字符串常量池这些都是不随虚拟机实现而改变的逻辑概念，是公共且抽象的，Metaspace、Heap 是与具体某种虚拟机实现相关的物理概念，是私有且具体的。</strong></p>
</blockquote>
<h3 id="hotSpot的对象"><a href="#hotSpot的对象" class="headerlink" title="hotSpot的对象"></a>hotSpot的对象</h3><h4 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h4><h5 id="一-类加载检查"><a href="#一-类加载检查" class="headerlink" title="一:类加载检查"></a>一:类加载检查</h5><p>虚拟机遇到new之后，会去方法区中的常量池中去检查是否有该类的符号引用，并检查该类有没有加载、解析初始化过，如果没有，再进行类的加载过程。</p>
<h5 id="二：分配空间"><a href="#二：分配空间" class="headerlink" title="二：分配空间"></a>二：分配空间</h5><p>在类加载检查之后，发现需要加载，这个时候在堆中分配一块内存给该对象。分配空间的方式又有两种：选择哪种分配方式与java堆是否是规整的，是否是规整又取决与垃圾回收器的回收算法，是否有 整理压缩。 </p>
<p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p>
<ul>
<li>指针碰撞 ： <ul>
<li>适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li>
<li>原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li>
<li>使用该分配方式的 GC 收集器：Serial, ParNew</li>
</ul>
</li>
<li>空闲列表 ： <ul>
<li>适用场合 ： 堆内存不规整的情况下。</li>
<li>原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li>
<li>使用该分配方式的 GC 收集器：CMS著作权归所有 原文链接：<a class="link"   target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/memory-area.html" >https://javaguide.cn/java/jvm/memory-area.html<i class="fas fa-external-link-alt"></i></a></li>
</ul>
</li>
</ul>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h5 id="三：初始化零值"><a href="#三：初始化零值" class="headerlink" title="三：初始化零值"></a>三：初始化零值</h5><p>内存分配完成之后，需要将分配的内存空间都初始化为零值，这样就可以保证对象的实例字段在java代码中不赋值就可以使用，程序就能访问带字段数据对应的“零值”</p>
<h5 id="四：设置对象头"><a href="#四：设置对象头" class="headerlink" title="四：设置对象头"></a>四：设置对象头</h5><p>初始化零值之后，就需要对对象进行设置，比如该对象是哪一个类 的实例、GC年代、以及对象的哈希码等，这些都存储在对象头中，根据虚拟机的状态不同，也许还有偏向锁等</p>
<h5 id="五：执行init方法"><a href="#五：执行init方法" class="headerlink" title="五：执行init方法"></a>五：执行init方法</h5><p>在上面的工作执行完之后，对于虚拟机来说，对象就创建出来了，但是对于java程序来说，还会执行init方法，按照程序员的意思创建对象。</p>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><p>对象在内存中存储时包含三部分：对象头、实例数据、对齐填充</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p>
<h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p>
<h5 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h5><p>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle.png" alt="对象的访问定位-使用句柄"></p>
<h5 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h5><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/access-location-of-object-handle-direct-pointer.png" alt="对象的访问定位-直接指针"></p>
<p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
<p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p>
<h3 id="day-9-2-8"><a href="#day-9-2-8" class="headerlink" title="day 9 2.8"></a>day 9 2.8</h3><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><h4 id="collection-list"><a href="#collection-list" class="headerlink" title="collection-list"></a>collection-list</h4><p>ArrayList和Vector的区别：底层都是用Object[],但是Vector是线程安全的，ArrayList不是线程安全的</p>
<p>ArrayList和LinkedList的区别：</p>
<p>​    主要是底层数据结构的不同导致的区别：</p>
<ul>
<li>ArrayList是有Object[]数组构成的，所以他支持随机访问，以及在对集合的增删改查的时候的时间复杂度受元素个属影响，因为是数组，所以在list列表结尾会预留空间</li>
<li>LinkedList因为是由链表构成的list,所以不支持随机访问，在访问元素的时候需要从头开始，在对集合的增删改查的时间复杂度不受元素个数影响，因为是链表所以每一个元素需要存储后指针，所以需要更多的空间。</li>
</ul>
<h5 id="arraylist源码扩容分析"><a href="#arraylist源码扩容分析" class="headerlink" title="arraylist源码扩容分析"></a>arraylist源码扩容分析</h5><p>无参构造的默认大小为10,判断是否扩容，就是在minCapacity - elementData.length（元素的容量） &gt; 0，如果大于，则扩容，不大于不会进入 （执行）<code>grow(minCapacity)</code> 方法，扩容是扩minCapacity，每次扩为之前的1.5倍左右，是位运算，最大Integer.MAX_VALUE - 8，如果大于就会为Integer.MAX_VALUE</p>
<h5 id="ensureCapacity"><a href="#ensureCapacity" class="headerlink" title="ensureCapacity"></a>ensureCapacity</h5><p>通过运行结果，我们可以看出向 <code>ArrayList</code> 添加大量元素之前使用<code>ensureCapacity</code> 方法可以提升性能。不过，这个性能差距几乎可以忽略不计。而且，实际项目根本也不可能往 <code>ArrayList</code> 里面添加这么多元素</p>
<h4 id="collection-set"><a href="#collection-set" class="headerlink" title="collection-set"></a>collection-set</h4><p>定制排序：</p>
<p>1.实现Comparator中的compare</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>arrayList<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> o1<span class="token punctuation">,</span> <span class="token class-name">Integer</span> o2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> o2<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>collection<span class="token operator">/</span>java<span class="token operator">-</span>collection<span class="token operator">-</span>questions<span class="token operator">-</span><span class="token number">01.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>2.在类中实现接口以及重写compareto方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span>  <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Person</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token comment">/**
     * T重写compareTo方法实现按年龄来排序
     */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Person</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">></span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">&lt;</span> o<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>collection<span class="token operator">/</span>java<span class="token operator">-</span>collection<span class="token operator">-</span>questions<span class="token operator">-</span><span class="token number">01.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>HashSet、LinkedHashSet 和 TreeSet的异同：</p>
<p> 都不是线程安全的，底层数据结构不同：HashSet是hashmap,LinkedHashSet是链表加hashmap,满足FIFO,TreeSet是红黑树，支持定制排序，所以对应的应用场景也不同。</p>
<h4 id="collection-queue"><a href="#collection-queue" class="headerlink" title="collection-queue"></a>collection-queue</h4><p>deque是queue的扩展，注意PriorityQueue，可以定制排序。</p>
<h4 id="collection-map"><a href="#collection-map" class="headerlink" title="collection-map"></a>collection-map</h4><p>1.8之后在解决hash冲突的时候变成了，链表的长度大于阈值的时候，就将装换为红黑树，将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树</p>
<p>hashMap初始容量是16，扩容之后变为原来的两倍，什么时候扩容：</p>
<p><strong>loadFactor 加载因子</strong></p>
<p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值</strong>。</p>
<p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 &#x3D; 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p>
<h5 id="Hashmap和hashtable的区别"><a href="#Hashmap和hashtable的区别" class="headerlink" title="Hashmap和hashtable的区别"></a>Hashmap和hashtable的区别</h5><p>hashmap是非线程安全的，hashtable是线程安全的，但是即使要考虑线程安全，也不要用hashtable,尽量用concurrentmap</p>
<h5 id="hashset和hashmap"><a href="#hashset和hashmap" class="headerlink" title="hashset和hashmap"></a>hashset和hashmap</h5><p>hashset就是基于hashmap实现的，只不过套了一层。</p>
<h5 id="hashmap和treemap"><a href="#hashmap和treemap" class="headerlink" title="hashmap和treemap"></a>hashmap和treemap</h5><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</strong></p>
<h5 id="concurrentmap"><a href="#concurrentmap" class="headerlink" title="concurrentmap"></a>concurrentmap</h5><p>线程安全的，在jdk 1.7时使用的segment+分段锁+数组+链表实现的。每个segment一把锁，想要访问该segment里的元素就需要获取锁，在1.8时就用的是node数组加+链表或者数组</p>
<p><strong>线程安全实现方式</strong> ：JDK 1.7 采用 <code>Segment</code> 分段锁来保证安全， <code>Segment</code> 是继承自 <code>ReentrantLock</code>。JDK1.8 放弃了 <code>Segment</code> 分段锁的设计，采用 <code>Node + CAS + synchronized</code> 保证线程安全，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点。</p>
<p><strong>Hash 碰撞解决方法</strong> : JDK 1.7 采用拉链法，JDK1.8 采用拉链法结合红黑树（链表长度超过一定阈值时，将链表转换为红黑树）。</p>
<p><strong>并发度</strong> ：JDK 1.7 最大并发度是 Segment 的个数，默认是 16。JDK 1.8 最大并发度是 Node 数组的大小，并发度更大。</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>UNIX 系统下， IO 模型一共有 5 种： <strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p>
<h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><p>就是BIO,应用程序发起IO请求，会一直阻塞，直到内核把数据拷贝到用户空间</p>
<h4 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h4><p>应用程序发起IO请求，不会一直阻塞，会一直询问，</p>
<p> <strong>同步非阻塞 IO 模型</strong>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb174e22dbe04bb79fe3fc126aed0c61~tplv-k3u1fbpfcp-watermark.image" alt="图源：《深入拆解Tomcat &amp; Jetty》"></p>
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<h4 id="AIO-异步"><a href="#AIO-异步" class="headerlink" title="AIO 异步"></a>AIO 异步</h4><p>请求回调</p>
<h3 id="java-并发"><a href="#java-并发" class="headerlink" title="java 并发"></a>java 并发</h3><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指：多个线程在运行的时候，同时被阻塞，阻塞的原因是因为一个或者多个都在互相等待资源释放，造成了无限循环等待，这就是死锁</p>
<h5 id="预防和破坏死锁"><a href="#预防和破坏死锁" class="headerlink" title="预防和破坏死锁"></a>预防和破坏死锁</h5><p>一次性申请所有资源、申请不到资源就释放自己占用的资源、</p>
<h4 id="wait-和sleep"><a href="#wait-和sleep" class="headerlink" title="wait 和sleep"></a>wait 和sleep</h4><p>wait会释放锁，需要其他线程来notify，sleep是thread的方法，不会释放锁</p>
<p>直接使用thread.run是错误的，<strong>调用 <code>start()</code> 方法方可启动线程并使线程进入就绪状态，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。</strong></p>
<h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><p>CAS是用来实现乐观锁，CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。ABA问题：解决方法：先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志    </p>
<h4 id="volatile（结合单例模式的线程安全的双重检查来记忆）"><a href="#volatile（结合单例模式的线程安全的双重检查来记忆）" class="headerlink" title="volatile（结合单例模式的线程安全的双重检查来记忆）"></a>volatile（结合单例模式的线程安全的双重检查来记忆）</h4><p>单例模式：</p>
<p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>保证了变量的可见性，每个线程每次获取该变量的时候，都需要去主存中获取拷贝到自己的共享变量副本中，</p>
<p>禁止指令重排（为了性能优化，JMM在不改变正确语义的情况下会允许编译器和处理器对指令序列进行重排序），通过插入内存屏障来实现，内存屏障就是在java编译器在指定的地方插入内存屏障指令来禁止处理器进行重排序</p>
<p>不保证 变量的原子性</p>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p> 解决的是多线程访问资源的同步性，可以方法或者代码块线程安全。</p>
<p>早期synchronized是重量级锁，因为监视器锁monitor是基于操作系统的来实现的，挂起或者恢复线程的时候都需要操作系统在内核态和用户态之间切换，所以    性能不高。</p>
<p>在java6之后，synchronized有了很大的优化：自旋锁、适应自旋锁、锁粗化、偏向锁以及轻量级锁</p>
<p>使用：</p>
<ul>
<li>修饰实例方法：锁的是对象</li>
<li>修饰静态方法：锁的是类，因为静态方法属于类</li>
<li>修饰代码块：锁对象或者类</li>
</ul>
<p>从字节码分析：</p>
<p><strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p>不过两者的本质都是对对象监视器 monitor 的获取。</p>
<p>java6对synchronized的优化：无锁、偏向锁、轻量级锁、重量级锁。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是针对一个线程来说的，假如有两个线程来竞争的话，就升级成轻量级锁。</p>
<p> 为什么要这样做呢？<em>因为经验表明，其实大部分情况下，都会是同一个线程进入同一块同步代码块的。这也是为什么会有偏向锁出现的原因</em></p>
<p>我们假设线程A曾经拥有锁（不确定是否释放锁）， 线程B来竞争锁对象，如果当线程A不在拥有锁时或者死亡时，线程B直接去尝试获得锁（根据是否 允许重偏向（<code>rebiasing</code>），获得偏向锁或者轻量级锁）；如果线程A仍然拥有锁，那么锁 升级为轻量级锁，线程B自旋请求获得锁</p>
<h4 id="轻量级锁："><a href="#轻量级锁：" class="headerlink" title="轻量级锁："></a>轻量级锁：</h4><p>线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录（<code>Lock Record</code>）的指针， 如上图所示。如果成功，当前线程获得轻量级锁，如果失败，虚拟机先检查当前对象头的 Mark Word 是否指向当前线程的栈帧，如果指向，则说明当前线程已经拥有这个对象的锁，则可以直接进入同步块 执行操作，否则表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。当竞争线程的自旋次数 达到界限值（<code>threshold</code>），轻量级锁将会膨胀为重量级锁。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>​    重量级锁（<code>heavy weight lock</code>），是使用操作系统互斥量（<code>mutex</code>）来实现的传统锁。 当所有对锁的优化都失效时，将退回到重量级锁。它与轻量级锁不同竞争的线程不再通过自旋来竞争线程， 而是直接进入堵塞状态，此时不消耗CPU，然后等拥有锁的线程释放锁后，唤醒堵塞的线程， 然后线程再次竞争锁。但是注意，当锁膨胀（<code>inflate</code>）为重量锁时，就不能再退回到轻量级锁</p>
<p>​    首先要明确一点是引入这些锁是为了提高获取锁的效率, 要明白每种锁的使用场景, 比如偏向锁适合一个线程对一个锁的多次获取的情况; 轻量级锁适合锁执行体比较简单(即减少锁粒度或时间), 自旋一会儿就可以成功获取锁的情况.</p>
<h4 id="synchronized和reentrantlock"><a href="#synchronized和reentrantlock" class="headerlink" title="synchronized和reentrantlock"></a>synchronized和reentrantlock</h4><p>​    都是可重入锁，可重入锁就是自己可以获取自己获取到的对象锁，就在对象锁的锁计数器加一，jdk的lock接口实现的锁都是可重入锁，包括synchronized。</p>
<p>Renentrantlock比synchronized增加的功能：</p>
<ul>
<li>可以实现非公平锁和公平锁</li>
<li>可以实现选择性唤醒：<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。而<code>Condition</code>实例的<code>signalAll()</code>方法，只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</li>
<li>等待可中断：通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
</ul>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>​    是指每一个线程私有的本地变量，不会被其他线程访问。</p>
<p>原理：其实底层使用threadlocalmap来实现的，就是hashmap，调用api：set以及get。</p>
<p>内存泄漏问题：</p>
<p>​    因为threadlocalmap中的key是弱引用，如果垃圾回收的时候，key被回收，但是value是强引用，    所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p>
<p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<h4 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h4><p>原子类就是具有原子操作的类，类在多个线程中是线程安全的，主要是使用CAS加volatile和native方法，通过Unsafe类中的objectFieldOffset（），是一个本地方法，获取原来的值的内存地址，然后通过volatile在主存中获取该值的最新值。</p>
<h5 id="Atomic主要分为四类"><a href="#Atomic主要分为四类" class="headerlink" title="Atomic主要分为四类"></a>Atomic主要分为四类</h5><ul>
<li><p>基本类型：AtomicInteger、AtomicBoolean</p>
</li>
<li><p>数组类型：AtomicIntegerArray</p>
</li>
<li><p>引用类型：AtomicReference：引用类型原子类;</p>
<p><code>AtomicStampedReference</code> ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题</p>
</li>
<li><p>对象的属性修改类型 ：</p>
</li>
</ul>
<h4 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h4><p>​    JMM是java内存模型，注意这里和jvm中的java内存结构区分，这里的JMM是指的在java多线程开发的时候，为了防止在多线程开发出现因CPU缓存和指令重排序出现问题的一系列规范。</p>
<h5 id="为什么需要JMM"><a href="#为什么需要JMM" class="headerlink" title="为什么需要JMM"></a>为什么需要JMM</h5><p>​    在操作系统层面，也有内存模型，编程语言完全可以复用操作系统的内存模型，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p>
<p>​    对于 Java 来说，你可以把 JMM 看作是 Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的</p>
<h5 id="保证共享变量在主内存和线程本地内存的一致性"><a href="#保证共享变量在主内存和线程本地内存的一致性" class="headerlink" title="保证共享变量在主内存和线程本地内存的一致性"></a>保证共享变量在主内存和线程本地内存的一致性</h5><p>八种同步操作：解锁、锁定、read、load….</p>
<p>还有八种规则保证这八种操作的正确执行。</p>
<h5 id="Happens-before"><a href="#Happens-before" class="headerlink" title="Happens-before"></a>Happens-before</h5><p>通过happens-before来实现在多线程下，确保编译器和处理器对指令的重排序不出问题。</p>
<h3 id="day-9-2-9"><a href="#day-9-2-9" class="headerlink" title="day 9 2.9"></a>day 9 2.9</h3><h4 id="java-线程"><a href="#java-线程" class="headerlink" title="java 线程"></a>java 线程</h4><h5 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h5><ul>
<li>降低资源的消耗：频繁的建立和销毁线程会消耗大量资源</li>
<li>提高响应时间：在任务到达时，不用等待线程创建的时间</li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制的建立，不仅消耗资源，还会降低系统的稳定性，使用线程池可以统一的分配以及监控管理（可以用对应的APi获取当前线程池的线程数以及活跃线程数以及等待数）</li>
</ul>
<h5 id="建议使用ThreadPoolExecutor构造函数建议线程池"><a href="#建议使用ThreadPoolExecutor构造函数建议线程池" class="headerlink" title="建议使用ThreadPoolExecutor构造函数建议线程池"></a>建议使用ThreadPoolExecutor构造函数建议线程池</h5><p>​    强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li><strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 允许请求的队列长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li><strong><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code></strong> ： 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM</li>
</ul>
</blockquote>
<h5 id="ThreadPoolExecutor构造函数参数解析"><a href="#ThreadPoolExecutor构造函数参数解析" class="headerlink" title="ThreadPoolExecutor构造函数参数解析"></a>ThreadPoolExecutor构造函数参数解析</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的核心线程数量</span>
                              <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的最大线程数</span>
                              <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>
                              <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//时间单位</span>
                              <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">></span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//任务队列，用来储存等待执行任务的队列</span>
                              <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//线程工厂，用来创建线程，一般默认即可</span>
                              <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>
                               <span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理"></p>
<h5 id="线程池运行"><a href="#线程池运行" class="headerlink" title="线程池运行"></a>线程池运行</h5><h5 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h5><p>execute –&gt; addWorker –&gt;runworker (getTask)</p>
<p>AddWorker：addWorker主要负责创建新的线程并执行任务 线程池创建新线程执行任务时，需要 获取全局锁:</p>
<h5 id="任务的提交"><a href="#任务的提交" class="headerlink" title="任务的提交"></a>任务的提交</h5><p>submit任务，等待线程池execute</p>
<p>执行FutureTask类的get方法时，会把主线程封装成WaitNode节点并保存在waiters链表中， 并阻塞等待运行结果；</p>
<p>FutureTask任务执行完成后，通过UNSAFE设置waiters相应的waitNode为null，并通过LockSupport类unpark方法唤醒主线程；</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ExecutorService</span> es <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> future <span class="token operator">=</span> es<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
                    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">return</span> <span class="token string">"future result"</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">String</span> result <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>java<span class="token operator">/</span>thread<span class="token operator">/</span>java<span class="token operator">-</span>thread<span class="token operator">-</span>x<span class="token operator">-</span>juc<span class="token operator">-</span>executor<span class="token operator">-</span><span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="任务的关闭"><a href="#任务的关闭" class="headerlink" title="任务的关闭"></a>任务的关闭</h5><p>shutdown：将线程池里的线程状态设置成SHUTDOWN状态, 然后中断所有没有正在执行任务的线程.</p>
<p>shutdownNow:将线程池里的线程状态设置成STOP状态, 然后停止所有正在执行或暂停任务的线程. 只要调用这两个关闭方法中的任意一个, isShutDown() 返回true. 当所有任务都成功关闭了, isTerminated()返回true</p>
<h5 id="线程池的线程数量"><a href="#线程池的线程数量" class="headerlink" title="线程池的线程数量"></a>线程池的线程数量</h5><p>​    如果设置太小，在高请求时，就会造成任务队列满了，导致大量请求无法处理，或者大量请求堆积导致OOM；如果设置太大，那么大量线程都在竞争CPU,就会导致上下文切换太多，影响整体效率</p>
<p>​    CPU密集：n+1,加一是防止某一个线程偶发的缺页中断或者其他原因导致的任务暂停，多一个先就可以利用该暂停的时间</p>
<p>​    IO密集：因为IO时间段是不会使用CPU的，就可以把CPU交给其他线程。</p>
<h5 id="使用线程池的注意事项："><a href="#使用线程池的注意事项：" class="headerlink" title="使用线程池的注意事项："></a>使用线程池的注意事项：</h5><p>不同业务类别使用不同的线程池，不然会造成死锁。</p>
<p>试想这样一种极端情况：假如我们线程池的核心线程数为 <strong>n</strong>，父任务（扣费任务）数量为 <strong>n</strong>，父任务下面有两个子任务（扣费任务下的子任务），其中一个已经执行完成，另外一个被放在了任务队列中。由于父任务把线程池核心线程资源用完，所以子任务因为无法获取到线程资源无法正常执行，一直被阻塞在队列中。父任务等待子任务执行完成，而子任务等待父任务释放线程池资源，这也就造成了 **”死锁”**。</p>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h4><h5 id="AQS是什么："><a href="#AQS是什么：" class="headerlink" title="AQS是什么："></a>AQS是什么：</h5><p>​    AQS是一个用来构建锁和同步器的框架，使用AQS能够简单且高效的构造出大量的同步器，包括：reentrantlock、semaphore，因为他是一个框架，所以我们自己也能构造出自定义需求的同步器。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护(如获取资源失败入队&#x2F;唤醒出队等)，AQS已经在上层已经帮我们实现好了</p>
<h5 id="AQS的核心思想："><a href="#AQS的核心思想：" class="headerlink" title="AQS的核心思想："></a>AQS的核心思想：</h5><p>​    如果被请求的资源空闲，则将请求该资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的资源被占用，则需要一套线程阻塞唤醒以及被唤醒时锁分配的机制。这个机制是用CLH队列锁来实现的。AQS将请求资源的线程封装成CLH的node节点来实现锁的分配。</p>
<pre><code>  AQS使用一个int变量来表示同步状态，AQS使用CAS对该变量进行修改，private volatile int state;//共享变量，使用volatile修饰保证线程可见性。
</code></pre>
<h5 id="AQS对资源的共享方式"><a href="#AQS对资源的共享方式" class="headerlink" title="AQS对资源的共享方式"></a>AQS对资源的共享方式</h5><ul>
<li>独占模式：只有一个线程能够执行，reentrantlock</li>
<li>共享模式：多个线程都能访问，如Semaphore&#x2F;CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock</li>
</ul>
<h5 id="AQS底层使用了模板模式的设计模式"><a href="#AQS底层使用了模板模式的设计模式" class="headerlink" title="AQS底层使用了模板模式的设计模式"></a>AQS底层使用了模板模式的设计模式</h5><p>​    使用者继承AbstractQueuedSynchronizer并重写指定的方法。自定义同步器需要重写以下AQS的模板方法：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token function">isHeldExclusively</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span>
<span class="token function">tryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span>
<span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span>
<span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>java<span class="token operator">/</span>thread<span class="token operator">/</span>java<span class="token operator">-</span>thread<span class="token operator">-</span>x<span class="token operator">-</span>lock<span class="token operator">-</span><span class="token class-name">AbstractQueuedSynchronizer</span><span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0(即释放锁)为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的(state会累加)，这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<h5 id="AQS-数据结构"><a href="#AQS-数据结构" class="headerlink" title="AQS 数据结构"></a>AQS 数据结构</h5><p>除了刚刚说的CLH队列，还有一个重要的就是AQS将请求的线程作为node加入到CLH中。</p>
<p>Node中重要的几个属性:</p>
<p>解释一下几个方法和属性值的含义：</p>
<table>
<thead>
<tr>
<th align="left">方法和属性值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">waitStatus</td>
<td align="left">当前节点在队列中的状态</td>
</tr>
<tr>
<td align="left">thread</td>
<td align="left">表示处于该节点的线程</td>
</tr>
<tr>
<td align="left">prev</td>
<td align="left">前驱指针</td>
</tr>
<tr>
<td align="left">predecessor</td>
<td align="left">返回前驱节点，没有的话抛出 npe</td>
</tr>
<tr>
<td align="left">nextWaiter</td>
<td align="left">指向下一个处于 CONDITION 状态的节点（由于本篇文章不讲述 Condition Queue 队列，这个指针不多介绍）</td>
</tr>
<tr>
<td align="left">next</td>
<td align="left">后继指针</td>
</tr>
</tbody></table>
<p>线程两种锁的模式：</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SHARED</td>
<td align="left">表示线程以共享的模式等待锁</td>
</tr>
<tr>
<td align="left">EXCLUSIVE</td>
<td align="left">表示线程正在以独占的方式等待锁</td>
</tr>
</tbody></table>
<p>waitStatus 有下面几个枚举值：</p>
<table>
<thead>
<tr>
<th align="left">枚举</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">当一个 Node 被初始化的时候的默认值，值为0，表示当前节点在sync queue中，等待着获取锁</td>
</tr>
<tr>
<td align="left">CANCELLED</td>
<td align="left">为 1，表示线程获取锁的请求已经取消了</td>
</tr>
<tr>
<td align="left">CONDITION</td>
<td align="left">为-2，表示节点在等待队列中，节点线程等待唤醒</td>
</tr>
<tr>
<td align="left">PROPAGATE</td>
<td align="left">为-3，当前线程处在 SHARED 情况下，该字段才会使用</td>
</tr>
<tr>
<td align="left">SIGNAL</td>
<td align="left">为-1，表示线程已经准备好了，就等资源释放了，表示当前节点的后继节点包含的线程需要运行，需要进行unpark操作</td>
</tr>
</tbody></table>
<h5 id="AQS过程"><a href="#AQS过程" class="headerlink" title="AQS过程"></a>AQS过程</h5><p>当一个线程调用acquire时，调用方法流程如下</p>
<p><img src="https://pdai.tech/images/thread/java-thread-x-juc-aqs-2.png" alt="image"></p>
<p>（1）首先调用acquire,调用此方法会试图在独占模式下获取资源，如果能够获得，就获得资源；否则调用addWaiter,将请求的线程封装成一个node放入CLH队列中</p>
<p>（2）然后调用accquireQueued,方法完成的功能是Sync queue中的结点不断尝试获取资源，若成功，则返回true，否则，返回false。具体流程是：</p>
<p>​    首先获取当前节点的前驱节点，判断是否是head节点并且能否获取资源，如果能，就获取该资源，将state+1,并且设置当前节点为头节点；否则，调用shouldParkAfterFailAcquire和parkAndCheckInterrupt</p>
<p>accquireQueued源码</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 标记是否成功拿到资源</span>
	<span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">try</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 标记等待过程中是否中断过</span>
		<span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token comment">// 开始自旋，要么获取锁，要么中断</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// 获取当前节点的前驱节点</span>
			<span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token comment">// 获取锁成功，头指针移动到当前node</span>
				<span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
				p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
				failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">finally</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
			<span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>javaguide<span class="token punctuation">.</span>cn<span class="token operator">/</span>java<span class="token operator">/</span>concurrent<span class="token operator">/</span>reentrantlock<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（3）shouldParkAfterFailAcquire </p>
<p>​    为了防止因死循环导致 CPU 资源被浪费（没有获取到资源，会自旋），我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire 流程）：</p>
<p><img src="https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png" alt="img"></p>
<h5 id="AQS总结"><a href="#AQS总结" class="headerlink" title="AQS总结"></a>AQS总结</h5><p>Q：某个线程获取锁失败的后续流程是什么呢？</p>
<p>A：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。</p>
<p>Q：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？</p>
<p>A：是 CLH 变体的 FIFO 双端队列。</p>
<p>Q：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？</p>
<p>A：可以详细看下 2.3.1.3 小节。</p>
<p>Q：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？</p>
<p>A：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见 2.3.2 小节。</p>
<p>Q：Lock 函数通过 Acquire 方法进行加锁，但是具体是如何加锁的呢？</p>
<p>A：AQS 的 Acquire 会调用 tryAcquire 方法，tryAcquire 由各个自定义同步器实现，通过 tryAcquire 完成加锁过程</p>
<p>每一个结点都是由前一个结点唤醒</p>
<p>当结点发现前驱结点是head并且尝试获取成功，则会轮到该线程运行。</p>
<p>condition queue中的结点向sync queue中转移是通过signal操作完成的。</p>
<p>当结点的状态为SIGNAL时，表示后面的结点需要运行</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/reentrantlock.html#_2-1-%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88" >https://javaguide.cn/java/concurrent/reentrantlock.html#_2-1-%E5%8E%9F%E7%90%86%E6%A6%82%E8%A7%88<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#abstractqueuedsynchronizer%E6%80%BB%E7%BB%93" >https://pdai.tech/md/java/thread/java-thread-x-lock-AbstractQueuedSynchronizer.html#abstractqueuedsynchronizer%E6%80%BB%E7%BB%93<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="day-10-2-10"><a href="#day-10-2-10" class="headerlink" title="day 10 2.10"></a>day 10 2.10</h3><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h5 id="堆空间的结构"><a href="#堆空间的结构" class="headerlink" title="堆空间的结构"></a>堆空间的结构</h5><p>新生代、老年代、永久代（元空间）。</p>
<h5 id="内存分配以及基本原则"><a href="#内存分配以及基本原则" class="headerlink" title="内存分配以及基本原则"></a>内存分配以及基本原则</h5><ul>
<li>对象优先分配在eden区</li>
<li>大对象直接进入老年代：比如数组以及字符串这种需要较大的连续空间的对象</li>
<li>长期存活的对象进入老年代：在mior GC的时候，如果eden的对象存活，就会在age上加一，直到达到阈值就会晋升到老年代，（JDK8动态年龄判定：当虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，而是在Survivor中的相同年龄的对象的总和大小大于survivor的空间的一半，则大于或者等于的就可以进入图老年代中）</li>
<li>空间担保原则：在发生minor GC的之前，因为minor GC 中会有新生代的对象会晋升到老年代中来，所以需要确保在老年代中有“足够的空间”，虚拟机会检查老年代中的可用连续空间是否大于新生代对象总大小或者历次晋升的平均水平，如果大于就可以进行minor GC,如果小于就需要FUll GC</li>
</ul>
<h5 id="死亡对象而判断方法"><a href="#死亡对象而判断方法" class="headerlink" title="死亡对象而判断方法"></a>死亡对象而判断方法</h5><p>1.引用计数法：引用了该对象就在计数器上加一。</p>
<p>​    会出现一个问题：相互循环引用，这两个对象的不被外部任何引用，只被两个对象相互循环引用，这就导致了永远无法回收他们。</p>
<p>2.可达性分析：以GC Roots作为起点，一个对象到GC root是如果没有一条引用练，就视为可以被回收。</p>
<p>哪些对象可以作为GC ROOTs：</p>
<ul>
<li>虚拟机栈（本地变量表）中引用的对象</li>
<li>本地方法栈中的对象（native方法中）</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>被同步锁的对象</li>
</ul>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul>
<li>强引用：一个对象具有强引用，垃圾回收器是不会回收的，当内存不足的时候，JVM宁愿抛出OOM错误,也不会随意回收强引用的对象来解决内存不足的问题。</li>
<li>软引用：如果内存空间不足，就会回收这些内存</li>
<li>弱引用：和软引用差不多，但是区别在于只具有弱引用的对象生命周期更短，在垃圾回收器线程扫描对象的时候，一旦发现了只具有弱引用的对象，不管内存空间是否不足，都会回收。</li>
<li>虚引用：任何时候都会可能被回收</li>
</ul>
<p>使用弱引用和虚引用较少，使用软引用较多，可以加速jvm对垃圾内存的回收速度，放置内存溢出等问题的产生。</p>
<h4 id="如何判断常量是垃圾"><a href="#如何判断常量是垃圾" class="headerlink" title="如何判断常量是垃圾"></a>如何判断常量是垃圾</h4><p>在jdk1.7之后字符串常量池在堆中，运行常量池还在方法区中，当字符串常量池中的没有任何String对象引用他，就会视为垃圾</p>
<h4 id="如何判断类是无用的类"><a href="#如何判断类是无用的类" class="headerlink" title="如何判断类是无用的类"></a>如何判断类是无用的类</h4><p>该类的所有实例对象都被回收；该类的classloader已经被回收；该类的class对象没有在任何地方被引用。但是就算是无用的类，也不一定就被回收</p>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul>
<li>标记-清除算法</li>
<li>标记-复制</li>
<li>标记-整理</li>
</ul>
<p>为什么要分代：因为根据不同代的对象的特点可以选择不同的垃圾回收算法，提升效率。</p>
<p>比如在新生代中，每次收集都会有大量对象死去，所以可以选择标记-复制算法，因为可以有分配担保原则，而且只需要付出少量的对象的复制成本。而在老年代中对象存活几率较大，而且没有额外的空间分配担保，所以选择标记-清除或者标记-整理</p>
<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="serial-收集器"><a href="#serial-收集器" class="headerlink" title="serial 收集器"></a>serial 收集器</h5><p>单线程收集器，意味着在垃圾回收的时候是单线程，而且在垃圾回收的时候会STW。适用于client这种客户机</p>
<p><img src="https://javaguide.cn/assets/46873026.3a9311ec.png" alt=" Serial 收集器 "></p>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>是serial收集器的多线程版本，新生代采用标记-复制，老年代采用标记-整理</p>
<p><img src="https://javaguide.cn/assets/22018368.df835851.png" alt="ParNew 收集器 "></p>
<h5 id="Parallel-Scanvenge收集器"><a href="#Parallel-Scanvenge收集器" class="headerlink" title="Parallel Scanvenge收集器"></a>Parallel Scanvenge收集器</h5><p>他和ParNew大概一致，区别就在于Parallel Scanvenge注重的是吞吐量， Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量</p>
<h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>整个过程分为四个步骤：</p>
<ul>
<li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li>
<li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li>
<li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li>
<li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li>
</ul>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/cms.png" alt="CMS 垃圾收集器 "></p>
<p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p>
<ul>
<li>对CPU资源铭感</li>
<li>浮动垃圾</li>
<li>标记清除算法产生大量内存碎片</li>
</ul>
<h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>G1收集器是一款面向服务器的垃圾回收器，在多CPU和大内存的场景下有很好的性能。</p>
<p>其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>
<p>G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。</p>
<p>通过引入region的概念，从而将原来的大空间分为了许多小空间，使得每个小空间都可以进行垃圾的单独回收，这样就使得了可预测的停顿模型成为可能，通过记录每个region垃圾回收时间和所回收的获得空间值（这两个值是通过过去获得的经验），并维护一个优先列表，每次根据允许的收集时间来优先选择需要回收的region.</p>
<p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描</p>
<p>在局部是标记复制，整体看来是标记整理</p>
<p><strong>主要优点</strong></p>
<ul>
<li>空间整合: 整体来看是基于“标记 - 整理”算法实现的收集器，从局部(两个 Region 之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li>
<li>可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</li>
</ul>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>加载-验证-准备-解析-初始化-使用-卸载</p>
<p>加载：</p>
<ol>
<li>将class文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口</li>
</ol>
<p>验证：验证文件格式以及元数据的格式以及字节码的流程正确，确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查</p>
<p>准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a &#x3D; 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</p>
<p>解析：虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<p>初始化：</p>
<p><strong>JVM初始化步骤</strong></p>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
</ul>
<h6 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h6><ul>
<li>启动类加载器;最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类</li>
<li>扩展类加载器类：它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库(如javax.*开头的类)，开发者可以直接使用扩展类加载器</li>
<li>应用程序类加载器：它负责加载用户类路径(ClassPath)所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li>
</ul>
<h5 id="双亲委派机制："><a href="#双亲委派机制：" class="headerlink" title="双亲委派机制："></a>双亲委派机制：</h5><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
<h3 id="Java-执行流程"><a href="#Java-执行流程" class="headerlink" title="Java 执行流程"></a>Java 执行流程</h3><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/1c1d85b5fb8b47239af2a5c0436eb2d7-new-image0cd10827-2f96-433c-9b16-93d4fe491d88.png" alt="img"></p>
<h3 id="jdk自带的监控工具"><a href="#jdk自带的监控工具" class="headerlink" title="jdk自带的监控工具"></a>jdk自带的监控工具</h3><ul>
<li>jps查看java所有进程</li>
<li>jmap生成堆转储快照</li>
<li>jstack生成当前线程快照</li>
<li>jstat;查看虚拟机运行状态信息</li>
</ul>
<p>可视化：jconsole</p>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p> 主要提供终端设备之间的应用程序之间的信息通讯，在应用层方面定义了消息的格式。</p>
<p>常见的应用层协议：</p>
<ul>
<li>http：超文本传输协议</li>
<li>SMTP：简单的邮件传输协议</li>
<li>FTP：文件传输协议</li>
<li>Telnet：远程登陆协议</li>
<li>SSH：安全的网络传输协议</li>
</ul>
<h5 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h5><p>负责终端设备进程之间的数据传输：</p>
<p><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</p>
<p><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）</p>
<h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>​    将传输层的数据在网络逻辑地址之间传输。</p>
<p>常见的网络层协议：</p>
<ul>
<li>IP：IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。有IPv4和IPv6</li>
<li>ARP：解决的是网络层地址和链路层地址之间的转换问题。将iP转换为mac地址的协议</li>
<li>NAT：应用于内部网到外部网的地址转换，局域网下的ip转换为互联网的公网IP</li>
<li>RIP、OSPF路由选择协议</li>
</ul>
<h5 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h5><p>是数据链路层和物理层的组合。</p>
<p>数据链路层负责将网络层的数据组装为帧，在相邻节点上传输帧（地址信息和差错校验）</p>
<p>物理层则是相邻节点的比特流的传输</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><ul>
<li>是否面向连接，tcp是面向连接的，而udp是不需要连接的</li>
<li>tcp是基于字节流的，udp是基于报文的</li>
<li>tcp是可靠传输，在tcp传递数据的时候，首先会有建立连接，其次在传输数据时，有消息确认、滑动窗口、和消息重传以及拥塞控制，而UDP不是可靠传输，消息发出去就完了</li>
<li>传输效率:tcp多了连接、确认、重传，所以传输效率比udp低</li>
<li>传输开销：tcp的首部4开销比udp首部开销大</li>
<li>tcp只支持点对点，而udp支持多对多</li>
<li>tcp讲究数据的准确率，而udp讲究速率。</li>
</ul>
<h4 id="什么时候选择-TCP-什么时候选-UDP"><a href="#什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="什么时候选择 TCP,什么时候选 UDP?"></a>什么时候选择 TCP,什么时候选 UDP?</h4><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等</li>
</ul>
<p>运行在udp之上的协议：DHCP和DNS</p>
<h4 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h4><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解"></p>
<ul>
<li>第一次：客户端向服务器发送syn&#x3D;x的请求数据包，然后客户端今日SYN_SEND状态，等待服务器响应</li>
<li>第二次：服务器受到客户端的数据包，向客户端返回一个SYN&#x3D;y,ACK&#x3D;x+1的数据包，然后服务器进入SYN_RECV状态</li>
<li>第三次：客户端收到服务器的数据包，向服务器发送ACK&#x3D;y+1的数据包，然后都进入ESTABLELISH,然后就可以传输数据了</li>
</ul>
<p><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p>
<p><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p>
<h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解"></p>
<p>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</p>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<p>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</p>
<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/HexoBlog/tags/%E5%87%86%E5%A4%87/">#准备</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/HexoBlog/2022/11/29/%E5%87%86%E5%A4%871/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">准备1</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">lj</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#day1"><span class="nav-number">1.</span> <span class="nav-text">day1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql"><span class="nav-number">1.1.</span> <span class="nav-text">mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">存储引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">1.存储引擎是什么，</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-mysql%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">2.mysql中常见的存储引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">数据库的事务隔离级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">mysql 索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E9%94%AE%E9%80%9A%E5%B8%B8%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9Eid"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">为什么主键通常建议使用自增id</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day2"><span class="nav-number">2.</span> <span class="nav-text">day2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MyISAM-%E5%92%8C-InnoDB-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">MyISAM 和 InnoDB 如何选择？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">MySQL 查询缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.0.0.3.1.</span> <span class="nav-text">MVCC 是什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">2.0.0.3.2.</span> <span class="nav-text">当前读和快照读</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A5%BD%E5%A4%84"><span class="nav-number">2.0.0.3.3.</span> <span class="nav-text">MVCC 解决的问题以及好处</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.0.0.3.4.</span> <span class="nav-text">MVCC和当前读、快照读的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E4%B8%AA%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">2.0.0.3.5.</span> <span class="nav-text">4个隐式字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#undo-log"><span class="nav-number">2.0.0.3.6.</span> <span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#read-view%EF%BC%88%E8%AF%BB%E8%A7%86%E5%9B%BE%EF%BC%89"><span class="nav-number">2.0.0.3.7.</span> <span class="nav-text">read view（读视图）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9ARR%E5%92%8CRC%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84read-view"><span class="nav-number">2.0.0.3.8.</span> <span class="nav-text">MVCC相关问题：RR和RC级别下的read view</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-3-12-5"><span class="nav-number">3.</span> <span class="nav-text">day 3 12.5</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E9%94%81"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">mysql 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="nav-number">3.0.0.1.1.</span> <span class="nav-text">表锁和行锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.0.0.1.2.</span> <span class="nav-text">行锁的使用的注意事项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">3.0.0.1.3.</span> <span class="nav-text">共享锁和排他锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">3.0.0.1.4.</span> <span class="nav-text">意向锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#innoDb-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A1%8C%E9%94%81"><span class="nav-number">3.0.0.1.5.</span> <span class="nav-text">innoDb 有哪些行锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">mysql 三大日志</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#redo-log"><span class="nav-number">3.0.0.2.1.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#redo-log%E5%B0%8F%E7%BB%93"><span class="nav-number">3.0.0.2.2.</span> <span class="nav-text">redo log小结</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bin-log"><span class="nav-number">3.0.0.2.3.</span> <span class="nav-text">bin log</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">两阶段提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">sql语句执行流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day4-12-12"><span class="nav-number">4.</span> <span class="nav-text">day4 12.12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">创建型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">建造器模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">原型模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">结构型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">适配器模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-5-12-13"><span class="nav-number">5.</span> <span class="nav-text">day 5 12.13</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.3.</span> <span class="nav-text">享元模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.4.</span> <span class="nav-text">装饰器模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E6%80%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.</span> <span class="nav-text">行为性设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">观察者模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-6-12-14"><span class="nav-number">6.</span> <span class="nav-text">day 6 12.14</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">模板方法模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.3.</span> <span class="nav-text">迭代器模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">设计模式总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-7-12-15"><span class="nav-number">7.</span> <span class="nav-text">day 7  12.15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%9F%BA%E7%A1%80"><span class="nav-number">7.1.</span> <span class="nav-text">java 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk%E3%80%81jre%E3%80%81jvm-jit%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81Aot"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">jdk、jre、jvm jit编译器、Aot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4java%E6%98%AF%E8%A7%A3%E9%87%8A%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%BB%93%E5%90%88"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">为什么说java是解释与编译型语言结合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java-%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">java 和C++的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">7.2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81"><span class="nav-number">7.2.2.</span> <span class="nav-text">静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">7.2.3.</span> <span class="nav-text">重载和重写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.1.</span> <span class="nav-text">包装类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6"><span class="nav-number">7.3.2.</span> <span class="nav-text">浮点数运算丢失精度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">7.4.</span> <span class="nav-text">面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93"><span class="nav-number">7.4.1.</span> <span class="nav-text">对象的引用和对象实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">7.4.2.</span> <span class="nav-text">深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">7.4.3.</span> <span class="nav-text">Object常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%B1%BB%EF%BC%9A"><span class="nav-number">7.4.4.</span> <span class="nav-text">String类：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-8-2-5"><span class="nav-number">8.</span> <span class="nav-text">day 8 2.5</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">8.1.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Exception-%E5%92%8C-Error-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">8.1.1.</span> <span class="nav-text">Exception 和 Error 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-try-with-resources-%E4%BB%A3%E6%9B%BFtry-catch-finally%EF%BC%9F"><span class="nav-number">8.1.2.</span> <span class="nav-text">如何使用 try-with-resources 代替try-catch-finally？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-SPI"><span class="nav-number">8.3.</span> <span class="nav-text">java SPI</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">8.4.</span> <span class="nav-text">java 序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">8.5.</span> <span class="nav-text">java内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="nav-number">8.5.1.</span> <span class="nav-text">运行时数据区域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">8.5.2.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">8.5.3.</span> <span class="nav-text">虚拟机栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">8.5.4.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">8.5.5.</span> <span class="nav-text">运行时常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">8.5.6.</span> <span class="nav-text">字符串常量池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hotSpot%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="nav-number">8.6.</span> <span class="nav-text">hotSpot的对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">8.6.1.</span> <span class="nav-text">对象的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%9F%A5"><span class="nav-number">8.6.1.1.</span> <span class="nav-text">一:类加载检查</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%EF%BC%9A%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">8.6.1.2.</span> <span class="nav-text">二：分配空间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%EF%BC%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%B6%E5%80%BC"><span class="nav-number">8.6.1.3.</span> <span class="nav-text">三：初始化零值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%EF%BC%9A%E8%AE%BE%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">8.6.1.4.</span> <span class="nav-text">四：设置对象头</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%94%EF%BC%9A%E6%89%A7%E8%A1%8Cinit%E6%96%B9%E6%B3%95"><span class="nav-number">8.6.1.5.</span> <span class="nav-text">五：执行init方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">8.6.2.</span> <span class="nav-text">对象的内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="nav-number">8.6.3.</span> <span class="nav-text">对象的访问定位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%A5%E6%9F%84"><span class="nav-number">8.6.3.1.</span> <span class="nav-text">句柄</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88"><span class="nav-number">8.6.3.2.</span> <span class="nav-text">直接指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-9-2-8"><span class="nav-number">8.7.</span> <span class="nav-text">day 9 2.8</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">8.7.1.</span> <span class="nav-text">集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-list"><span class="nav-number">8.7.2.</span> <span class="nav-text">collection-list</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#arraylist%E6%BA%90%E7%A0%81%E6%89%A9%E5%AE%B9%E5%88%86%E6%9E%90"><span class="nav-number">8.7.2.1.</span> <span class="nav-text">arraylist源码扩容分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ensureCapacity"><span class="nav-number">8.7.2.2.</span> <span class="nav-text">ensureCapacity</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-set"><span class="nav-number">8.7.3.</span> <span class="nav-text">collection-set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-queue"><span class="nav-number">8.7.4.</span> <span class="nav-text">collection-queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#collection-map"><span class="nav-number">8.7.5.</span> <span class="nav-text">collection-map</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Hashmap%E5%92%8Chashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.7.5.1.</span> <span class="nav-text">Hashmap和hashtable的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashset%E5%92%8Chashmap"><span class="nav-number">8.7.5.2.</span> <span class="nav-text">hashset和hashmap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hashmap%E5%92%8Ctreemap"><span class="nav-number">8.7.5.3.</span> <span class="nav-text">hashmap和treemap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#concurrentmap"><span class="nav-number">8.7.5.4.</span> <span class="nav-text">concurrentmap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO"><span class="nav-number">8.8.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO"><span class="nav-number">8.8.1.</span> <span class="nav-text">同步阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">8.8.2.</span> <span class="nav-text">同步非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">8.8.3.</span> <span class="nav-text">IO多路复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AIO-%E5%BC%82%E6%AD%A5"><span class="nav-number">8.8.4.</span> <span class="nav-text">AIO 异步</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%B9%B6%E5%8F%91"><span class="nav-number">8.9.</span> <span class="nav-text">java 并发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">8.9.1.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A2%84%E9%98%B2%E5%92%8C%E7%A0%B4%E5%9D%8F%E6%AD%BB%E9%94%81"><span class="nav-number">8.9.1.1.</span> <span class="nav-text">预防和破坏死锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#wait-%E5%92%8Csleep"><span class="nav-number">8.9.2.</span> <span class="nav-text">wait 和sleep</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS"><span class="nav-number">8.9.3.</span> <span class="nav-text">CAS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#volatile%EF%BC%88%E7%BB%93%E5%90%88%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E6%9D%A5%E8%AE%B0%E5%BF%86%EF%BC%89"><span class="nav-number">8.9.4.</span> <span class="nav-text">volatile（结合单例模式的线程安全的双重检查来记忆）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized"><span class="nav-number">8.9.5.</span> <span class="nav-text">synchronized</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">8.9.6.</span> <span class="nav-text">偏向锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A"><span class="nav-number">8.9.7.</span> <span class="nav-text">轻量级锁：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">8.9.8.</span> <span class="nav-text">重量级锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E5%92%8Creentrantlock"><span class="nav-number">8.9.9.</span> <span class="nav-text">synchronized和reentrantlock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">8.9.10.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Atomic"><span class="nav-number">8.9.11.</span> <span class="nav-text">Atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Atomic%E4%B8%BB%E8%A6%81%E5%88%86%E4%B8%BA%E5%9B%9B%E7%B1%BB"><span class="nav-number">8.9.11.1.</span> <span class="nav-text">Atomic主要分为四类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JMM"><span class="nav-number">8.9.12.</span> <span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81JMM"><span class="nav-number">8.9.12.1.</span> <span class="nav-text">为什么需要JMM</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BF%9D%E8%AF%81%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E5%9C%A8%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">8.9.12.2.</span> <span class="nav-text">保证共享变量在主内存和线程本地内存的一致性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Happens-before"><span class="nav-number">8.9.12.3.</span> <span class="nav-text">Happens-before</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-9-2-9"><span class="nav-number">8.10.</span> <span class="nav-text">day 9 2.9</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-%E7%BA%BF%E7%A8%8B"><span class="nav-number">8.10.1.</span> <span class="nav-text">java 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">8.10.1.1.</span> <span class="nav-text">线程池的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BB%BA%E8%AE%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">8.10.1.2.</span> <span class="nav-text">建议使用ThreadPoolExecutor构造函数建议线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ThreadPoolExecutor%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="nav-number">8.10.1.3.</span> <span class="nav-text">ThreadPoolExecutor构造函数参数解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C"><span class="nav-number">8.10.1.4.</span> <span class="nav-text">线程池运行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">8.10.1.5.</span> <span class="nav-text">任务的执行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%8F%90%E4%BA%A4"><span class="nav-number">8.10.1.6.</span> <span class="nav-text">任务的提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%85%B3%E9%97%AD"><span class="nav-number">8.10.1.7.</span> <span class="nav-text">任务的关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="nav-number">8.10.1.8.</span> <span class="nav-text">线程池的线程数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="nav-number">8.10.1.9.</span> <span class="nav-text">使用线程池的注意事项：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS"><span class="nav-number">8.10.2.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="nav-number">8.10.2.1.</span> <span class="nav-text">AQS是什么：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="nav-number">8.10.2.2.</span> <span class="nav-text">AQS的核心思想：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="nav-number">8.10.2.3.</span> <span class="nav-text">AQS对资源的共享方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E5%BA%95%E5%B1%82%E4%BD%BF%E7%94%A8%E4%BA%86%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.10.2.4.</span> <span class="nav-text">AQS底层使用了模板模式的设计模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">8.10.2.5.</span> <span class="nav-text">AQS 数据结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E8%BF%87%E7%A8%8B"><span class="nav-number">8.10.2.6.</span> <span class="nav-text">AQS过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AQS%E6%80%BB%E7%BB%93"><span class="nav-number">8.10.2.7.</span> <span class="nav-text">AQS总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#day-10-2-10"><span class="nav-number">8.11.</span> <span class="nav-text">day 10 2.10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">8.12.</span> <span class="nav-text">JVM垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E7%A9%BA%E9%97%B4%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">8.12.0.1.</span> <span class="nav-text">堆空间的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">8.12.0.2.</span> <span class="nav-text">内存分配以及基本原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E8%80%8C%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="nav-number">8.12.0.3.</span> <span class="nav-text">死亡对象而判断方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">8.12.1.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%B8%B8%E9%87%8F%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="nav-number">8.12.2.</span> <span class="nav-text">如何判断常量是垃圾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E6%98%AF%E6%97%A0%E7%94%A8%E7%9A%84%E7%B1%BB"><span class="nav-number">8.12.3.</span> <span class="nav-text">如何判断类是无用的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">8.12.4.</span> <span class="nav-text">垃圾回收算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">8.12.5.</span> <span class="nav-text">垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#serial-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.1.</span> <span class="nav-text">serial 收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scanvenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.3.</span> <span class="nav-text">Parallel Scanvenge收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.4.</span> <span class="nav-text">CMS收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">8.12.5.5.</span> <span class="nav-text">G1收集器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="nav-number">8.13.</span> <span class="nav-text">类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">8.13.0.0.1.</span> <span class="nav-text">类加载器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="nav-number">8.13.0.1.</span> <span class="nav-text">双亲委派机制：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">8.14.</span> <span class="nav-text">Java 执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk%E8%87%AA%E5%B8%A6%E7%9A%84%E7%9B%91%E6%8E%A7%E5%B7%A5%E5%85%B7"><span class="nav-number">8.15.</span> <span class="nav-text">jdk自带的监控工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="nav-number">8.16.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-x2F-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.16.1.</span> <span class="nav-text">TCP&#x2F;IP四层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">8.16.1.1.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">8.16.1.2.</span> <span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">8.16.1.3.</span> <span class="nav-text">网络层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82"><span class="nav-number">8.16.1.4.</span> <span class="nav-text">网络接口层</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.16.2.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9-TCP-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89-UDP"><span class="nav-number">8.16.3.</span> <span class="nav-text">什么时候选择 TCP,什么时候选 UDP?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">8.16.4.</span> <span class="nav-text">TCP的三次握手和四次挥手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">8.16.4.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">8.16.4.2.</span> <span class="nav-text">四次挥手</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/HexoBlog/js/utils.js"></script>

<script src="/HexoBlog/js/main.js"></script>

<script src="/HexoBlog/js/header-shrink.js"></script>

<script src="/HexoBlog/js/back2top.js"></script>

<script src="/HexoBlog/js/dark-light-toggle.js"></script>





    
<script src="/HexoBlog/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/HexoBlog/js/left-side-toggle.js"></script>

<script src="/HexoBlog/js/libs/anime.min.js"></script>

<script src="/HexoBlog/js/toc.js"></script>

    
</div>



</body>
</html>

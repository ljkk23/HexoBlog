<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="lj">
    
    <title>
        
            准备2 |
        
        LjBlog
    </title>
    
<link rel="stylesheet" href="/HexoBlog/css/style.css">

    <link rel="shortcut icon" href="/HexoBlog/images/logo.svg">
    
<link rel="stylesheet" href="/HexoBlog/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"ljkk23.github.io","root":"/HexoBlog/","language":"zh-CN"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.svg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/HexoBlog/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                LjBlog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/HexoBlog/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/HexoBlog/categories">分类</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">准备2</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/HexoBlog/images/avatar.svg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">lj</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-11-30 17:06:49</span>
        <span class="mobile">2022-11-30 17:06</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/categories/%E5%87%86%E5%A4%87/">准备</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/HexoBlog/tags/%E5%87%86%E5%A4%87/">准备</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h2 id="day1"><a href="#day1" class="headerlink" title="day1"></a>day1</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><h5 id="1-存储引擎是什么，"><a href="#1-存储引擎是什么，" class="headerlink" title="1.存储引擎是什么，"></a>1.存储引擎是什么，</h5><p>​    在百度百科上是这样说的：</p>
<pre class="line-numbers language-none"><code class="language-none"> MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。

 例如，如果你在研究大量的临时数据，你也许需要使用内存存储引擎。内存存储引擎能够在内存中存储所有的表格数据。又或者，你也许需要一个支持[事务处理]的数据库(以确保事务处理不成功时数据的回退能力)。

这些不同的技术以及配套的相关功能在MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎，可以预先设置或者在MySQL服务器中启用。你可以选择适用于服务器、数据库和表格的存储引擎，以便在选择如何存储你的信息、如何检索这些信息以及你需要你的数据结合什么性能和功能的时候为你提供最大的灵活  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>总结：</p>
<p>​    1.mysql根据不同的使用者的不同需求，在存储机制、索引技巧以及锁等方面有不同的实现，这些不同的技术配套组合起来就称为存储引擎。</p>
<p>​    2.存储引擎是基于插件式架构，支持多重存储引擎，因为存储引擎是基于表的，所以我们甚至可以为不同的数据库设置不同的存储引擎，自己也可以根据mysql的标准存储引擎实现接口编写一个自己的存储引擎</p>
<h5 id="2-mysql中常见的存储引擎"><a href="#2-mysql中常见的存储引擎" class="headerlink" title="2.mysql中常见的存储引擎"></a>2.mysql中常见的存储引擎</h5><p>​     mysql 5.5之前的默认存储引擎是 MyISAM,MyISAM的性能也不错，在全文索引、压缩、空间函数等都体现不错，但是因为不支持事务和行级锁，而且崩溃后无法安全恢复数据，所以就在mysql5.5之后，取而代之的是InnoDB，对比一下两个常见的存储引擎：</p>
<p>1.是否支持行级锁：</p>
<p>  MyISAM只支持表级锁，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。所以在并发的时候就知道InnoDB的优势了</p>
<p>2.是否支持事务</p>
<p>MyISAM不提供支持事务</p>
<p>​    innoDB支持事务，实现了sql标准的四个隔离级别，默认使用的是可重复读，可以解决幻读。具体事务级别看后面</p>
<p>3.是否支持外键</p>
<p>​    myISAM不支持外键，innoDB支持外键。</p>
<p>​    外键的好处能对数据库的维护数据一致性有很好的帮助，但是在阿里的开发手册中明确提出禁止用外键，所以我们通常在开发项目的时候不再数据库层面使用外键，而将其在应用层实现，不过，到底用不用还是得看实际的项目</p>
<p>4.是否支持数据库崩溃之后数据的安全恢复</p>
<p>​    myISAM不支持。而mysql支持，mysql这个恢复i的过程基于redo log</p>
<p>5.索引的实现不一样</p>
<p>​    虽然都是用的B+树作索引，myISAM是索引文件而数据文件分离，innoDB数据文件就是索引文件，具体看后面</p>
<h5 id="数据库的事务隔离级别"><a href="#数据库的事务隔离级别" class="headerlink" title="数据库的事务隔离级别"></a>数据库的事务隔离级别</h5><p>（1）读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
<p>问题：</p>
<p>​    在一个事务a开启之后数据为2，如果另一个事务b修改了这数据3，a再读取这数据就为3，但是b事务回滚了，数据又变成了2,这里就出现了脏读</p>
<p>（2）读已提交：可以解决脏读，在一个事务开启时，另一个事务修改的数据必须提交之后才能被其他事务读到</p>
<p>（3）可重复读：： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
<p>解决不可重复读：</p>
<p>​        当b事务提交之后，a再次读这个数据就为3了，但是之前b事务还没有提交的时候，a就读取了这个数据为2,这样就造成了前后读的数据不一致，这就是不可重复读，所以如果是这个级别，之后再读取这个数据就还会是2。</p>
<p>问题：</p>
<p>​    但是会出现幻读，和可重复读差不多，只不过这次b事务不是去修改a读过的数据，而是增加或修改了其他数据，导致a事务再次去读的时候，就出现了两条数据（如果之前是一条数据），</p>
<p>解决幻读：</p>
<ol>
<li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li>
</ol>
<p>（4）可串行化：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
<p>总结：</p>
<p>1.因为隔离级别越低，事务请求的锁越少，所以可串行化对并发量不太友好，所以mysql中innoDB默认隔离级别是不可重复读且解决了幻读的问题，虽然一般的数据库是读已提交，但是innoDB的可重复读不会有任何性能损失。</p>
<p>2.innoDB解决幻读：通过MVCC机制快照读、使用Next-key Lock（Record Lock+Gap Lock）实现当前读</p>
<h5 id="mysql-索引"><a href="#mysql-索引" class="headerlink" title="mysql 索引"></a>mysql 索引</h5><p>1.索引是什么：</p>
<p>索引是一种快速查找数据和检索数据的数据结构</p>
<p>2.索引的优缺点：</p>
<p>优点：</p>
<ul>
<li>大大加快了检索数据的速度</li>
<li>如果建立唯一性索引，还可以保证数据的唯一性</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引需要空间，耗费空间</li>
<li>创建和维护索引也需要一定的耗费时间，在对表进行增删查改的时候，有索引就需要维护索引，降低sql的执行效率</li>
</ul>
<p>3.索引底层数据结构</p>
<p>（1）hash表，虽然hash表查询速度很快，但是因为hash不支持顺序和范围查询，而且每次IO只能取一个数据</p>
<p>（2）b树和B+树：</p>
<p>​    b树的所有节点都存放数据和key,这就导致了枝干节点的能够存放key的存储空间就比完全存放key的存储空间小，所以就导致整个树存储的数据比B+树少。</p>
<p>​    b+树叶子节点有一条链表，在范围查询的时候比b树少一次IO</p>
<p>​    B+树检索效率稳定，因为数据都在叶子节点</p>
<p>4.myISAM和innoDB都是用的B+树</p>
<p>但是不同点：</p>
<p>​    myISAM用的是非聚簇索引，即叶子节点存放的是data的指针，找到叶子节点之后，需要多一次IO去读取真正的数据</p>
<pre><code> innoDb用的是聚簇索引，叶子节点直接存放的是data。
</code></pre>
<p>5.索引的类型</p>
<p>主键索引：拿主键作为索引，通过主键索引找到叶子节点存放的就是data</p>
<p>二级索引：通过二级索引找到叶子节点，存放的就是主键的信息，然后再通过主键去找到data</p>
<p>聚簇索引优缺点：</p>
<p>优点：</p>
<p>​    （1）查询data时速度更快，比较与非聚簇少一个IO操作</p>
<p>​    （2）<strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</p>
<p>缺点：</p>
<p>​    数据更改，索引就要更改，代价较大，非聚簇索引的数据改时，索引不用改，</p>
<p>非聚簇：</p>
<p>优点：</p>
<p>​    数据更改，索引的树不用更改</p>
<p>缺点：</p>
<p>​     可能会二次查询。</p>
<p>演示innoDB聚簇索引的主键索引和二级索引，和myIsam的非聚簇索引的主键索引和二级索引</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/suoying.png"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用”where id &#x3D; 14”这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</li>
<li>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</li>
</ol>
<p>MyISM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
<p><strong>选择合适的字段创建索引</strong></p>
<ul>
<li>经常查询的字段</li>
<li>不为空对象的字段</li>
<li>作为条件的字段</li>
<li>频繁作为连接的字段</li>
<li>频繁更新的不适合作为索引</li>
</ul>
<p>​    innoDB选择默认是主键作为索引，如果没有主键就找一个唯一且不为null的字段，如果都没有，就自己生成一个6字节的索引，所以主键一般不为uuid或字符串这种难排序的，最好是自增的，因为这样方便插入和排序。</p>
<h5 id="为什么主键通常建议使用自增id"><a href="#为什么主键通常建议使用自增id" class="headerlink" title="为什么主键通常建议使用自增id"></a><strong>为什么主键通常建议使用自增id</strong></h5><p>​    因为使用自增 id 可以避免页分裂，因为聚簇索引的物理存放顺序和索引顺序是一致的，只要索引相邻，对应的数据也相邻，如果主键不是自增id,那么就会不断的调整数据的物理分页。为什么呢？一下是解释</p>
<p>​    mysql 在底层又是以数据页为单位来存储数据的，一个数据页大小默认为 16k，当然你也可以自定义大小，也就是说如果一个数据页存满了，mysql 就会去申请一个新的数据页来存储数据。</p>
<p>​    如果主键为自增 id 的话，mysql 在写满一个数据页的时候，直接申请另一个新数据页接着写就可以了。</p>
<p>​    如果主键是非自增 id，为了确保索引有序，mysql 就需要将每次插入的数据都放到合适的位置上。</p>
<p>​    当往一个快满或已满的数据页中插入数据时，新插入的数据会将数据页写满，mysql 就需要申请新的数据页，并且把上个数据页中的部分数据挪到新的数据页上。</p>
<p>对主键 id 还有一个小小的要求，在满足业务需求的情况下，尽量使用占空间更小的主键 id，因为普通索引的叶子节点上保存的是主键 id 的值，如果主键 id 占空间较大的话，那将会成倍增加 mysql 空间占用大小</p>
<h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><h5 id="MyISAM-和-InnoDB-如何选择？"><a href="#MyISAM-和-InnoDB-如何选择？" class="headerlink" title="MyISAM 和 InnoDB 如何选择？"></a>MyISAM 和 InnoDB 如何选择？</h5><p>​    一般来说我们都选择innoDB,因为innoDB支持事务、行锁、崩溃后数据能够安全恢复，这几个myISAM都不能做到，但是这几个又是我们日常业务的必须，其实innoDB的速度并不一定比myISAM慢，比如聚簇索引就比非聚簇索引少一层IO操作</p>
<h5 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="MySQL 查询缓存"></a>MySQL 查询缓存</h5><p>​    在mysql8之前有，查询数据之前，会先查询缓存，但是在mysql8之后就移除了这个功能，原因是虽然缓存能够提高查询速度，但是维护和更新缓存无疑会增加带来额外开销，每一次操作之后都会做一次缓存操作，而且更新缓存和缓存不击中的情况比较多：（1）查询条件不同（2）缓存的数据的所在表更改（3）查询条件中函数以及临时表都不会缓存。</p>
<h5 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h5><p>参考：<a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html#%E4%BB%80%E4%B9%88%E6%98%AFmvcc" >https://pdai.tech/md/db/sql-mysql/sql-mysql-mvcc.html#%E4%BB%80%E4%B9%88%E6%98%AFmvcc<i class="fas fa-external-link-alt"></i></a></p>
<h6 id="MVCC-是什么"><a href="#MVCC-是什么" class="headerlink" title="MVCC 是什么"></a>MVCC 是什么</h6><p>​    MVCC，全称Multi-Version Concurrency Control，即多版本并发控制。是一种控制并发的方法，是一种理念，在数据库管理系统中，实现对数据库的并发，在编程语言中实现事务。</p>
<h6 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h6><p>​    在了解MVCC之前，先知道什么是当前读和快照读</p>
<p>​    当前读：读取的是数据的最新版本，读取时会对数据进行加锁，例如：像select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读</p>
<p>​    快照读：不加锁的读就是快照读，之所以会出现快照读，是因为提高并发，所以快照读基于多版本并发，他避免了加锁，因为是多版本，所以难免会读到数据的旧版本。</p>
<p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<h6 id="MVCC-解决的问题以及好处"><a href="#MVCC-解决的问题以及好处" class="headerlink" title="MVCC 解决的问题以及好处"></a>MVCC 解决的问题以及好处</h6><p>数据库并发场景?</p>
<p>有三种, 分别为：</p>
<ul>
<li><strong>读-读</strong>：不存在任何问题，也不需要并发控制</li>
<li><strong>读-写</strong>：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读</li>
<li><strong>写-写</strong>：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失</li>
</ul>
<p>MVCC带来的好处是？</p>
<p>MVCC多版本并发控制是一种解决读写冲突的无锁非阻塞，他为每一个事务分配一个单向增长的时间戳，版本与该时间戳关联，读操作（快照读）只读取该事务开始的版本</p>
<p>在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决更新丢失问题</p>
<h6 id="MVCC和当前读、快照读的关系"><a href="#MVCC和当前读、快照读的关系" class="headerlink" title="MVCC和当前读、快照读的关系"></a>MVCC和当前读、快照读的关系</h6><p>​    准确的说，MVCC只是一个理念，所以我们需要在数据库中实现，为了在数据库中实现这么一个理念，快照读就出来了，他解决了在读写问题中的阻塞问题。但其实MVCC整套理念的实现不仅只有一个快照读，MVCC模型的实现是靠4个隐式字段和undo log和readView实现的。</p>
<h6 id="4个隐式字段"><a href="#4个隐式字段" class="headerlink" title="4个隐式字段"></a>4个隐式字段</h6><p>每行记录除了我们自定义的字段外，还有数据库隐式定义的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID等字段</p>
<ul>
<li><strong>DB_ROW_ID</strong> 6byte, 隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引</li>
<li><strong>DB_TRX_ID</strong> 6byte, 最近修改(修改&#x2F;插入)事务ID：记录创建这条记录&#x2F;最后一次修改该记录的事务ID</li>
<li><strong>DB_ROLL_PTR</strong> 7byte, 回滚指针，指向这条记录的上一个版本（存储于rollback segment里）</li>
<li><strong>DELETED_BIT</strong> 1byte, 记录被更新或删除并不代表真的删除，而是删除flag变了</li>
</ul>
<p>这里注意最后一个字段，</p>
<h6 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h6><p>不同事务或者相同事务的对同一记录的修改，会导致该记录的undo log成为一条记录版本线性表，即链表，undo log的链首就是最新的旧记录，链尾就是最早的旧记录（当然就像之前说的该undo log的节点可能是会purge线程清除掉，向图中的第一条insert undo log，其实在事务提交之后可能就被删除丢失了，不过这里为了演示，所以还放在这里）</p>
<h6 id="read-view（读视图）"><a href="#read-view（读视图）" class="headerlink" title="read view（读视图）"></a>read view（读视图）</h6><p>就是在事务快照读的时候，能够读到的数据是事务的哪些版本。</p>
<p>read view 有三个全局属性，这三个属性都是全局的</p>
<p><strong>trx_list</strong> 未提交事务ID列表，用来维护Read View生成时刻系统正活跃的事务ID</p>
<p><strong>up_limit_id</strong> 记录trx_list列表中事务ID最小的ID</p>
<p><strong>low_limit_id</strong> ReadView生成时刻系统尚未分配的下一个事务ID，也就是目前已出现过的事务ID的最大值+1</p>
<p>生成read view流程：</p>
<ul>
<li>1.在某一个事务中快照读取某个数据时，首先看该数据的事务的隐式字段事务id是否小于<strong>up_limit_id</strong> （记录trx_list列表中事务ID最小的ID），如果是，就说明这个是已经提交的数据，可以读</li>
<li>如果不小于当前活跃事务的最小id,就判断是否大于<strong>low_limit_id</strong>，如果是，说明该事务不符合可见性</li>
<li>如果不大于low_limit_id，说明该事务处于活跃中，则去该事务的undo log中找事务id,再次通过流程判断，直到符合可见性</li>
</ul>
<h6 id="MVCC相关问题：RR和RC级别下的read-view"><a href="#MVCC相关问题：RR和RC级别下的read-view" class="headerlink" title="MVCC相关问题：RR和RC级别下的read view"></a>MVCC相关问题：RR和RC级别下的read view</h6><p><strong>总之在RC隔离级别下，是每个快照读都会生成并获取最新的Read View；而在RR隔离级别下，则是同一个事务中的第一个快照读才会创建Read View, 之后的快照读获取的都是同一个Read View</strong>。</p>
<p>所以RC会出现不可重复读，RR会解决这个问题</p>
<h2 id="day-3-12-5"><a href="#day-3-12-5" class="headerlink" title="day 3 12.5"></a>day 3 12.5</h2><h5 id="mysql-锁"><a href="#mysql-锁" class="headerlink" title="mysql 锁"></a>mysql 锁</h5><h6 id="表锁和行锁"><a href="#表锁和行锁" class="headerlink" title="表锁和行锁"></a>表锁和行锁</h6><p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h6 id="行锁的使用的注意事项"><a href="#行锁的使用的注意事项" class="headerlink" title="行锁的使用的注意事项"></a>行锁的使用的注意事项</h6><p>​    innoDB的行锁的是针对索引字段，表极锁是针对非索引字段，所以当我们执行update delete语句时，如果where未命中索引或者索引失效的话，就会全表的所有行记录进行加锁，所以这里要注意。</p>
<p>​    这里需要注意的是，虽然我们用了索引，但是有些时候还会走全局扫描，所以这就是后面mysql优化器</p>
<h6 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h6><p>​    不论是表锁还是行锁，都有共享锁和排他锁，由于MVCC的存在，所以一般的select语句是不会加任何锁的，可以显式的加锁查询</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//共享锁</span>
select <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lock in share mode
 <span class="token comment">//排他锁</span>
    select <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> update   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h6 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h6><p>意向锁就是，在加表锁的时候，肯定需要去判断该表是否加了行锁，那怎么判断呢，如果一行一行的去遍历，性能太差，优秀的程序员怎么能容忍这种事情发生呢，所以就有了一个意向锁，在加共享锁或者排他锁之前，需要首先获得意向锁，比如加共享锁时，需要首先获得该记录的意向共享锁</p>
<h6 id="innoDb-有哪些行锁"><a href="#innoDb-有哪些行锁" class="headerlink" title="innoDb 有哪些行锁"></a>innoDb 有哪些行锁</h6><p>mysql 支持三种行锁</p>
<ul>
<li>记录锁（record lock），属于单个行的锁</li>
<li>间隙锁（Gap lock）：锁定一个范围，不包括记录本身</li>
<li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>mysql innoDB的RR是可以解决幻读的，本来一般的事务隔离级别为RR都不会解决幻读的，mysql innodb能解决是以下两种情况：</p>
<ul>
<li>快照读：通过mvcc机制保证不出现幻读，核心就是生成read view</li>
<li>当前读：使用next-key lock 来加锁解决幻读</li>
</ul>
<h5 id="mysql-三大日志"><a href="#mysql-三大日志" class="headerlink" title="mysql 三大日志"></a>mysql 三大日志</h5><h6 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h6><p>​    redo log （重做日志）是innodb独有的，这也是前面说过的innoDB相比于myISAM的优势：能够在宕机后安全的恢复数据，就是基于这个实现的</p>
<p>​    因为mysql 中的数据是以页为单位的，所以当你查询一条记录的时候，会把记所在的一页数据都加载到出来，放入到    BUffer pool，然后后续查找先去Buffer pool 中查找，包括更新数据也是先更新Buffer pool中的数据，然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/03.png"></p>
<p><strong>redo log的刷盘时机</strong></p>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略</p>
<p><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</p>
<p><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</p>
<p><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p>redo log 是由一组日志文件组</p>
<h6 id="redo-log小结"><a href="#redo-log小结" class="headerlink" title="redo log小结"></a>redo log小结</h6><p>​    上面讲了redo log 的作用机制、刷盘时机以及存储形式。现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p> 这里就有几个不同：</p>
<ul>
<li>一是：每次修改数据页可能就修改了几byte，这样就刷盘的话，会浪费资源</li>
<li>二是：而且数据页的刷盘是随机读写，因为如果主键索没有用自增id,就有可能就造成数据页的刷盘的随机读写，性能很低，而日志文件都是一行记录占用byte少，而且日志文件是顺序读写，大大增强了性能，</li>
</ul>
<h6 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h6><p>​    redo log 是属于物理日志，记录的是在“某个数据页上做了什么修改”，属于innoDB存储引擎的;</p>
<p>​    而bin log 属于归档日志，记录的是sql语句或者说记录的是sql语句的逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于mysql server层的，不管用什么存储引擎，只要表数更改了，就会产生bin log</p>
<p>​    bin log 到底是干嘛的，有什么作用： binlog 主要用与数据库的备份、主从复制等，依靠bin log 来同步数据库，保持数据一致性。</p>
<p><strong>记录格式</strong></p>
<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><p><strong>statement</strong>：记录的是sql的原语句：</p>
</li>
<li><p><strong>row</strong>：记录的增强版的sql,来保持数据一致性，比如要主从之间复制当地时间，所以就需要在主机时，就将sql中的值修改为主机的获取当地时间。</p>
</li>
<li><p><strong>mixed</strong>：row这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>​    <code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p>​        <code>    binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>​    虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>​    首先我们先整体知道一下执行语句更新的时候，整体流程：在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/01-20220305234816065.png"></p>
<p> 所以想象这样一个场景，当redo log 写完之后，当写入bin log 时，数据库宕机了，这样就会导致bin log 并没有成功写完，所以就导致了从机通过bin log 同步数据的时候，和主机数据不一致（因为主机通过redo log 已经更改了数据）。</p>
<p>​    所以怎么解决这样一个问题呢，这明显是一个事务问题，所以我们这里就用了两阶段提交的方法，在更新数据之后，先将写redo log事务标记为prepare阶段，然后在写入bin log 之后，将redo log 事务标记为commit,然后就更新主机数据。这里就保证了数据的一致性。</p>
<p>那么对于这个流程，通过以下问题进一步深刻了解：</p>
<p>（1）有了bin log 为什么还需要redo log</p>
<ul>
<li>bin log 不知道数据库从哪一时刻丢了数据，所以只能从备份点开始对bin log 记录恢复数据，比较耗时，而redo log有一个check point</li>
<li>bin log 需要手动恢复数据，redo log是自动恢复</li>
<li>redo log 的wal+写缓存+异步刷盘提高IO利用</li>
</ul>
<p>（2）有了redo log 为什么还需要bin log</p>
<ul>
<li>bin log 是server 层的，redo log 是存储引擎innoDB的，其他存储引擎无法通过redo log 恢复</li>
<li>主从机之间是通过bin log复制。</li>
</ul>
<p>（3）保证数据一致性的流程</p>
<ul>
<li>如果在prepare阶段写完之后，在写bin log时宕机从机不会更改，此时重启mysql,通过redo log 恢复数据，看到redo log 事务的处于prepare阶段然后去判断bin log 是否有对应记录，因为还没有写完整，所以不会更改该redo log,这样主从就一致</li>
<li>如果在写bin log 之后，在提交的之前宕机，此时重启mysql,如果redo log是prepare,去判断bin log ，发现是完整的，然后就会更改主库</li>
<li>至于有了第二种情况，为什么还需要有commit,这是为了性能，因为每次都去判断bin log 难免效率太低下，所以一旦是commit,就直接提交</li>
</ul>
<h5 id="sql语句执行流程"><a href="#sql语句执行流程" class="headerlink" title="sql语句执行流程"></a>sql语句执行流程</h5><p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/13526879-3037b144ed09eb88.png"></p>
<p>以下面这条简单的 SQL 语句为例，我们来解释下执行器和 InnoDB 存储引擎在更新时做了哪些事情：</p>
<pre class="line-numbers language-none"><code class="language-none">updatetablesetage&#x3D;age+1whereid&#x3D;1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol>
<li>执行器：找<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D" >存储引擎<i class="fas fa-external-link-alt"></i></a>取到 id &#x3D; 1 这一行记录</li>
<li>存储引擎：根据主键索引树找到这一行，如果 id &#x3D; 1 这一行所在的数据页本来就在内存池（Buffer Pool）中，就直接返回给执行器；否则，需要先从磁盘读入<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%86%85%E5%AD%98%E6%B1%A0&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2280710259%7D" >内存池<i class="fas fa-external-link-alt"></i></a>，然后再返回</li>
<li>执行器：拿到存储引擎返回的行记录，把 age 字段加上 1，得到一行新的记录，然后再调用存储引擎的接口写入这行新记录</li>
<li>存储引擎：将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 <code>prepare</code> 状态。然后告知执行器执行完成了，随时可以提交事务<br>注意不要把这里的提交事务和我们 sql 语句中的提交事务 commit 命令搞混了哈，我们这里说的提交事务，指的是事务提交过程中的一个小步骤，也是最后一步。当这个步骤执行完成后，[commit 命令](<a class="link"   target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=commit" >https://www.zhihu.com/search?q=commit<i class="fas fa-external-link-alt"></i></a> 命令&amp;search_source&#x3D;Entity&amp;hybrid_search_source&#x3D;Entity&amp;hybrid_search_extra&#x3D;{“sourceType”%3A”answer”%2C”sourceId”%3A2280710259})就执行成功了。</li>
<li>执行器：生成这个操作的 bin log，并把 bin log 写入磁盘</li>
<li>执行器：调用存储引擎的提交事务接口</li>
<li>存储引擎：把刚刚写入的 redo log 状态改成提交（<code>commit</code>）状态，更新完成</li>
</ol>
<h2 id="day4-12-12"><a href="#day4-12-12" class="headerlink" title="day4 12.12"></a>day4 12.12</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>​    确保一个类只有一个实例，并提供该实例的全局访问点。</p>
<p>​    有六种实现方式：饿汉式、枚举式、懒汉式、同步锁、双重校验锁、静态内部类</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/2_singleton_1.png"></p>
<p>​    前面两种是初始化就加载对象，这种就需要满足初始化速度快而且占用内存小，不然会造成应用启动太慢。所以如果初始化速度慢或者占用内存大，就需要延迟加载，在初始化的时候不加载，而是使用的时候再加载，这样就节约了资源。</p>
<p>​    哪些时候需要初始化就加载，比如电商中的一些热点数据访问较多的，所以就可以提前加载，免得第一次访问还要去加载，而当有些数据可能很久都不会用到，这些就可以用到的时候再加载，避免了没用到时的资源浪费</p>
<p>（1）饿汉式：因为有new，所以就会直接加载类，后面会有类加载的时机，因为在初始化时就加载，所以不会存在线程安全问题。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

   <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（2）枚举：枚举的静态代码块本身就根据jvm的类加载机制加载，所以只有一次加载，因为是静态变量，所以存在于类中，不会因对象而改变，所以这里也是线程安全的</p>
<p>（3）懒汉式（线程不安全的版本）：因为多线程，所以if (uniqueInstance &#x3D;&#x3D; null) {这一段代码会有很多个线程进入，就造成了线程不安全</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（4）懒汉式同步锁：因为加了synchronized,所以性能消耗大</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>（5）双重校验锁（DCL）：</p>
<p>这是在懒汉式同步锁上因为加了synchronized关键字导致性能下降的优化，加锁操作只需要对实例化那部分的代码进行，</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>注意：（1）这里为什么要双重校验的，因为是多线程，所以进入第一个if的有很多线程，如果不要synchronized里面的if判断，那么线程都会最终执行uniqueInstance &#x3D; new Singleton();只是拿到锁的先执行，后来的就后执行，所以这里就不是单例模式了。</p>
<p>​            （2）这里的实例必须用volatile修饰，因为uniqueInstance &#x3D; new Singleton();这一句是分为三个步骤执行的</p>
<ul>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向分配的内存空间</li>
</ul>
<p>但是在jvm的优化下，有可能会产生指令重排，就会出现1-》3-》2的顺序，所以这时如果在执行了3还未执行2的时候，来了新的线程判断对象不为空，就会直接返回给调用方，但是因为此时还未执行2初始化对象，所以这个时候返回给调用方的对象是不正确的，就会导致出错，所以这里必须使用volatile来禁止指令重排</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/20200425180018774.png"></p>
<p>（6）静态内部类：因为初始化在加载外部类的时候，是不会加载内部类的（静态内部类就属于被动引用的行列），所以就实现了延迟加载，又因为这里getInstantce时并没有去new,而是去获得内部的变量，这时就加载该内部类，有因为是静态内部类，所以在jvm加载时自动就保证了线程安全。</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Singleton</span> INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token class-name">SingletonHolder</span><span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>使用单例模式的好处</strong> :</p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<h5 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h5><p>​    工厂模式分为三种：简单工厂、工厂方法、抽象工厂。</p>
<p>（1）简单工厂：就是将实例化的操作放在一个类来实现，调用方不用在意实例化的类的内部具体实现，只需要按照规则使用new对象即可。</p>
<p>工厂类：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleFactory</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token class-name">Product</span> <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>dev<span class="token operator">-</span>spec<span class="token operator">/</span>pattern<span class="token operator">/</span><span class="token number">3_</span>simple_factory<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>调用方：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">SimpleFactory</span> simpleFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Product</span> product <span class="token operator">=</span> simpleFactory<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// do something with the product</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
著作权归<span class="token annotation punctuation">@pdai</span>所有
原文链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>pdai<span class="token punctuation">.</span>tech<span class="token operator">/</span>md<span class="token operator">/</span>dev<span class="token operator">-</span>spec<span class="token operator">/</span>pattern<span class="token operator">/</span><span class="token number">3_</span>simple_factory<span class="token punctuation">.</span>html<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（2）工厂方法：生成一个接口，由子类去选择实例化哪个对象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 定义一个抽象的咖啡工厂
 * @author Lsj
 */</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>
    
    <span class="token comment">/**
     * 生产可制造的咖啡
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 中国咖啡工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChinaCoffeeFactory</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Cappuccino</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 美国咖啡工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericaCoffeeFactory</span> <span class="token keyword">extends</span> <span class="token class-name">CoffeeFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token keyword">new</span> <span class="token class-name">Americano</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 工厂方法测试
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryMethodTest</span> <span class="token punctuation">&#123;</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Coffee</span> coffee <span class="token operator">:</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>coffee<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">CoffeeFactory</span> chinaCoffeeFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChinaCoffeeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chinaCoffees <span class="token operator">=</span> chinaCoffeeFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中国咖啡工厂可以生产的咖啡有："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>chinaCoffees<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">CoffeeFactory</span> americaCoffeeFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericaCoffeeFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> americaCoffees <span class="token operator">=</span> americaCoffeeFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"美国咖啡工厂可以生产的咖啡有："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>americaCoffees<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>（3）抽象工厂：定义一系列有关的接口：也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * 抽象的饮料产品家族制造工厂
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token comment">/**
     * 制造咖啡
     * @return
     */</span>
    <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * 制造茶
     * @return
     */</span>
    <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/**
     * 制造碳酸饮料
     * @return
     */</span>
    <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 中国饮品工厂
 * 制造咖啡与茶
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChinaDrinksFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MilkTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 美国饮品制造工厂
 * 制造咖啡和碳酸饮料
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AmericaDrinksFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AbstractDrinksFactory</span> <span class="token punctuation">&#123;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Coffee</span> <span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Latte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Tea</span> <span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Sodas</span> <span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// TODO Auto-generated method stub</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">CocaCola</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span>


<span class="token comment">/**
 * 抽象工厂测试类
 * @author Lsj
 *
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactoryTest</span> <span class="token punctuation">&#123;</span>
    
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Drink</span> drink<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>drink <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品：--"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品："</span> <span class="token operator">+</span> drink<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token class-name">AbstractDrinksFactory</span> chinaDrinksFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ChinaDrinksFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Coffee</span> coffee <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Tea</span> tea <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Sodas</span> sodas <span class="token operator">=</span> chinaDrinksFactory<span class="token punctuation">.</span><span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"中国饮品工厂有如下产品："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>tea<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>sodas<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token class-name">AbstractDrinksFactory</span> americaDrinksFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AmericaDrinksFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        coffee <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createCoffee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        tea <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createTea</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sodas <span class="token operator">=</span> americaDrinksFactory<span class="token punctuation">.</span><span class="token function">createSodas</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"美国饮品工厂有如下产品："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>coffee<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>tea<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">print</span><span class="token punctuation">(</span>sodas<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="建造器模式"><a href="#建造器模式" class="headerlink" title="建造器模式"></a>建造器模式</h5><p>​    当我们需要实例化一个比较复杂类，而且还要根据要求实例化不同结构和不同内部状态的对象时，我们可以用类将其不同的实例化逻辑封装，这些类就叫建造者。</p>
<p>建造者分为四种角色：</p>
<ul>
<li>Product(产品类) :我们具体需要生成的类对象</li>
<li>Builder(抽象建造者类)：为我们需要生成的类对象，构建不同的模块属性，即：公开构建产品类的属性，隐藏产品类的其他功能</li>
<li>ConcreteBuilder(具体建造者类)：实现我们要生成的类对象</li>
<li>Director(导演类)：确定构建我们的类对象具体有哪些模块属性，在实际应用中可以不需要这个角色，直接通过client处理</li>
</ul>
<p>在电商中有多种不同类型的商品 <strong>普通实物商品</strong>，<strong>电子卡券商品</strong>，<strong>虚拟视频学习商品</strong> 等多种不同的商品，他们都是商品但是他们的属性却不一样，电子卡券：独有券码，学习视频：独有视频链接等。</p>
<p>具体:<a class="link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/h7iEyxgN34FPn191S8qUpA" >https://mp.weixin.qq.com/s/h7iEyxgN34FPn191S8qUpA<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5><p>​    原型模式出现的原因：场景：当我们实例化对象时需要耗费很多资源以及硬件密集型操作而且已有实例对象与新对象的各方面结构或者状态一致的话，我们可以通过克隆来产生新对象。</p>
<p>​    假设现在我们有这么一种场景，公司搞一场活动有五万个商品参加此次活动，我们需要从后台能定时同步每个商品的销量，方便我们为后面的活动做商品分析，我们要怎么处理这个销量同步问题？</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/clone.png"></p>
<p>​    这里设计浅拷贝和深拷贝。其实在其他的地方我们可以用到原型模式，比如我们在发松活动的PUSH通知，针对平台百万、千万、甚至上亿的用户发送通知的时候通知的内容基本都是一样的只是推送用户不一样或者有些特别字段值的小改动，那我们这里就可以用原型模式来做，同时开启多线程来做push，需要注意的是这里的线程安全问题，所以在每个线程内部去做copy对象。在一般情况下是不建议用这种模式的除非创建的对象成本特别大，或者在一些特殊场景使用</p>
<h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><h5 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h5><p>​    这个模式充分体现了设计原则中的最少知道原则，也就是说客户对象所需要交互的对象应当尽可能少。</p>
<p>​    外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口。</p>
<h5 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h5><p>适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。</p>
<p>​    例如spring mvc中的DispatcherServlet根据请求信息调用handlermappering,然后由handlerAadpter对目标类适配，就解决了不同类型的 <code>Controller</code> 通过不同的方法来对请求进行处理。</p>
<h2 id="day-5-12-13"><a href="#day-5-12-13" class="headerlink" title="day 5 12.13"></a>day 5 12.13</h2><h5 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h5><p>​    就是将抽象和实现分开，某些类型由于自身的逻辑，它具有两个或多个维度的变化，</p>
<ul>
<li>比如在电脑商城中有分类</li>
</ul>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/qiaojie.png"></p>
<p>我们用代码实现就需要台式电脑和笔记本继承电脑，然后华硕、小米继承台式以及继承笔记本，那这时增加了平板电脑（在电脑类型维度上变化），此时就需要增加华硕、小米继承平板电脑，这就导致了不是一个维度变化。还有这是增加了索尼品牌，也需要增加。所以我们这里如果根据桥接模式，就分为品牌和电脑类型，那么增加了电脑类型就只修改电脑类型，不会影响品牌。</p>
<ul>
<li>比如在driver驱动程序，有mysql的driver和OracleDriver，那么根据桥接模式实现，实现和抽象分开，driver和drivermanager分开，就能实现这种在driver和drivermanager维度变化互不影响</li>
</ul>
<h5 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h5><p>​    什么时候需要用到组合模式，当你想要将对象组合成树形结构，使单个对象和组合对象具有一致性的时候，这个时候就需要用到组合模式。</p>
<p>​    组合模式有三个角色：</p>
<ul>
<li>一个是统一的对象声明接口：对象都需要实现该接口。</li>
<li>一个是定义有枝节点行为，用来存储子部件。</li>
<li>一个是叶子节点，就是没有子节点</li>
</ul>
<h5 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h5><p>​    享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。比如我们的jdbc连接池，作为共享的对象，其中一个特点就是，该对象的某些属性值是相同的，那么就可以用享元模式，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p>
<h5 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h5><p>就是在装饰一个功能时，给被装饰者的功能加上对应的处理</p>
<h4 id="行为性设计模式"><a href="#行为性设计模式" class="headerlink" title="行为性设计模式"></a>行为性设计模式</h4><h5 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h5><p>将请求和接收方解耦，让多个接收对象都能够处理该请求，将这些对象串成一条链，并沿着该请求传递请求，直到链上某个对象处理该请求为止。</p>
<p>​    优点：</p>
<ul>
<li>增加新的请求处理类很方便。</li>
<li>降低耦合度。它将请求的发送者和接收者解耦。</li>
</ul>
<p>使用场景：SpringMVC中的 <strong>ServletFilter</strong>以及<strong>SpringInterceptor</strong>，</p>
<p>自己实现一个责任链设计模式来实现日志打印，不同的信息调用同一个接口，来实现日志打印的不同效果。</p>
<p>INFO打印在console,DEBUG打印在file中等等</p>
<p><a class="link"   target="_blank" rel="noopener" href="http://www.bjpowernode.com/shejimoshi/1599.html" >http://www.bjpowernode.com/shejimoshi/1599.html<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h5><p>​    当一个对象发现变化时，同时能够通知到与他相关的对象，当一个对象的状态发生改变时，已经登记的其他对象能够观察到这一改变从而作出自己相对应的改变。通过这种方式来达到减少依赖关系，解耦合的作用。</p>
<ul>
<li>Subject（主题）: 主要由类实现的可观察的接口，通知观察者使用attach方法，以及取消观察的detach方法。</li>
<li>ConcreteSubject（具体主题）: 是一个实现主题接口的类，处理观察者的变化</li>
<li>Observe（观察者）: 观察者是一个由对象水岸的接口，根据主题中的更改而进行更新。</li>
</ul>
<p>类似与消息队列的原理</p>
<p>​    熟悉JDK的人应该知道 在java.util 包下 除了常用的 集合 和map之外还有一个<strong>Observable</strong>类，他的实现方式其实就是观察者模式。里面也有<strong>添加、删除、通知</strong>等方法。</p>
<p>这里需要注意是的 他是用Vector 作为订阅关系的容器，同时在他的定义方法中都添加synchronized关键字修饰类，以达到线程安全的目的。</p>
<p>应用场景：当前现在有更加好的中间件<strong>MQ消息队列</strong>来处理这个业务问题，使得我们更加从容的面对这类场景问题，但是一些资源不足，不想引入新的系统。还是可以用这种方式来处理问题的。</p>
<h2 id="day-6-12-14"><a href="#day-6-12-14" class="headerlink" title="day 6 12.14"></a>day 6 12.14</h2><h5 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h5><p>​    定义一系列算法，封装每个算法，不同的策略可以调用不同的算法。</p>
<p>​    用大白话来讲，就是调用方根据不同的参数传入进去之后，会根据这个参数有不同的算法逻辑处理。</p>
<ul>
<li>Strategy（抽象策略）：抽象策略类，并且定义策略执行入口</li>
<li>ConcreteStrategy（具体策略）：实现抽象策略，实现algorithm方法</li>
<li>Context（环境）：运行特定的策略类。</li>
</ul>
<p>一个抽象策略接口Strategy，然后各种具体的策略实现该接口ConcreteStrategy，然后实现context来运行策略接口方法，</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/celue.png"></p>
<p>context对象：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">private</span> <span class="token class-name">Strategy</span> strategy<span class="token punctuation">;</span>
 
   <span class="token keyword">public</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token class-name">Strategy</span> strategy<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
 
   <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
      <span class="token keyword">return</span> strategy<span class="token punctuation">.</span><span class="token function">doOperation</span><span class="token punctuation">(</span>num1<span class="token punctuation">,</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyPatternDemo</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token class-name">Context</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationAdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 + 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationSubtract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 - 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
      context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OperationMultiply</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"10 * 5 = "</span> <span class="token operator">+</span> context<span class="token punctuation">.</span><span class="token function">executeStrategy</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>框架的应用：</p>
<p><strong>ThreadPoolExecutor</strong>中的里面实现线程池的异常策略,传入什么参数，就是什么策略</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/xianchengchi.png"></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/AFbt7VJMASenD2S8KbPKJQ" >https://mp.weixin.qq.com/s/AFbt7VJMASenD2S8KbPKJQ<i class="fas fa-external-link-alt"></i></a></p>
<h5 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h5><p>​    定义一个模板，模板里面有子类必须实现的接口（abstract），也有可以选择重写的接口，也有直接写好了的方法（final）</p>
<p>框架应用：HttpServlet 继承GenericServlet中也还是模版方法的体现，可以自己实现doget等</p>
<h5 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h5><p>​    我们可以用相同的方式处理集合，无论它是列表还是数组，它都提供了一种迭代其元素而不用暴露其内部结构的机制，更重要的是，不同的类型的集合都可以使用相同的统一机制</p>
<p> 这里需要注意在java 集合遍历的时候，是不允许增删数据的，因为会导致指针位置变化，导致遍历的时候，数据漏掉或重复。</p>
<h3 id="设计模式总结："><a href="#设计模式总结：" class="headerlink" title="设计模式总结："></a>设计模式总结：</h3><p><a class="link"   target="_blank" rel="noopener" href="http://www.bjpowernode.com/shejimoshi/1595.html" >http://www.bjpowernode.com/shejimoshi/1595.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://pdai.tech/md/dev-spec/pattern/1_overview.html" >https://pdai.tech/md/dev-spec/pattern/1_overview.html<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/AobingJava/JavaFamily" >https://github.com/AobingJava/JavaFamily<i class="fas fa-external-link-alt"></i></a></p>
<h2 id="day-7-12-15"><a href="#day-7-12-15" class="headerlink" title="day 7  12.15"></a>day 7  12.15</h2><h3 id="java-基础"><a href="#java-基础" class="headerlink" title="java 基础"></a>java 基础</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><h5 id="jdk、jre、jvm-jit编译器、Aot"><a href="#jdk、jre、jvm-jit编译器、Aot" class="headerlink" title="jdk、jre、jvm jit编译器、Aot"></a>jdk、jre、jvm jit编译器、Aot</h5><h5 id="为什么说java是解释与编译型语言结合"><a href="#为什么说java是解释与编译型语言结合" class="headerlink" title="为什么说java是解释与编译型语言结合"></a>为什么说java是解释与编译型语言结合</h5><p>​    编译型语言：直接编译为机器可以执行的代码，执行速度快，但是开发效率低，比如C++、GO等</p>
<p>​    解释型语言：<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E8%AA%9E%E8%A8%80" >解释型语言open in new window<i class="fas fa-external-link-alt"></i></a>会通过<a class="link"   target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8" >解释器open in new window<i class="fas fa-external-link-alt"></i></a>一句一句的将代码解释（interpret）为机器代码后再执行。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/compiled-and-interpreted-languages.png"></p>
<p>java 是先编译在解释：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/basis/java-code-to-machine-code.png"></p>
<h5 id="java-和C-的区别"><a href="#java-和C-的区别" class="headerlink" title="java 和C++的区别"></a>java 和C++的区别</h5><ul>
<li>java 没有指针，不能直接操作内存，程序更加安全，但其实是有unsafe类可以操作内存的，在cas中就是通过unsafe获取对应内存的值来比较，unsafe操作的是堆外内存</li>
<li>java 单继承</li>
<li>java 有自动垃圾回收机制（GC），C++没有，需要程序员自己手动释放</li>
<li>java 不支持运算符重载</li>
</ul>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul>
<li>对象存在于堆内存，局部变量则存在于栈内存</li>
<li>静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。静态变量会被 <code>final</code> 关键字修饰成为常量</li>
</ul>
<h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>​    静态变量和静态方法是属于类的，静态方法不能调用非静态成员或者非静态方法，因为静态是属于类的，在类的加载时就分配内存了，非静态方法属于对象的，类加载的时候，这时候没有对象，自然就不能调用非静态方法或者变量。</p>
<p>​    静态方法是通过类调用的</p>
<h4 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h4><p>​    重载是对同一个类的，重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理，下面就是对构造方法重载</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StringBuilder</span> sb2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"HelloWorld"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>重写就是子类在继承的时候，可以选择性的重写方法，要求方法名和参数都一致，返回值应该比夫类的返回值类型更小或相等，一般都是相等。但是，父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法。protected只能儿子继承。</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>八种基本数据类型：</p>
<p>  6种数字类型：byte short int long float double；1种字符类型：char，1种boolean</p>
<p><img src="/HexoBlog/2022/11/30/%E5%87%86%E5%A4%872/data.png"></p>
<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p> 1.包装类型和基本数据类型的区别：</p>
<ul>
<li>包装类型是对象，所以不赋值，默认就是null,而基本数据类型一般有默认值的</li>
<li>包装类型因为是对象，所以存在堆中，而基本数据类型的局部变量存在栈中</li>
</ul>
<p>2.包装类型的缓存机制</p>
<p><code>    Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210422164544846.png">    3.包装类型的自动拆装箱：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h4 id="浮点数运算丢失精度"><a href="#浮点数运算丢失精度" class="headerlink" title="浮点数运算丢失精度"></a>浮点数运算丢失精度</h4><p>​    这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p>
<p>​    用BigDecimal来实现浮点数计算，该包装类比较应该用compareto，对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对低。</p>
<h3 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h3><h4 id="对象的引用和对象实体"><a href="#对象的引用和对象实体" class="headerlink" title="对象的引用和对象实体"></a>对象的引用和对象实体</h4><ul>
<li>对象实体实在堆内存中，对象引用是在栈内存中。</li>
<li>对象的相等一般比较的是内存中存放的内容是否相等，引用相等一般比较的是他们指向的内存地址是否相等。</li>
</ul>
<h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>浅拷贝在拷贝的时候，如果拷贝的有引用类型，直接指向该引用类型，而深拷贝是拷贝引用类型时，新建一个该引用类型的对象，然后赋值引用。这里主要体现在链表的操作：分割链表。</p>
<h4 id="Object常用方法"><a href="#Object常用方法" class="headerlink" title="Object常用方法"></a>Object常用方法</h4><p>​    equal方法，引用比较的是对象的内存地址，因为本身就是存储的对象的值。不重写默认就是&#x3D;&#x3D;</p>
<p>​    hashcode，<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回，那么为什么需要hashcode呢，因为在hashmap、hashset中是根据hashcode来快速确定对象的位置，提高效率，不用一个一个去比较。</p>
<ul>
<li><p>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</p>
</li>
<li><p>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</p>
</li>
</ul>
<p>重写equal时也必须重写hashcode,因为重写了equal导致有可能导致对象equal返回true,但是hashcode不一样。</p>
<h4 id="String类："><a href="#String类：" class="headerlink" title="String类："></a>String类：</h4><p>1.String、Stringbuilder、StringBuffer</p>
<ul>
<li>String：不可变，因为由final和private修饰的value（且没有暴露操作value的方法）,操作string对象，然后将指针指向新的 <code>String</code> 对象。。线程安全</li>
<li>StringBuilder：可变，并没有对方法进行加同步锁，所以是非线程安全的。</li>
<li>StringBuffer：<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</li>
</ul>
<p>2.<strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>

        </div>

        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/HexoBlog/tags/%E5%87%86%E5%A4%87/">#准备</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/HexoBlog/2022/11/29/%E5%87%86%E5%A4%871/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">准备1</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">lj</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#day1"><span class="nav-number">1.</span> <span class="nav-text">day1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql"><span class="nav-number">1.1.</span> <span class="nav-text">mysql</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">存储引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">1.存储引擎是什么，</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-mysql%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">2.mysql中常见的存储引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">数据库的事务隔离级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E7%B4%A2%E5%BC%95"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">mysql 索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%BB%E9%94%AE%E9%80%9A%E5%B8%B8%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9Eid"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">为什么主键通常建议使用自增id</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day2"><span class="nav-number">2.</span> <span class="nav-text">day2</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MyISAM-%E5%92%8C-InnoDB-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">MyISAM 和 InnoDB 如何选择？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MySQL-%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">MySQL 查询缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVCC"><span class="nav-number">2.0.0.3.</span> <span class="nav-text">MVCC</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.0.0.3.1.</span> <span class="nav-text">MVCC 是什么</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="nav-number">2.0.0.3.2.</span> <span class="nav-text">当前读和快照读</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8A%E5%A5%BD%E5%A4%84"><span class="nav-number">2.0.0.3.3.</span> <span class="nav-text">MVCC 解决的问题以及好处</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB%E3%80%81%E5%BF%AB%E7%85%A7%E8%AF%BB%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.0.0.3.4.</span> <span class="nav-text">MVCC和当前读、快照读的关系</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4%E4%B8%AA%E9%9A%90%E5%BC%8F%E5%AD%97%E6%AE%B5"><span class="nav-number">2.0.0.3.5.</span> <span class="nav-text">4个隐式字段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#undo-log"><span class="nav-number">2.0.0.3.6.</span> <span class="nav-text">undo log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#read-view%EF%BC%88%E8%AF%BB%E8%A7%86%E5%9B%BE%EF%BC%89"><span class="nav-number">2.0.0.3.7.</span> <span class="nav-text">read view（读视图）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#MVCC%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9ARR%E5%92%8CRC%E7%BA%A7%E5%88%AB%E4%B8%8B%E7%9A%84read-view"><span class="nav-number">2.0.0.3.8.</span> <span class="nav-text">MVCC相关问题：RR和RC级别下的read view</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-3-12-5"><span class="nav-number">3.</span> <span class="nav-text">day 3 12.5</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E9%94%81"><span class="nav-number">3.0.0.1.</span> <span class="nav-text">mysql 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%A8%E9%94%81%E5%92%8C%E8%A1%8C%E9%94%81"><span class="nav-number">3.0.0.1.1.</span> <span class="nav-text">表锁和行锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">3.0.0.1.2.</span> <span class="nav-text">行锁的使用的注意事项</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="nav-number">3.0.0.1.3.</span> <span class="nav-text">共享锁和排他锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-number">3.0.0.1.4.</span> <span class="nav-text">意向锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#innoDb-%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A1%8C%E9%94%81"><span class="nav-number">3.0.0.1.5.</span> <span class="nav-text">innoDb 有哪些行锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#mysql-%E4%B8%89%E5%A4%A7%E6%97%A5%E5%BF%97"><span class="nav-number">3.0.0.2.</span> <span class="nav-text">mysql 三大日志</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#redo-log"><span class="nav-number">3.0.0.2.1.</span> <span class="nav-text">redo log</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#redo-log%E5%B0%8F%E7%BB%93"><span class="nav-number">3.0.0.2.2.</span> <span class="nav-text">redo log小结</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bin-log"><span class="nav-number">3.0.0.2.3.</span> <span class="nav-text">bin log</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">3.0.0.3.</span> <span class="nav-text">两阶段提交</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sql%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">3.0.0.4.</span> <span class="nav-text">sql语句执行流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day4-12-12"><span class="nav-number">4.</span> <span class="nav-text">day4 12.12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.</span> <span class="nav-text">创建型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">单例模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.2.</span> <span class="nav-text">工厂模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BB%BA%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.3.</span> <span class="nav-text">建造器模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.1.4.</span> <span class="nav-text">原型模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.</span> <span class="nav-text">结构型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">外观模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">适配器模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-5-12-13"><span class="nav-number">5.</span> <span class="nav-text">day 5 12.13</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.1.</span> <span class="nav-text">桥接模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.2.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.3.</span> <span class="nav-text">享元模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.0.4.</span> <span class="nav-text">装饰器模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%8C%E4%B8%BA%E6%80%A7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.</span> <span class="nav-text">行为性设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.1.</span> <span class="nav-text">责任链模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.0.1.2.</span> <span class="nav-text">观察者模式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-6-12-14"><span class="nav-number">6.</span> <span class="nav-text">day 6 12.14</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.1.</span> <span class="nav-text">策略模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.2.</span> <span class="nav-text">模板方法模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.0.0.3.</span> <span class="nav-text">迭代器模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="nav-number">6.1.</span> <span class="nav-text">设计模式总结：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day-7-12-15"><span class="nav-number">7.</span> <span class="nav-text">day 7  12.15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-%E5%9F%BA%E7%A1%80"><span class="nav-number">7.1.</span> <span class="nav-text">java 基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">7.1.1.</span> <span class="nav-text">基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#jdk%E3%80%81jre%E3%80%81jvm-jit%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%81Aot"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">jdk、jre、jvm jit编译器、Aot</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4java%E6%98%AF%E8%A7%A3%E9%87%8A%E4%B8%8E%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%BB%93%E5%90%88"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">为什么说java是解释与编译型语言结合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#java-%E5%92%8CC-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">java 和C++的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">基础语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">7.2.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81"><span class="nav-number">7.2.2.</span> <span class="nav-text">静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">7.2.3.</span> <span class="nav-text">重载和重写</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.1.</span> <span class="nav-text">包装类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B8%A2%E5%A4%B1%E7%B2%BE%E5%BA%A6"><span class="nav-number">7.3.2.</span> <span class="nav-text">浮点数运算丢失精度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="nav-number">7.4.</span> <span class="nav-text">面向对象基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BD%93"><span class="nav-number">7.4.1.</span> <span class="nav-text">对象的引用和对象实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">7.4.2.</span> <span class="nav-text">深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Object%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">7.4.3.</span> <span class="nav-text">Object常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E7%B1%BB%EF%BC%9A"><span class="nav-number">7.4.4.</span> <span class="nav-text">String类：</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/HexoBlog/js/utils.js"></script>

<script src="/HexoBlog/js/main.js"></script>

<script src="/HexoBlog/js/header-shrink.js"></script>

<script src="/HexoBlog/js/back2top.js"></script>

<script src="/HexoBlog/js/dark-light-toggle.js"></script>





    
<script src="/HexoBlog/js/code-copy.js"></script>





<div class="post-scripts">
    
        
<script src="/HexoBlog/js/left-side-toggle.js"></script>

<script src="/HexoBlog/js/libs/anime.min.js"></script>

<script src="/HexoBlog/js/toc.js"></script>

    
</div>



</body>
</html>
